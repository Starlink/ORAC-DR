# -*-perl-*-

=head1 NAME

_CREATE_NOISE_MAP_ - Create a map of the noise for a given cube.

=head1 DESCRIPTION

This primitive is used to create a noise map. It first masks out
emission regions using a previously-defined mask (see
_CREATE_BASELINE_MASK_), and then collapses the resulting cube along
the frequency axis using the RMS estimator.

=head1 ARGUMENTS

=over 4

=item GROUP = INTEGER (Given)

How to process group files. 0 means use the current Frame object. 1
means use the current Group object. 2 means use each Frame member of
the current Group object. [0]

=item QA = LOGICAL (Given)

Whether or not to perform quality assurance calculations on the
resulting noise map. [0]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS cubes.

=item *

Neither the current Frame nor the current Group object are updated.

=back

=head1 OUTPUT DATA

=over 4

=item *

The noise map with suffix _noise.

=back

=head1 TASKS

KAPPA: ADD, COLLAPSE, PASTE.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All Rights Reserved.

=cut

# Bring in Starlink::HDSPACK for NDF creation.
use Starlink::HDSPACK qw/ create_hdsobj copy_hdsobj /;

# Handle parameters.
my $freqsmooth = get_prim_arg( $_PRIM_ARGS_, "FREQUENCY_SMOOTH", 25 );
my $group = get_prim_arg( $_PRIM_ARGS_, "GROUP", 0 );
my $order = get_prim_arg( $_PRIM_ARGS_, "ORDER", 5 );
my $qa = get_prim_arg( $_PRIM_ARGS_, "QA", 0 );
my $spatsmooth = get_prim_arg( $_PRIM_ARGS_, "SPATIAL_SMOOTH", 3 );

# Figure out what we're doing with groups/frames.
my @objs;
if( $group == 0 ) {
  push @objs, $Frm;
} elsif( $group == 1 ) {
  push @objs, $Grp;
} elsif( $group == 2 ) {
  @objs = $Grp->members;
} else {
  orac_throw "Programming error: GROUP parameter to _CREATE_NOISE_MAP_ must be 0, 1, or 2";
}

if( $group != 1 || ( $group == 1 && $Grp->lastmember( $Frm ) ) ) {

  if( ! ( $group == 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) ) {

    foreach my $Obj ( @objs ) {

      my ( undef, $out ) = $Obj->inout( "_noise" );

      # Mask and collapse each of the files making up the current object.
      my @collapsed;

      foreach my $i ( 1 .. $Obj->nfiles ) {

        my ( $in, undef ) = $Obj->inout( "_noise", $i );

        if( $Obj->uhdr( "SPARSE" ) ) {

          orac_warn $Obj->file( $i ) . " is a sparse cube. Cannot create noise map for a sparse cube.\n";

        } else {

          orac_say "Creating noise map for $in.";

          my $collapsed = new ORAC::TempFile;

          # Check to see if we have a variance component. If so,
          # collapse that using MEAN (to preserve the frequency
          # bounds).
          $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$in" );
          my ( $ORAC_STATUS, $varexists ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "variance" );

          if( uc( $varexists ) eq 'TRUE' ) {

            orac_say " Using variance array in $in to create temporary noise map.";

            my $tempfile = new ORAC::TempFile;

            # Collapse. This gives us the variance when we want the RMS, remember.
            $Mon{'kappa_mon'}->obeyw( "collapse", "in=$in out=$tempfile axis=spec wlim=0.0 estimator=mean comp=var" );

            # Take the square root.
            $Mon{'kappa_mon'}->obeyw( "pow", "in=$tempfile out=$collapsed power=0.5" );

          } else {

            # Create a baseline mask if we don't already have one.
            if( ! defined( $Obj->uhdr( "BASELINE_MASKS" ) ) ) {

              _CREATE_BASELINE_MASK_ GROUP=$group FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order

            }

            my $masks = $Obj->uhdr( "BASELINE_MASKS" );
            my $mask = $masks->[$i];

            # Mask out emission.
            orac_say " Masking out lines using $mask.";
            my $masked = new ORAC::TempFile;
            my $params = "in1=$in in2=$mask out=$masked";
            $Mon{'kappa_mon'}->obeyw( "add", "$params" );

            # Collapse the cube.
            orac_say " Collapsing to form temporary noise map.";
            $params  = "in=$masked out=$collapsed estimator=rms ";
            $params .= "axis=SPEC wlim=0.0 trim=false variance=false";
            $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

          }

          push @collapsed, $collapsed;

        }

      }

      # At this point we've collapsed all of the tiles for the given Obj, so paste them all together. Of course, just copy it over if there's only one.
      if( scalar( @collapsed ) == 1 ) {

        $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$collapsed[0] out=$out" );

      } else {

        orac_say "\n Pasting together temporary noise maps to form full noise map.";

        _PASTE_FILES_ FILES=\@collapsed OUT=$out

      }

      orac_say "Created noise map in $out.";

      _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRODUCT VALUE=noise
      $Obj->sync_headers;

      # Copy the output to a group file if requested.
      if( $group != 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) {
        ( undef, my $groupout ) = $Grp->inout( "_noise" );

        $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$out out=$groupout" );

        my $tGrp = new $Grp;
        $tGrp->groupid( $Grp->groupid );
        $tGrp->allow_header_sync(1);
        $tGrp->file( $groupout );

        orac_say "$out to $groupout:";
        orac_say " Copied to Group file.";
      }

      orac_say "";

      # Run QA if requested.
      if( $qa ) {
        _QA_MAP_RMS_SPATIAL_UNIFORMITY_ FILE=$out CENTRAL=50
      }

    }
  }
}

