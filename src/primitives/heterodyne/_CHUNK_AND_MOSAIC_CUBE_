=head1 NAME

_CHUNK_AND_MOSAIC_CUBE_ -- Creates a cube by dividing a group of time-series
ACSIS observations into chunks.

=head1 DESCRIPTION

This primitive divides time-series ACSIS cubes from each observation, supplied
as an array of NDF names, into more manageable subsets.  It then runs MAKECUBE
on each subset to create a spatial/spectral cube, divided into tiles if a
maximum tile size is exceeded.  For each tile that would have been created had
MAKECUBE processed all the time series simultaneously, data are summed from
the chunked spatial/spectral cubes which intersect that tile,  The summed data
are trimmed to the tile pixel bounds.

The goal is to mimic MAKECUBE processing all the supplied time series, but
without causing a timeout or excessive memory demands.

=head1 ARGUMENTS

=over 4

=item CHUNKSIZE = INTEGER (Given)

The maximum subset size in megabytes.  [5120]

=item FILES = ARRAY REFERENCE (Given)

A reference to an array containing filenames to be formed into a spatial/spectral
cube.

=item MAKECUBE_PARAMS = STRING (Given)

The parameter values for MAKECUBE excluding the name of the IN and OUT parameters.

=item MEAN_CHUNKSIZE = INTEGER (Given)

The average subset size in megabytes.

=item NUM_CHUNK = INTEGER (Given)

The number of subsets.

=item TILEDIMS = INTEGER (Given)

The tile size in pixels along both spatial axes.

=item TOTALSIZE = INTEGER (Given)

The total size in megabytes of all the time series listed in TIMESERIES.

=item TOTALTILE = INTEGER (Given)

The total number of tiles that MAKECUBE would create processing all
the time-series data files.

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=item *

It serves _CREATE_CUBE_GROUP_ from where the supplied arguments to this
primitive are either parameters or are evaluated.

=back

=head1 OUTPUT DATA

=over 4

=item *

A cube (or set of cubes) whose filename is of the form
gaYYYYMMDD_NN_SS_cubeMMM.sdf, where YYYYMMDD is the UT date, NN is the
observation number, SS is the zero-padded subsystem number, and MMM is
the zero-padded tile number. Tiles are numbered starting from 1 and
increasing monotonically, counting from the bottom-left corner in
spatial extent and proceeding in a raster fashion from left to right.

=back

=head1 TASKS

CCDPACK: MAKEMOS.
KAPPA: DIV, MATHS, MSTATS, NDFCOPY, NDFTRACE, SETBB, SHOWQUAL, STATS.
SMURF: MAKECUBE.

=head1 REQUIRED PERL MODULES

File::Copy.

=head1 AUTHORS

Malcolm J. Currie E<lt>mjc@star.rl.ac.ukE<gt>

=head1 COPYRIGHT

Copyright (C) 2010-2011 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

use File::Copy;
use constant MEGABYTE => 1048576;

my $files = get_prim_arg( $_PRIM_ARGS_, "FILES", undef );
if ( ! defined( $files ) ) {
  orac_throw "FILES argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $params = get_prim_arg( $_PRIM_ARGS_, "MAKECUBE_PARAMS", undef );
if ( ! defined( $params ) ) {
  orac_throw "MAKECUBE_PARAMS argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $mean_chunksize = get_prim_arg( $_PRIM_ARGS_, "MEAN_CHUNKSIZE", undef );
if ( ! defined( $mean_chunksize ) ) {
  orac_throw "MEAN_CHUNKSIZE argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $num_chunk = get_prim_arg( $_PRIM_ARGS_, "NUM_CHUNK", undef );
if ( ! defined( $num_chunk ) ) {
  orac_throw "NUM_CHUNK argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $tiledims = get_prim_arg( $_PRIM_ARGS_, "TILEDIMS", undef );
if ( ! defined( $tiledims ) ) {
  orac_throw "TILEDIMS argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $totalsize = get_prim_arg( $_PRIM_ARGS_, "TOTALSIZE", undef );
if ( ! defined( $totalsize ) ) {
  orac_throw "TOTALSIZE argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $totaltile = get_prim_arg( $_PRIM_ARGS_, "TOTALTILE", undef );
if ( ! defined( $totaltile ) ) {
  orac_throw "TOTALTILE argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $chunksize = get_prim_arg( $_PRIM_ARGS_, "CHUNKSIZE", 5120 );

# Will a TSYS be created?

my $tsys_present = 0;
if ( lc( $params ) =~ /spread=nearest/ ) {
   $tsys_present = 1;

} elsif ( !( lc( $params ) =~ /spread=/ ) ) {
   $tsys_present = 1;
}

# Divide the list into manageable chunks to prevent a timeout.
# ============================================================

# The approach is to attempt to reduce each observation separately
# on the same grid of tiles, and only chunk an observation if it
# contains too much data.  Then combine each observation of a tile.
# Thus edge artefacts from smoothing in chunks rather than the
# observation as whole is reduced.

# We want to find the extreme bounds of the tiles.  The central tile
# is symmetric around bound (0,0).  Initialise the limits accordingly.
my @full_lb = ( 1, 1 );
my @full_ub = ( -1, -1 );

my $fi = 0;
my @chunk_ntile;
my $chunk_index = 0;
my $sumsize = 0;
my @chfiles;
my $num_files = @$files;
my $ORAC_STATUS;

# Allocate files to chunks.
# -------------------------

# Look at each input file and see if it needs chunking.
foreach my $i ( 1 .. $num_files ) {
   my $fullname = $files->[ $i - 1 ] . ".sdf";
   my $filesize = ( -s $fullname ) / MEGABYTE;

# Continue to add files to the current chunk until the size limit
# is surpassed.  Spectral-cube formation is always required for
# the last file in the group.  Also because of the quantisation
# enlarge the chunk size to the maximum for the final chunk so
# that it can encompass all the remaining input time-series files.
   my $use_chunksize = ( $chunk_index == $num_chunk ) ? $chunksize : $mean_chunksize;
   if ( ( $sumsize + $filesize ) <= $use_chunksize && $i < $num_files ) {
      $sumsize += $filesize;
      push @chfiles, $files->[ $fi ];
      $fi++;

   } else {

# Append the final input time-series file to the the list for the final chunk.
      if ( $i == $num_files ) {
         push @chfiles, $files->[ $fi ];
         $fi++;
      }

# Find and report the number of files in the chunk.
      my $chunk = @chfiles;
      my $string = ( $chunk == 1 ) ? "file" : "files";
      $chunk_index++;
      orac_print "Chunk: $chunk_index contains $chunk $string.\n";

# Form spatial/spectral cube.
# ---------------------------

# Form text file listing the chunk's members for MAKECUBE.
      my $chlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
      my $chlist_fh = $chlist->handle;

      for ( my $k = 0; $k < $chunk; $k++ ) {
         print $chlist_fh $chfiles[ $k ] . "\n";
      }
      $chlist->handle->close;

# Form tiles for current chunk.  Use a suffix to delineate the chunks.
      my ( $in, $out ) = $Grp->inout( "_cube" );
      $out .= "_ch" . "$chunk_index";

# Process the current manageable chunk of input time series into spectral
# cubes.
      orac_print "Creating cube $out from " . join( ", ", @chfiles ) . "...\n";

      $Mon{'smurf_mon'}->obeyw( "makecube", "$params in='^" . $chlist->file . "' out=$out" );
      orac_say "done.";
      undef $chlist;

# Find and record the number of tiles in the current chunk.
      ( $ORAC_STATUS, my $ntile ) = $Mon{'smurf_mon'}->get( "makecube", "ntile" );
      push @chunk_ntile, $ntile;

# Mask border pixels.
# -------------------
      if ( $ntile > 1 ) {

# Create a text file listing all the input tiles with a border.
         my $inlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
         my $inlist_fh = $inlist->handle;

# Create a text file listing all the output tiles without a border.
         my $outlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
         my $outlist_fh = $outlist->handle;

# The tiles should be in same places as if all the input time series
# were turned into a spatial/spectral cube in one invocation of MAKECUBE.
# However, not all will be occupied with data from this subset.
         my @tmp;
         foreach my $i ( 1.. $totaltile ) {
            my $ch_tile = $out . "_" . $i;
            if ( -e $ch_tile . ".sdf" ) {
               my $trim_ch_tile = new ORAC::TempFile;

# Determine whether there is a BORDER quality flag set.
               if ( starversion_gt( 'KAPPA', 'V1.13-0' ) ) {
                  $Mon{'ndfpack_mon'}->obeyw( "showqual", "ndf=$ch_tile" );
                 ( $ORAC_STATUS, my @qnames ) = $Mon{'ndfpack_mon'}->get( "showqual", "qnames" );

# Add those with a border to the list of files to mask.  As the times
# are summed, there is a need to mask the exposure-time and effective-time
# arrays too, but these do not have QUALITY.  The approach is to use
# the bounds of the bad-pixel trimmed DATA_ARRAY for all the SMURF
# arrays too.
                  foreach my $element ( @qnames ) {
                     if ( $element eq "BORDER" ) {
                        print $inlist_fh "$ch_tile\n";
                        print $outlist_fh "$trim_ch_tile\n";
                        push @tmp, $trim_ch_tile;
                        last;
                     }
                  }

# Have to keep fingers crossed that all tiles have a border.  I can
# only think of messy ways to search for the QUALITY_NAMES without the
# SHOWQUAL output parameter.
               } else {
                  print $inlist_fh "$ch_tile\n";
                  print $outlist_fh "$trim_ch_tile\n";
               }
            }
         }
         $inlist->handle->close;

         $Mon{'ndfpack_mon'}->obeyw( "setbb", "ndf='^" . $inlist->file . "' bb=BORDER" );

# Trim the border, now comprising bad pixels in each chunk.  Copy each
# back to its original name, as if nothing had happened.
         my $trim_param = "in='^" . $inlist->file . "' out='^" . $outlist->file . "'";
         $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$trim_param trimbad" );

         $trim_param = "in='^" . $outlist->file . "' out='^" . $inlist->file . "'";
         $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$trim_param" );

         undef $inlist;
         undef $outlist;

# Not sure why the temporary NDFs are not being removed outside the
# context.
         foreach my $element ( @tmp ) {
            undef $element;
         }

# There is only the one tile, and MAKECUBE omits the tile-index suffix.
      } else {
         $Mon{'ndfpack_mon'}->obeyw( "setbb", "ndf=$out bb=BORDER" );

# Trim the border, now comprising bad pixels.  Copy back to the
# original name, as if nothing had happened.
         my $trim_ch_tile = new ORAC::TempFile;
         $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$out out=$trim_ch_tile trimbad" );
         $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$trim_ch_tile out=$out" );
      }

# Assign tiles in the current chunk to their index within the full set
# of tiles, as if processing all the time series simultaneously.
# --------------------------------------------------------------------

# The tiles are always numbered from 1 at the lower left to $ntile at
# the upper right.  Thus the lower bound of the first tile will be most
# negative and the upper bound of the last tile will be the most positive.
      my $lb_file= ( $ntile > 1 ) ? $out . "_1" : $out;
      _GET_DIMENSIONS_ FILE=$lb_file
      my @lbnd = @{$_GET_DIMENSIONS_{LBOUND}};
      $full_lb[0] = min( $lbnd[0], $full_lb[0] );
      $full_lb[1] = min( $lbnd[1], $full_lb[1] );

      my $ub_file= ( $ntile > 1 ) ? $out . "_" . $ntile : $out;
      _GET_DIMENSIONS_ FILE=$ub_file
      my @ubnd = @{$_GET_DIMENSIONS_{UBOUND}};
      $full_ub[0] = max( $ubnd[0], $full_ub[0] );
      $full_ub[1] = max( $ubnd[1], $full_ub[1] );

# Start a new list of files for the new chunk.
      if ( $i < $num_files ) {
         @chfiles = ( $files->[ $fi ] );
         $sumsize = $filesize;
         $fi++;
      }
   }
}

my $total_chunk = $chunk_index;
orac_print "Spatial extent of tiles is (" . $full_lb[0] . "," .
           $full_lb[1] . ") to (" . $full_ub[0] . "," . $full_ub[1] .")\n";

# Assign files in each chunk to the grand-mosaic tiles.
# =====================================================
#
( undef, my $out ) = $Grp->inout( "_cube" );
if ( $total_chunk > 1 ) {

# Find the bounds of the grand-mosaic tiles.
# ------------------------------------------

# Reset the tile dimensions to the original value.
   $tiledims *= -1;

# Find the number of tiles along each spatial axis, and hence the x-y
# indices of the centre.  This assumes that the reference point is at the
# centre of a tile.
   my $nx = int( $full_ub[0] / $tiledims + 0.5 ) + 1 +
            int( abs( $full_lb[0] ) / $tiledims + 0.5 );
   my $ny = int( $full_ub[1] / $tiledims + 0.5 ) + 1 +
            int( abs( $full_lb[1] ) / $tiledims + 0.5 );
   my @centre_index;
   $centre_index[0] = int( ( $nx + 1 ) / 2 );
   $centre_index[1] = int( ( $ny + 1 ) / 2 );

   my ( @tiles_main, @tiles_exp_time, @tiles_eff_time, @tiles_tsys );

# Store the tile spatial upper and lower bounds, constrained by the actual
# limiting bounds.  The bounds must always be integer so apply the half-tile
# shift as integer.  Also the limits are not symmetric, being offset from
# (1,1) not (0,0).
   my ( @tile_xl, @tile_xu, @tile_yl, @tile_yu );
   my $halftile = int( ( $tiledims ) / 2 );
   my $oddtile = $tiledims % 2;
   foreach my $c ( 1 .. $totaltile ) {
      my $xi = ( $c - 1 ) % $nx + 1;
      my $yi = int( ( $c - 1 ) / $nx ) + 1;
      $tile_xl[$c] = max( $full_lb[0], 1 - $halftile +
                          ( $xi - $centre_index[0] ) * $tiledims );
      $tile_xu[$c] = min( $full_ub[0], $halftile + $oddtile +
                          ( $xi - $centre_index[0] ) * $tiledims );

      $tile_yl[$c] = max( $full_lb[1], 1 - $halftile +
                          ( $yi - $centre_index[1] ) * $tiledims );
      $tile_yu[$c] = min( $full_ub[1], $halftile + $oddtile +
                          ( $yi - $centre_index[1] ) * $tiledims );
   }

# Assign portions of each chunk to tiles.
# ---------------------------------------
   foreach my $c ( 1 .. $total_chunk ) {
      foreach my $t ( 1 .. $chunk_ntile[$c - 1] ) {
         my $chunk_file = $out . "_ch" . $c;
         if ( $chunk_ntile[$c - 1] > 1 ) { $chunk_file .= "_" . $t }

# The spanned tiles need not be contiguous if data from two frames are
# combined.
         if ( -e $chunk_file . ".sdf" ) {
            _GET_DIMENSIONS_ FILE=$chunk_file
            my @lbnd = @{$_GET_DIMENSIONS_{LBOUND}};
            my @ubnd = @{$_GET_DIMENSIONS_{UBOUND}};
            orac_print "\nChunk: $chunk_file has bounds ($lbnd[0],$lbnd[1]) to ($ubnd[0],$ubnd[1]).\n";

# Find the tile indices that the current chunk spans along each axis,
# using the offsets from the centre (0,0).
            my @ti_lb = ( 0, 0 );
            my @ti_ub = ( 0, 0 );
            for ( my $i = 0; $i < 2; $i++ ) {
               $ti_lb[$i] = int( $lbnd[$i] / $tiledims +
                                 ( $lbnd[$i] >= 0 ? +1 : -1 ) * 0.5 ) + $centre_index[$i];
               $ti_ub[$i] = int( $ubnd[$i] / $tiledims +
                                 ( $ubnd[$i] >= 0 ? +1 : -1 ) * 0.5 ) + $centre_index[$i];
            }
            orac_print "Tiles: $chunk_file spans tiles ($ti_lb[0],$ti_lb[1]) to ($ti_ub[0],$ti_ub[1]).\n";

# Convert the x-y indices to a tile index to store the contributing chunk
# names, constrained with bounds to lie solely within the tile.  Apply
# to each SMURF NDF too.
            my $tileindex;
            my $tile_section;
            for ( my $j = $ti_lb[1]; $j <= $ti_ub[1]; $j++ ) {
               for ( my $i = $ti_lb[0]; $i <= $ti_ub[0]; $i++ ) {
                  $tileindex = $i + $nx * ( $j - 1 );
                  $tile_section = "($tile_xl[$tileindex]:$tile_xu[$tileindex],$tile_yl[$tileindex]:$tile_yu[$tileindex],)";
                  $tiles_main[$tileindex] .= $chunk_file . $tile_section . " ";
                  $tiles_eff_time[$tileindex] .= $chunk_file . ".MORE.SMURF.EFF_TIME" . $tile_section . " ";
                  $tiles_exp_time[$tileindex] .= $chunk_file . ".MORE.SMURF.EXP_TIME" . $tile_section . " ";
                  if ( $tsys_present ) { $tiles_tsys[$tileindex] .= $chunk_file . ".MORE.SMURF.TSYS" . $tile_section . " " }
                  orac_print "File " . $chunk_file . " is in Tile " . $tileindex . ".\n";
               }
            }
         }
      }
   }

# Reassemble each tile as it if were created by MAKECUBE.
# =======================================================
   foreach my $c ( 1 .. $totaltile ) {

# Extract the number and names of the NDFs to combine.
      $tiles_main[$c] =~ s/^\s+//;
      my @frames = split ( ' ', $tiles_main[$c] );
      my $nframe = @frames;

# Mimic MAKECUBE's output-NDF naming convention, i.e. exclude the
# _<tile> suffix if there is only one tile.
      my $mmout = ( $totaltile > 1 ) ? $out . "_" . $c : $out;

      if ( $nframe > 1 ) {

# Form trimmed mosaic.
# --------------------

# Form text file listing the tile's contributing chunks for MAKEMOS.
         my $mmlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
         my $mmlist_fh = $mmlist->handle;

         my $mm_params = "usevar method=mean genvar nozero noscale";
         foreach my $i ( 1.. $nframe ) {
            print $mmlist_fh $frames[ $i - 1 ] . "\n";
         }
         $mmlist->handle->close;

# Combine the tiles as if we had processed all the data in one MAKECUBE
# invocation.  However, it cannot be tackled in one pass; while MAKECUBE
# knows about the SMURF extensions that are also NDFs, MAKEMOS does not.

# First combine the main arrays.
         my $mmout = $out . "_" . $c;
         orac_print "\nRunning MAKEMOS on Tile $c to form $mmout from:\n";
         foreach my $i ( 1.. $nframe ) {
            orac_print "  " . $frames[ $i - 1 ] . "\n";
         }
         $Mon{'ccdpack_reg'}->obeyw( "makemos", "$mm_params in='^" . $mmlist->file . "' out=$mmout" );
         orac_print "  done.\n\n";
         undef $mmlist;

# Sum the EXP_TIME NDFs.
# ----------------------

# Delete the existing version of the extension NDF in the output file.
         my $exp_time_out = $mmout . ".MORE.SMURF.EXP_TIME";
         $Mon{'ndfpack_mon'}->obeyw( "erase", "object=$exp_time_out ok" );

# Form text file listing the tile's contributing EXP_TIME chunks to sum.
         my $mslist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
         my $mslist_fh = $mslist->handle;

         @frames = split ( ' ', $tiles_exp_time[$c] );
         foreach my $i ( 1.. $nframe ) {
            print $mslist_fh $frames[ $i - 1 ] . "\n";
         }
         $mslist->handle->close;

# Sum the exposure times.
         my $temp_exp_time = new ORAC::TempFile;
         my $ms_params = "wlim=0 variance=f trim estimator=sum single=false";
         $Mon{'kappa_mon'}->obeyw( "mstats", "in=^$mslist out=$temp_exp_time $ms_params" );

# MSTATS will leave a cube with a degenerate final axis.  Remove that axis.
         $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp_exp_time out=$exp_time_out trim" );

         orac_print "Summing exposure times on Tile $c to form $exp_time_out.\n";

         undef $temp_exp_time;
         undef $mslist;

# Average the T_sys NDFs.
# -----------------------

# Propagation formula used:
# TSYS = sum w_i TSYS_i
#          i
#
# Since we used equal weights for combining the data, we just determine the
# mean TSYS.

# Delete the existing version of the extension NDF in the output file.
         my $tsys_out;
         if ( $tsys_present ) {
            $tsys_out = $mmout . ".MORE.SMURF.TSYS";
            $Mon{'ndfpack_mon'}->obeyw( "erase", "object=$tsys_out ok" );

# Form text file listing the tile's contributing TSYS chunks to average.
            $mslist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
            $mslist_fh = $mslist->handle;

            @frames = split ( ' ', $tiles_tsys[$c] );
            foreach my $i ( 1.. $nframe ) {
               print $mslist_fh $frames[ $i - 1 ] . "\n";
            }
            $mslist->handle->close;

# Average the TSYS.
            my $temp_tsys = new ORAC::TempFile;
            $ms_params = "wlim=0 variance=f trim estimator=mean single=false";
            $Mon{'kappa_mon'}->obeyw( "mstats", "in=^$mslist out=$temp_tsys $ms_params" );

# MSTATS will leave a cube with a degenerate final axis.  Remove that axis.
            $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp_tsys out=$tsys_out trim" );
            orac_print "Averaging system temperatures on Tile $c to form $tsys_out.\n";

            undef $temp_tsys;
            undef $mslist;
        }

# Combine the EFF_TIME NDFs.
# --------------------------

# Propagation formula used:
# EFF_TIME = (sum (EFF_TIME_i / TSYS_i) )**2 / sum (EFF_TIME_p / (TSYS_p)**2)
#               i                                p

# Remove the existing EFF_TIME propagated from the primary NDF.
         my $eff_time_out = $mmout . ".MORE.SMURF.EFF_TIME";
         $Mon{'ndfpack_mon'}->obeyw( "erase", "object=$eff_time_out ok" );

# TSYS is needed to sum the EFF_TIME.
         if ( $tsys_present ) {

# Form text files listing the terms to sum in the numerator
# and denominator that define the combined T_eff.
            my $nlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
            my $nlist_fh = $nlist->handle;
            my $dlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
            my $dlist_fh = $dlist->handle;

            orac_print "Combining T_eff on Tile $c to form $eff_time_out.\n";
            my @eframes = split ( ' ', $tiles_eff_time[$c] );
            my @tframes = split ( ' ', $tiles_tsys[$c] );
            my ( @numerator, @denominator );

            foreach my $i ( 1.. $nframe ) {

# Form temporary NDFs that store numerator and denominator expressions.
               my $temp_n = new ORAC::TempFile;
               my $temp_d = new ORAC::TempFile;
               push @numerator, $temp_n;
               push @denominator, $temp_d;

# Constrain the Tsys to avoid divide by zeroes.
               my $maths_in = "ia=" . $eframes[ $i - 1 ] . " ib=" . $tframes[ $i - 1 ] . " fb=max(0.1,IB)";
               my $maths_out = "exp=ia/fb out=$temp_n";
               $Mon{'kappa_mon'}->obeyw( "maths", "$maths_in $maths_out" );

               $maths_out = "exp=ia/fb/fb out=$temp_d";
               $Mon{'kappa_mon'}->obeyw( "maths", "$maths_in $maths_out" );

# Store the names of temporary NDFs that are to be summed to form the
# numerator and denominator of the expression to combine T_eff values.
               print $nlist_fh $temp_n . "\n";
               print $dlist_fh $temp_d . "\n";
            }

# Close the indirection files so that MSTATS can read them.
            $nlist->handle->close;
            $dlist->handle->close;

# Sum the terms in the numerator and denominator.
            my $temp_num = new ORAC::TempFile;
            my $temp_den = new ORAC::TempFile;
            $ms_params = "wlim=0 variance=f trim estimator=sum single=false";
            $Mon{'kappa_mon'}->obeyw( "mstats", "in=^$nlist out=$temp_num $ms_params" );
            $Mon{'kappa_mon'}->obeyw( "mstats", "in=^$dlist out=$temp_den $ms_params" );

# The numerator is the sqaured of the sum.
            my $temp_numsq = new ORAC::TempFile;
            $Mon{'kappa_mon'}->obeyw( "maths", "ia=$temp_num exp=ia*ia out=$temp_numsq" );

# Remove intermediate NDFs and indirection files.
            foreach my $i ( 1.. $nframe ) {
               undef $numerator[ $i - 1 ];
               undef $denominator[ $i - 1 ];
            }
            undef $temp_num;
            undef $nlist;
            undef $dlist;

# Generate the output EFF_TIME NDF.
            my $temp_eff_time = new ORAC::TempFile;
            $Mon{'kappa_mon'}->obeyw( "div", "in1=$temp_numsq in2=$temp_den out=$temp_eff_time" );

# MSTATS calculations will leave a cube with a degenerate final axis.  Remove that axis.
            $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp_eff_time out=$eff_time_out trim" );
            orac_print "  Done.\n";

            undef $temp_eff_time;
            undef $temp_num;
            undef $temp_den;
         }

# Update three representative values of these arrays in the FITS headers.
# -----------------------------------------------------------------------

         $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$exp_time_out order" );
         ( $ORAC_STATUS, my $exptime ) = $Mon{'kappa_mon'}->get( "stats", "median" );
         _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=EXP_TIME VALUE=$exptime

         if ( $tsys_present ) {
            $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$eff_time_out order" );
            ( $ORAC_STATUS, my $efftime ) = $Mon{'kappa_mon'}->get( "stats", "median" );
            _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=EFF_TIME VALUE=$efftime

            $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$tsys_out order" );
            ( $ORAC_STATUS, my $medtsys ) = $Mon{'kappa_mon'}->get( "stats", "median" );
            _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=MEDTSYS VALUE=$medtsys

# Set blank headers as we have no values.
         } else {
            _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=EFF_TIME VALUE=<null>
            _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=MEDTSYS VALUE=<null>
         }

      } elsif ( $nframe > 1 ) {
         orac_print "Only one file contributes to Tile $c\n";
         orac_print "Rename ". $frames[0] . " to $mmout \n";
         copy( $frames[0] . ".sdf", $mmout . ".sdf" );

      } else {
         orac_print "No files contribute to Tile $c\n";
      }
   }
}
