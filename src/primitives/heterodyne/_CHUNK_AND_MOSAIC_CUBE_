=head1 NAME

_CHUNK_AND_MOSAIC_CUBE_ -- Creates a cube by dividing a group of time-series
ACSIS observations into chunks.

=head1 DESCRIPTION

This primitive divides time-series ACSIS cubes from each observation, supplied
as an array of NDF names, into more manageable subsets.  It then runs MAKECUBE
on each subset to create a spatial/spectral cube, divided into tiles if a
maximum tile size is exceeded.  For each tile that would have been created had
MAKECUBE processed all the time series simultaneously, data are summed from
the chunked spatial/spectral cubes which intersect that tile,  The summed data
are trimmed to the tile pixel bounds.

The goal is to mimic MAKECUBE processing all the supplied time series, but
without causing a timeout or excessive memory demands.

=head1 ARGUMENTS

=over 4

=item CHUNKSIZE = INTEGER (Given)

The maximum subset size in megabytes.  [5120]

=item FILES = ARRAY REFERENCE (Given)

A reference to an array containing filenames to be formed into a spatial/spectral
cube.

=item MAKECUBE_PARAMS = STRING (Given)

The parameter values for MAKECUBE excluding the name of the IN and OUT parameters.

=item MEAN_CHUNKSIZE = INTEGER (Given)

The average subset size in megabytes.

=item NUM_CHUNK = INTEGER (Given)

The number of subsets.

=item TILEDIMS = INTEGER (Given)

The tile size in pixels along both spatial axes.

=item TOTALSIZE = INTEGER (Given)

The total size in megabytes of all the time series listed in TIMESERIES.

=item TOTALTILE = INTEGER (Given)

The total number of tiles that MAKECUBE would create processing all
the time-series data files.

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=item *

It serves _CREATE_CUBE_GROUP_ from where the supplied arguments to this
primitive are either parameters or are evaluated.

=back

=head1 OUTPUT DATA

=over 4

=item *

A cube (or set of cubes) whose filename is of the form
gaYYYYMMDD_NN_SS_cubeMMM.sdf, where YYYYMMDD is the UT date, NN is the
observation number, SS is the zero-padded subsystem number, and MMM is
the zero-padded tile number. Tiles are numbered starting from 1 and
increasing monotonically, counting from the bottom-left corner in
spatial extent and proceeding in a raster fashion from left to right.

=back

=head1 TASKS

CCDPACK: MAKEMOS.
KAPPA: DIV, MATHS, MSTATS, NDFCOPY, NDFTRACE, STATS.
SMURF: MAKECUBE.

=head1 REQUIRED PERL MODULES

File::Copy.

=head1 AUTHORS

Malcolm J. Currie E<lt>mjc@star.rl.ac.ukE<gt>

=head1 COPYRIGHT

Copyright (C) 2010-2011 Science and Technology Facilities Council.  All
Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either Version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307, USA.

=cut

use File::Copy;
use constant MEGABYTE => 1048576;

my $files = get_prim_arg( $_PRIM_ARGS_, "FILES", undef );
if ( ! defined( $files ) ) {
  orac_throw "FILES argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $params = get_prim_arg( $_PRIM_ARGS_, "MAKECUBE_PARAMS", undef );
if ( ! defined( $params ) ) {
  orac_throw "MAKECUBE_PARAMS argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $mean_chunksize = get_prim_arg( $_PRIM_ARGS_, "MEAN_CHUNKSIZE", undef );
if ( ! defined( $mean_chunksize ) ) {
  orac_throw "MEAN_CHUNKSIZE argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $num_chunk = get_prim_arg( $_PRIM_ARGS_, "NUM_CHUNK", undef );
if ( ! defined( $num_chunk ) ) {
  orac_throw "NUM_CHUNK argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $tiledims = get_prim_arg( $_PRIM_ARGS_, "TILEDIMS", undef );
if ( ! defined( $tiledims ) ) {
  orac_throw "TILEDIMS argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $totalsize = get_prim_arg( $_PRIM_ARGS_, "TOTALSIZE", undef );
if ( ! defined( $totalsize ) ) {
  orac_throw "TOTALSIZE argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $totaltile = get_prim_arg( $_PRIM_ARGS_, "TOTALTILE", undef );
if ( ! defined( $totaltile ) ) {
  orac_throw "TOTALTILE argument to _CHUNK_AND_MOSAIC_CUBE_ not defined: programming error";
}

my $chunksize = get_prim_arg( $_PRIM_ARGS_, "CHUNKSIZE", 5120 );

# Will a TSYS be created?

my $tsys_present = 0;
if ( lc( $params ) =~ /spread=nearest/ ) {
   $tsys_present = 1;

} elsif ( !( lc( $params ) =~ /spread=/ ) ) {
   $tsys_present = 1;
}

# Divide the list into manageable chunks to prevent a timeout.
# ============================================================

# The approach is to attempt to reduce each observation separately
# on the same grid of tiles, and only chunk an observation if it
# contains too much data.  Then combine each observation of a tile.
# Thus edge artefacts from smoothing in chunks rather than the
# observation as whole is reduced.

# We want to find the extreme bounds of the tiles.  The central tile
# is symmetric around bound (0,0).  Initialise the limits accordingly.
my @full_lb = ( 1, 1 );
my @full_ub = ( -1, -1 );

my $fi = 0;
my @chunk_ntile;
my $chunk_index = 0;
my $sumsize = 0;
my @chfiles;
my $num_files = @$files;
my $ORAC_STATUS;

# Allocate files to chunks.
# -------------------------

# Look at each input file and see if it needs chunking.
foreach my $i ( 1 .. $num_files ) {
   my $fullname = $files->[ $i - 1 ] . ".sdf";
   my $filesize = ( -s $fullname ) / MEGABYTE;

# Continue to add files to the current chunk until the size limit
# is surpassed.  Spectral-cube formation is always required for
# the last file in the group.  Also because of the quantisation
# enlarge the chunk size to the maximum for the final chunk so
# that it can encompass all the remaining input time-series files.
   my $use_chunksize = ( $chunk_index == $num_chunk ) ? $chunksize : $mean_chunksize;
   if ( ( $sumsize + $filesize ) <= $use_chunksize && $i < $num_files ) {
      $sumsize += $filesize;
      push @chfiles, $files->[ $fi ];
      $fi++;

   } else {

# Append the final input time-series file to the the list for the final chunk.
      if ( $i == $num_files ) {
         push @chfiles, $files->[ $fi ];
         $fi++;
      }

# Find and report the number of files in the chunk.
      my $chunk = @chfiles;
      my $string = ( $chunk == 1 ) ? "file" : "files";
      $chunk_index++;
      orac_print "Chunk: $chunk_index contains $chunk $string.\n";

# Form spatial/spectral cube.
# ---------------------------

# Form text file listing the chunk's members for MAKECUBE.
      my $chlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
      my $chlist_fh = $chlist->handle;

      for ( my $k = 0; $k < $chunk; $k++ ) {
         print $chlist_fh $chfiles[ $k ] . "\n";
      }
      $chlist->handle->close;

# Form tiles for current chunk.  Use a suffix to delineate the chunks.
      my ( $in, $out ) = $Grp->inout( "_cube" );
      $out .= "_ch" . "$chunk_index";

# Process the current manageable chunk of input time series into spectral
# cubes.
      orac_print "Creating cube $out from " . join( ", ", @chfiles ) . "...\n";

      $Mon{'smurf_mon'}->obeyw( "makecube", "$params trim=f in='^" . $chlist->file . "' out=$out" );
      orac_say "done.";
      undef $chlist;

# Find and record the number of tiles in the current chunk.
      ( $ORAC_STATUS, my $ntile ) = $Mon{'smurf_mon'}->get( "makecube", "ntile" );
      push @chunk_ntile, $ntile;

# Start a new list of files for the new chunk.
      if ( $i < $num_files ) {
         @chfiles = ( $files->[ $fi ] );
         $sumsize = $filesize;
         $fi++;
      }
   }
}

my $total_chunk = $chunk_index;

# Reset the tile dimensions to the original value.
$tiledims *= -1;

# Assign files in each chunk to the grand-mosaic tiles.
# =====================================================
#
( undef, my $out ) = $Grp->inout( "_cube" );
if ( $total_chunk > 1 ) {
   my ( @tiles_main, @tiles_exp_time, @tiles_eff_time, @tiles_tsys );

   foreach my $c ( 1 .. $total_chunk ) {
      foreach my $t ( 1 .. $chunk_ntile[$c - 1] ) {
         my $chunk_file = $out . "_ch" . $c;

# Mimic MAKECUBE naming.
         if ( $chunk_ntile[$c - 1] > 1 ) { $chunk_file .= "_" . $t }

# The tiles generated in chunks should be the same as if all the time
# series were supplied together.  Assignments to tiles should be
# straightforward.
         if ( -e $chunk_file . ".sdf" ) {
            $tiles_main[$t] .= $chunk_file . " ";
            $tiles_exp_time[$t] .= $chunk_file . ".MORE.SMURF.EXP_TIME" . " ";
            if ( $tsys_present ) {
               $tiles_tsys[$t] .= $chunk_file . ".MORE.SMURF.TSYS" . " ";
               $tiles_eff_time[$t] .= $chunk_file . ".MORE.SMURF.EFF_TIME" . " ";
            }
         }
      }
   }

# Reassemble each tile as it if were created by MAKECUBE.
# =======================================================
   foreach my $c ( 1 .. $totaltile ) {

# Extract the number and names of the NDFs to combine.
      $tiles_main[$c] =~ s/^\s+//;
      my @frames = split ( ' ', $tiles_main[$c] );
      my $nframe = @frames;

# Mimic MAKECUBE's output-NDF naming convention, i.e. exclude the
# _<tile> suffix if there is only one tile.
      my $mmout = ( $totaltile > 1 ) ? $out . "_" . $c : $out;

      if ( $nframe > 1 ) {

# Form trimmed mosaic.
# --------------------

# Form text file listing the tile's contributing chunks for MAKEMOS.
         my $mmlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
         my $mmlist_fh = $mmlist->handle;

         my $mm_params = "usevar method=mean genvar nozero noscale";
         foreach my $i ( 1.. $nframe ) {
            print $mmlist_fh $frames[ $i - 1 ] . "\n";
         }
         $mmlist->handle->close;

# Combine the tiles as if we had processed all the data in one MAKECUBE
# invocation.  However, it cannot be tackled in one pass; while MAKECUBE
# knows about the SMURF extensions that are also NDFs, MAKEMOS does not.

# First combine the main arrays.
         my $mmout = $out . "_" . $c;
         orac_print "\nRunning MAKEMOS on Tile $c to form $mmout from:\n";
         foreach my $i ( 1.. $nframe ) {
            orac_print "  " . $frames[ $i - 1 ] . "\n";
         }
         $Mon{'ccdpack_reg'}->obeyw( "makemos", "$mm_params in='^" . $mmlist->file . "' out=$mmout" );
         orac_print "  done.\n\n";
         undef $mmlist;

# Sum the EXP_TIME NDFs.
# ----------------------

# Delete the existing version of the extension NDF in the output file.
         my $exp_time_out = $mmout . ".MORE.SMURF.EXP_TIME";
         $Mon{'ndfpack_mon'}->obeyw( "erase", "object=$exp_time_out ok" );

# Form text file listing the tile's contributing EXP_TIME chunks to sum.
         my $mslist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
         my $mslist_fh = $mslist->handle;

         my @exp_frames = split ( ' ', $tiles_exp_time[$c] );
         foreach my $i ( 1.. $nframe ) {
            print $mslist_fh $exp_frames[ $i - 1 ] . "\n";
         }
         $mslist->handle->close;

# Sum the exposure times.
         my $temp_exp_time = new ORAC::TempFile;
         my $ms_params = "wlim=0 variance=f trim estimator=sum single=false";
         $Mon{'kappa_mon'}->obeyw( "mstats", "in=^$mslist out=$temp_exp_time $ms_params" );

# MSTATS will leave a cube with a degenerate final axis.  Remove that axis.
         $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp_exp_time out=$exp_time_out trim" );

         orac_print "Summing exposure times on Tile $c to form $exp_time_out.\n";

         undef $temp_exp_time;
         undef $mslist;

# Average the T_sys NDFs.
# -----------------------

# Propagation formula used:
# TSYS = sum w_i TSYS_i
#          i
#
# Since we used equal weights for combining the data, we just determine the
# mean TSYS.

# Delete the existing version of the extension NDF in the output file.
         my $tsys_out;
         if ( $tsys_present ) {
            $tsys_out = $mmout . ".MORE.SMURF.TSYS";
            $Mon{'ndfpack_mon'}->obeyw( "erase", "object=$tsys_out ok" );

# Form text file listing the tile's contributing TSYS chunks to average.
            $mslist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
            $mslist_fh = $mslist->handle;

            my @tsys_frames = split ( ' ', $tiles_tsys[$c] );
            foreach my $i ( 1.. $nframe ) {
               print $mslist_fh $tsys_frames[ $i - 1 ] . "\n";
            }
            $mslist->handle->close;

# Average the TSYS.
            my $temp_tsys = new ORAC::TempFile;
            $ms_params = "wlim=0 variance=f trim estimator=mean single=false";
            $Mon{'kappa_mon'}->obeyw( "mstats", "in=^$mslist out=$temp_tsys $ms_params" );

# MSTATS will leave a cube with a degenerate final axis.  Remove that axis.
            $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp_tsys out=$tsys_out trim" );
            orac_print "Averaging system temperatures on Tile $c to form $tsys_out.\n";

            undef $temp_tsys;
            undef $mslist;
         }

# Combine the EFF_TIME NDFs.
# --------------------------

# Propagation formula used:
# EFF_TIME = (sum (EFF_TIME_i / TSYS_i) )**2 / sum (EFF_TIME_p / (TSYS_p)**2)
#               i                                p

# Remove the existing EFF_TIME propagated from the primary NDF.
         my $eff_time_out = $mmout . ".MORE.SMURF.EFF_TIME";
         $Mon{'ndfpack_mon'}->obeyw( "erase", "object=$eff_time_out ok" );

# TSYS is needed to sum the EFF_TIME.
         if ( $tsys_present ) {

# Form text files listing the terms to sum in the numerator
# and denominator that define the combined T_eff.
            my $nlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
            my $nlist_fh = $nlist->handle;
            my $dlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
            my $dlist_fh = $dlist->handle;

            orac_print "Combining T_eff on Tile $c to form $eff_time_out.\n";
            my @eframes = split ( ' ', $tiles_eff_time[$c] );
            my @tframes = split ( ' ', $tiles_tsys[$c] );
            my ( @numerator, @denominator );

            foreach my $i ( 1.. $nframe ) {

# Form temporary NDFs that store numerator and denominator expressions.
               my $temp_n = new ORAC::TempFile;
               my $temp_d = new ORAC::TempFile;
               push @numerator, $temp_n;
               push @denominator, $temp_d;

# Constrain the Tsys to avoid divide by zeroes.
               my $maths_in = "ia=" . $eframes[ $i - 1 ] . " ib=" . $tframes[ $i - 1 ] . " fb=max(0.1,IB)";
               my $maths_out = "exp=ia/fb out=$temp_n";
               $Mon{'kappa_mon'}->obeyw( "maths", "$maths_in $maths_out" );

               $maths_out = "exp=ia/fb/fb out=$temp_d";
               $Mon{'kappa_mon'}->obeyw( "maths", "$maths_in $maths_out" );

# Store the names of temporary NDFs that are to be summed to form the
# numerator and denominator of the expression to combine T_eff values.
               print $nlist_fh $temp_n . "\n";
               print $dlist_fh $temp_d . "\n";
            }

# Close the indirection files so that MSTATS can read them.
            $nlist->handle->close;
            $dlist->handle->close;

# Sum the terms in the numerator and denominator.
            my $temp_num = new ORAC::TempFile;
            my $temp_den = new ORAC::TempFile;
            $ms_params = "wlim=0 variance=f trim estimator=sum single=false";
            $Mon{'kappa_mon'}->obeyw( "mstats", "in=^$nlist out=$temp_num $ms_params" );
            $Mon{'kappa_mon'}->obeyw( "mstats", "in=^$dlist out=$temp_den $ms_params" );

# The numerator is the sqaured of the sum.
            my $temp_numsq = new ORAC::TempFile;
            $Mon{'kappa_mon'}->obeyw( "maths", "ia=$temp_num exp=ia*ia out=$temp_numsq" );

# Remove intermediate NDFs and indirection files.
            foreach my $i ( 1.. $nframe ) {
               undef $numerator[ $i - 1 ];
               undef $denominator[ $i - 1 ];
            }
            undef $temp_num;
            undef $nlist;
            undef $dlist;

# Generate the output EFF_TIME NDF.
            my $temp_eff_time = new ORAC::TempFile;
            $Mon{'kappa_mon'}->obeyw( "div", "in1=$temp_numsq in2=$temp_den out=$temp_eff_time" );

# MSTATS calculations will leave a cube with a degenerate final axis.  Remove that axis.
            $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp_eff_time out=$eff_time_out trim" );
            orac_print "  Done.\n";

            undef $temp_eff_time;
            undef $temp_num;
            undef $temp_den;
         }

# Update three representative values of these arrays in the FITS headers.
# -----------------------------------------------------------------------

         $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$exp_time_out order" );
         ( $ORAC_STATUS, my $exptime ) = $Mon{'kappa_mon'}->get( "stats", "median" );
         _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=EXP_TIME VALUE=$exptime

         if ( $tsys_present ) {
            $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$eff_time_out order" );
            ( $ORAC_STATUS, my $efftime ) = $Mon{'kappa_mon'}->get( "stats", "median" );
            _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=EFF_TIME VALUE=$efftime

            $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$tsys_out order" );
            ( $ORAC_STATUS, my $medtsys ) = $Mon{'kappa_mon'}->get( "stats", "median" );
            _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=MEDTSYS VALUE=$medtsys

# Set blank headers as we have no values.
         } else {
            _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=EFF_TIME VALUE=<null>
            _SET_FILE_FITS_ITEM_ FILE=$mmout KEY=MEDTSYS VALUE=<null>
         }

# Remove chunk NDFs now we have finished using the ones for the current
# tile.
         foreach my $i ( 1.. $nframe ) {
            my $chunkndf =  $frames[ $i - 1 ] . ".sdf";
            unlink( $chunkndf ) or orac_warn "Unable to remove chunk $chunkndf.\n";
         }

      } elsif ( $nframe == 1 ) {
         orac_print "Only one file contributes to Tile $c\n";
         orac_print "Rename ". $frames[0] . " to $mmout \n";
         copy( $frames[0] . ".sdf", $mmout . ".sdf" );

      } else {
         orac_print "No files contribute to Tile $c\n";
      }
   }
}
