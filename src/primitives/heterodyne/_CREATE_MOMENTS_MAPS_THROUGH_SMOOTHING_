# -*-cperl-*-

=head1 NAME

_CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_ - Create moments maps by
smoothing and detecting emission regions using various methods.

=head1 DESCRIPTION

This primitive is used to create moments maps. It first smooths the
cube along the frequency axis, then in the spatial axes. It then masks
out emission regions using a previously-determined mask (see
_CREATE_BASELINE_MASK_), and then calculates the RMS in the
emission-free regions. This RMS is used to set a threshold for the
various emission-selection methods. Selected regions are then turned
into an emission mask (masking out non-emission) to be applied to the
original resolution cube which is then collapsed to form the moment
maps.

Three emission selection methods are available:
  CUPID::Clumpfind: selects emission by walking down peaks to lower
        intensities.
  CUPID::Fellwalker: selects emission by walking up along line of
        steepest accent until a peak or a previous found clump is
        found.
  KAPPA:Thresh: selects emission by simply accepting all data
        above a specified RMS threshold.

=head1 ARGUMENTS

=over 4

=item FREQUENCY_SMOOTH = INTEGER (Given)

The number of channels to smooth in the frequency axis when smoothing
to determine baselines. This number should be small (~10) for
narrow-line observations and large (~25) for broad-line
observations. [25]

=item GROUP = INTEGER (Given)

How to process group files. 0 means use the current Frame object. 1
means use the current Group object. 2 means use each Frame member of
the current Group object. [0]

=item LOWER_VELOCITY = REAL (Given)

An optional lower velocity in km/s, below which no data will be used
when creating the moments map. This argument can be overridden by the
RECPAR_MOMENTS_LOWER uhdr via the recipe parameter system. [undef]

=item MOMENTS = STRING (Given)

The moment maps to create. These are any of the values allowed for the
ESTIMATOR parameter to the COLLAPSE method, but in reality this should
probably be 'integ', 'iwc', and/or 'itd'. Any number of moments can be
given in a comma-separated string. This argument can be overridden by
the RECPAR_MOMENTS uhdr via the recipe parameter system. ['integ']

=item ORDER = INTEGER (Given)

The polynomial order that will be used when estimating baselines. [1]

=item METHOD = STRING (Given)

Method to use to find emission in the data: 'clumpfind', 'fellwalker',
or 'thresh'. ['clumpfind']

=item PER_LINE = LOGICAL (Given)

Whether or not to create a moments map for each detected line. [0]

=item RMS_THRESHOLD = REALS (Given)

The RMS threshold above which emission will be considered to be a
clump. A separate threshold can be specified for each moments map
requested. The last specified number will be applied to any further
moments requested. Typically 'integ' can tolerate a rms of 3-sigma,
but the higher order moments need a higher threshold. Comma-separated
string in the same order as the requested MOMENTS. [3.0,4.5]

=item SNR = LOGICAL (Given)

Whether or not to do clump detection on an SNR cube instead of the
signal cube. Useful for data taken in varying conditions. This
argument can be overridden by the RECPAR_MOMENTS_SNR uhdr via the
recipe parameter system. [0]

=item SPATIAL_SMOOTH = INTEGER (Given)

The number of pixels to smooth in both spatial axes when smoothing to
determine baselines. [3]

=item TAG = STRING (Given)

Which moment map to tag as a representative image. ['']

=item UPPER_VELOCITY = REAL (Given)

An optional upper velocity in km/s, above which no data will be used
when creating the moments map. This argument can be overridden by the
RECPAR_MOMENTS_UPPER uhdr via the recipe parameter system. [undef]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS cubes.

=back

=head1 OUTPUT DATA

=over 4

=item *

The moments map(s) with suffix equal to the given moment(s) by the
MOMENTS parameter.

=back

=head1 TASKS

CUPID: FINDCLUMPS
KAPPA: ADD, BLOCK, COLLAPSE, DIV, MULT, NDFCOPY, NDFTRACE, NOMAGIC,
       PASTE, PLUCK, SETBB, SETVAR, STATS, THRESH

=head1 REQUIRED PERL MODULES

None, but see _COMPONENT_EXISTS_.

=head1 SEE ALSO

_COMPONENT_EXISTS_, _CREATE_BASELINE_MASK_

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>,
Remo Tilanus E<lt>r.tilanus@jach.hawaii.eduE<gt>.

=head1 COPYRIGHT

Copyright (C) 2008-2009 Science and Technology Facilities Council.
All Rights Reserved.

=cut

# Handle parameters.
my $freqsmooth = get_prim_arg( $_PRIM_ARGS_, "FREQUENCY_SMOOTH", 25 );
my $group = get_prim_arg( $_PRIM_ARGS_, "GROUP", 0 );
my $lower_velocity = get_prim_arg( $_PRIM_ARGS_, "LOWER_VELOCITY", undef );
my $moments = get_prim_arg( $_PRIM_ARGS_, "MOMENTS", 'integ' );
my $method = get_prim_arg( $_PRIM_ARGS_, "METHOD", 'clumpfind' );
my $order = get_prim_arg( $_PRIM_ARGS_, "ORDER", 1 );
my $per_line = get_prim_arg( $_PRIM_ARGS_, "PER_LINE", 0 );
my $rms_thrhlds = get_prim_arg( $_PRIM_ARGS_, "RMS_THRESHOLD", '3.0,4.5' );
my $snr = get_prim_arg( $_PRIM_ARGS_, "SNR", 0 );
my $spatsmooth = get_prim_arg( $_PRIM_ARGS_, "SPATIAL_SMOOTH", 3 );
my $tag = get_prim_arg( $_PRIM_ARGS_, "TAG", undef );
my $upper_velocity = get_prim_arg( $_PRIM_ARGS_, "UPPER_VELOCITY", undef );

# Handle recipe parameters.
$lower_velocity = ( defined( $Frm->uhdr( "RECPAR_MOMENTS_LOWER" ) ) ?
                    $Frm->uhdr( "RECPAR_MOMENTS_LOWER" )            :
                    $lower_velocity );
$moments = ( defined( $Frm->uhdr( "RECPAR_MOMENTS" ) ) ?
             $Frm->uhdr( "RECPAR_MOMENTS" )            :
             $moments );
$snr = ( defined( $Frm->uhdr( "RECPAR_MOMENTS_SNR" ) ) ?
         $Frm->uhdr( "RECPAR_MOMENTS_SNR" )            :
         $snr );
$upper_velocity = ( defined( $Frm->uhdr( "RECPAR_MOMENTS_UPPER" ) ) ?
                    $Frm->uhdr( "RECPAR_MOMENTS_UPPER" )            :
                    $upper_velocity );

my $group2 = ( $group == 2 ? 0 : $group );

my @moments = split /,/, $moments;
my @rms_thrhlds = split /,/, $rms_thrhlds;

if( $method =~ /^t/i ) {
  $method = "thresh";
} elsif( $method =~ /^f/i ) {
  $method = "fellwalker";
} else {
  $method = "clumpfind";
}

my @objs;
if( $group == 0 ) {
  push @objs, $Frm;
} elsif( $group == 1 ) {
  push @objs, $Grp;
} elsif( $group == 2 ) {
  @objs = $Grp->members;
}

if( $group != 1 || ( $group == 1 && $Grp->lastallmembers( $Frm ) ) ) {

  if( ! ( $group == 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) ) {

    foreach my $Obj ( @objs ) {

      if( ! defined( $Obj->uhdr( "BASELINE_MASKS" ) ) ) {

        _CREATE_BASELINE_MASK_ GROUP=$group FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order

      }

      # Collapse each of the files making up the current object.
      my @collapsed;
      my %paste_inputs;
      my @smoothed;
      my @smo_obj;
      my @masked;
      my @mask_obj;

      my $nomap = 0;

      foreach my $i ( 1 .. $Obj->nfiles ) {

        if( $Obj->uhdr( "SPARSE" ) ) {

          orac_warn $Obj->file( $i ) . " is a sparse cube. Cannot create moments map for a sparse cube.\n";

        } else {

          ( my $in, undef ) = $Obj->inout( "_blah", $i );

          orac_say "Creating moments maps for $in.";

          my $masks = $Obj->uhdr( "BASELINE_MASKS" );
          my $mask = $masks->[$i];

          # Only do this if the cube isn't 1xMxN or Mx1xN.
          _GET_DIMENSIONS_ FILE=$in
          my $dims = $_GET_DIMENSIONS_{DIMS};
          my $lbound = $_GET_DIMENSIONS_{LBOUND};
          my $ubound = $_GET_DIMENSIONS_{UBOUND};

          if( $dims->[0] == 1 ||
              $dims->[1] == 1 ) {
            orac_warn "Cannot create moment map with a " . $dims->[0] . "x" . $dims->[1] . "x" . $dims->[2] . " cube.\n";
            $nomap = 1;

            # If both dimensions are 1, then copy this file into the _sp.
            if( $dims->[0] == 1 && $dims->[1] == 1 ) {

              {
                my $Frm = $Obj;
                $Frm->uhdr( "INTEG_MAX_POS", [ 1, 1 ] );
                _EXTRACT_MAXVALUE_SPECTRUM_ TAG=1 GROUP=0
              }

            }

          } else {

            # Temporarily disable bad-bits mask.
            $Mon{'ndfpack_mon'}->obeyw( "setbb", "ndf=$in bb=0" );

            # Make SNR cube, if requested.
            my $snrtemp = new ORAC::TempFile;
            my $snrtempfile = $snrtemp->file;
            if( $snr ) {
              orac_say " Creating SNR cube.";
              my $params = "in=$in out=$snrtempfile minvar=0.01";
              $Mon{'kappa_mon'}->obeyw( "makesnr", "$params" );
            } else {
              $snrtempfile = $in;
            }

            my $temp1 = new ORAC::TempFile;
            my $temp1file = $temp1->file;

            if( starversion_gt( 'KAPPA', 'v1.11-7' ) ) {

              # We can use N-D BLOCK.
              orac_say " Smoothing cube with [$spatsmooth,$spatsmooth,$freqsmooth] tophat.";
              my $params = "in=$snrtempfile out=$temp1file box=[$spatsmooth,$spatsmooth,$freqsmooth] estimator=mean";
              $Mon{'kappa_mon'}->obeyw( "block", "$params" );
            } else {

              # Need to do two BLOCK calls.
              my $temp2 = new ORAC::TempFile;
              my $temp2file = $temp2->file;

              orac_say " Smoothing cube in frequency with $freqsmooth-pixel tophat.";

              my $params = "in=$snrtempfile out=$temp2file axes=[1,3] box=[1,$freqsmooth] estimator=mean";
              $Mon{'kappa_mon'}->obeyw( "block", "$params" );

              orac_say " Smoothing cube in spatial with $spatsmooth-pixel tophat.";

              if( $dims->[0] < 3 || $dims->[1] < 3 ) {
                $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp2file out=$temp1file" );
              } else {
                $params = "in=$temp2file out=$temp1file axes=[1,2] box=[$spatsmooth,$spatsmooth] estimator=mean";
                $Mon{'kappa_mon'}->obeyw( "block", "$params" );
              }
            }

            # Restore bad-bits mask.
            $Mon{'ndfpack_mon'}->obeyw( "setbb", "ndf=$in bb=255" );

            push @smoothed, $temp1file;
            push @smo_obj, $temp1;

            # Mask out lines.
            orac_say " Masking out lines using $mask.";
            my $temp3 = new ORAC::TempFile;
            my $temp3file = $temp3->file;
            my $params = "in1=$temp1file in2=$mask out=$temp3file";
            $Mon{'kappa_mon'}->obeyw( "add", "$params" );

            # Copy the variance across, but only if the input cube has
            # a variance.
            $params = "ndf=$temp1file";
            $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "$params" );
            my ( $ORAC_STATUS, $var ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "variance" );
            if( uc( $var ) eq 'TRUE' ) {
              $params = "ndf=$temp3file from=$temp1file comp=VARIANCE";
              $Mon{'ndfpack_mon'}->obeyw( "setvar", "$params" );
            }

            push @masked, $temp3file;
            push @mask_obj, $temp3;

          }
        }
      }

      if( ! $nomap ) {

        # Get the RMS for the smoothed files.
        _CALCULATE_RMS_ FILES=\@masked BOX=1
        my $medianrms = $_CALCULATE_RMS_{RMS};
        orac_say "Median RMS in smoothed observation is " . sprintf( "%0.3f", $medianrms );

        # Find bounds for each identified line, if requested.
        if( $per_line ) {
          my @bounds;
          foreach my $smoothed ( @smoothed ) {
            _IDENTIFY_SPECBOUNDS_ FILE=$smoothed
            my $bounds = $_IDENTIFY_SPECBOUNDS_{'BOUNDS'};
            push @bounds, $bounds;
          }
          # Check to see if we have Number::Range. If we don't, we
          # can't do the linteg range determination (and print a
          # warning saying such.
          my $isok = eval { require Number::Range; 1; };
          if( $isok ) {
            my $range = new Number::Range;
            foreach my $b1 ( @bounds ) {
              foreach my $b2 ( @$b1 ) {
                {
                  # We need to temporarily turn off warnings because
                  # Number::Range annoyingly throws a warning if we
                  # add a number that's already in the range...
                  no warnings;
                  $range->addrange( $b2->[0] . ".." . $b2->[1] );
                }
              }
            }

            # Stringify the range.
            my $str = $range->range;

            # At this point the range is of the form
            # "32..183,317..324", so split it by commas into
            # individual ranges, then split it be two periods to get
            # the min and the max.
            my @ranges = split ',', $str;
            my @frmranges;
            foreach my $range ( @ranges ) {
              my ( $min, $max ) = split '\.\.', $range;
              push @frmranges, [ $min, $max ];
            }

            # Store the ranges in the SPECTRAL_BOUNDS uhdr for future
            # use.
            $Obj->uhdr( "SPECTRAL_BOUNDS", \@frmranges );
          } else {
            orac_warn "Cannot load Number::Range and thus cannot create moments maps for individual lines.\n";
          }
        }

        for my $i ( 1 .. $Obj->nfiles ) {
          my $in = $Obj->file( $i );
          my $file = $smoothed[$i-1];

          my $colin = new ORAC::TempFile;

          # Do the emission selection and collapse for each moment
          my $mom = 0;
          foreach my $moment ( @moments ) {

            # Select appropriate threshold from user specification
            my $rms_thresh;
            if($mom <= $#rms_thrhlds) {
              $rms_thresh = $rms_thrhlds[$mom];
            } else {
              $rms_thresh = $rms_thrhlds[$#rms_thrhlds];
              orac_say " Warning: no threshold level for this moment, using previous: $rms_thresh*RMS";
            }

            # Only repeat if different threshold needed
            if( $mom == 0 || $rms_thresh != $rms_thrhlds[$mom-1] ) {

              # Initialize output file for masks
              my $temp4 = new ORAC::TempFile;
              my $temp4file = $temp4->file;
              my $nclumps = 0;
              my $ORAC_STATUS;

              # Find emission/clumps
              # --------------------
              # RPT: this section could go into a _FIND_EMISSION_ primitive
              # if there is an elegant way to handle the temp output file.

              # Method is Thresholding: run kappa::thresh
              if( $method eq 'thresh' ) {

                orac_say " Finding emission higher than $rms_thresh-sigma using $method.";
                my $clip = $medianrms*$rms_thresh;
                my $params = "in=$file out=$temp4file thrlo=$clip thrhi=-1.0e30 newlo=bad";
                $Mon{'kappa_mon'}->obeyw( "thresh", "$params" );

                $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp4file" );
                ( $ORAC_STATUS, $nclumps ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );

              # Else use cupid::findclumps
              } else {

                # Create parameter file for FINDCLUMPS with both
                # parameters for clumpfind and fellwalker
                my $fc_param = "findclumps$$.param";
                open my $fc_fh, ">", $fc_param;
                print $fc_fh "ClumpFind.Minpix=50\n";
                print $fc_fh "ClumpFind.AllowEdge=1\n";
                print $fc_fh "ClumpFind.FwhmBeam=1\n";
                print $fc_fh "ClumpFind.MaxBad=9999\n";
                print $fc_fh "ClumpFind.VeloRes=0\n";
                print $fc_fh "ClumpFind.Tlow=$rms_thresh*RMS\n";
                print $fc_fh "FellWalker.Minpix=50\n";
                print $fc_fh "FellWalker.AllowEdge=1\n";
                print $fc_fh "FellWalker.FwhmBeam=0\n";
                print $fc_fh "FellWalker.MaxBad=9999\n";
                print $fc_fh "FellWalker.VeloRes=0\n";
                print $fc_fh "FellWalker.Noise=$rms_thresh*RMS\n";
                print $fc_fh "FellWalker.FlatSlope=1.0*RMS\n";
                print $fc_fh "FellWalker.MinHeight=$rms_thresh*RMS\n";
                close $fc_fh;

                # Run findclumps with clumpfind or fellwalker
                orac_say " Finding clumps higher than $rms_thresh-sigma using $method.";
                my $params = "in=$file rms=$medianrms config='^$fc_param' method=$method out=$temp4file outcat=\! deconv=no";
                $Mon{'cupid_mon'}->obeyw( "findclumps", "$params" );
                unlink( $fc_param );

                # Check number of clumps using NCLUMPS.
                ( $ORAC_STATUS, $nclumps ) = $Mon{'cupid_mon'}->get( "findclumps", "nclumps" );
              }
              # --------------------

              # If we have no clumps, we can't make a clump mask, so skip
              # the masking and just go straight to the moment map
              # creation.
              if( $nclumps ) {

                # Set clumps to be 1 everywhere (i.e. "clump mask").
                my $temp6 = new ORAC::TempFile;
                my $params = "in1=$temp4file in2=$temp4file out=$temp6";
                $Mon{'kappa_mon'}->obeyw( "div", "$params" );

                # Set bad data to zero.
                my $temp7 = new ORAC::TempFile;
                $params = "in=$temp6 out=$temp7 repval=0";
                $Mon{'kappa_mon'}->obeyw( "nomagic", "$params" );

                # Multiply clump mask by input cube.
                orac_say " Masking non-clump data.";
                $params = "in1=$in in2=$temp7 out=$colin";
                $Mon{'kappa_mon'}->obeyw( "mult", "$params" );

              } else {

                orac_say " No clumps found, using full cube for map creation.";
                $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$colin" );

              }

            }

            # For the moment collapse the masked cube into a temporary
            # file.
            if( ! exists( $paste_inputs{$moment} ) ) {
              $paste_inputs{$moment} = ();
            }

            # Set any pixels with a BORDER QUALITY value to bad.
            my $params = "ndf=$colin bb=255";
            $Mon{'ndfpack_mon'}->obeyw( "setbb", "$params" );

            # Copy the variance from the input cube.
            $params = "ndf=$colin from=$in comp=VARIANCE";
            $Mon{'ndfpack_mon'}->obeyw( "setvar", "$params" );

            # For each requested spectral range, collapse. The
            # @specbounds array will have the full range (or the
            # user-requested range) as the first element, and then any
            # ranges identified for line-specific moments maps after
            # that.
            my @specbounds;
            if( defined( $Obj->uhdr( "SPECTRAL_BOUNDS" ) ) ) {
              _GET_DIMENSIONS_ FILE=$colin
              my $flbound = $_GET_DIMENSIONS_{FLBOUND};
              my $fubound = $_GET_DIMENSIONS_{FUBOUND};
              push @specbounds, [ $flbound->[2], $fubound->[2] ];
              push @specbounds, @{$Obj->uhdr( "SPECTRAL_BOUNDS" ) };
            } elsif( defined( $lower_velocity ) || defined( $upper_velocity ) ) {
              push @specbounds, [ $lower_velocity, $upper_velocity ];
            } else {
              _GET_DIMENSIONS_ FILE=$colin
              my $flbound = $_GET_DIMENSIONS_{FLBOUND};
              my $fubound = $_GET_DIMENSIONS_{FUBOUND};
              push @specbounds, [ $flbound->[2], $fubound->[2] ];
            }

            for my $i ( 0 .. $#specbounds ) {
              my $lower = $specbounds[$i]->[0];
              my $upper = $specbounds[$i]->[1];

              if( ! defined( $lower ) ) {
                _GET_DIMENSIONS_ FILE=$colin
                $lower = $_GET_DIMENSIONS_{FLBOUND};
              }
              if( ! defined( $upper ) ) {
                _GET_DIMENSIONS_ FILE=$colin
                $upper = $_GET_DIMENSIONS_{FUBOUND};
              }

              # Set up the NDF section that we're collapsing over.
              my $section = "(,,$lower:$upper)";

              # Run the COLLAPSE.
              orac_say " Collapsing to form temporary $moment map.";

              if( defined( $lower_velocity ) ) {
                orac_say " Using lower velocity of $lower_velocity km/s.";
              }
              if( defined( $upper_velocity ) ) {
                orac_say " Using upper velocity of $upper_velocity km/s.";
              }

              my $temp8 = new ORAC::TempFile;
              my $temp8file = $temp8->file;
              $params = "in=$colin$section out=$temp8file estimator=$moment ";
              $params .= "axis=SPEC wlim=0.0 trim=false";
              if( uc( $moment ) eq 'IWC' ) {
                $params .= " variance=false";
              } else {
                $params .= " variance=true";
              }
              $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

              push @{$paste_inputs{$moment}{$i}}, $temp8file;
              push @collapsed, $temp8;
            }
            $mom++;
          }
        }

        orac_say;

        # Paste together the files in @collapsed into $out.
        foreach my $moment ( @moments ) {

          if( defined( $paste_inputs{$moment} ) ) {

            my $line_number = 0;
            foreach my $region ( sort keys %{$paste_inputs{$moment}} ) {

              my $suffix;
              if( $per_line && $region != 0 ) {
                $suffix = sprintf( "_l%s%03d", $moment, $line_number );
              } else {
                $suffix = "_$moment";
              }

              my( $in, $out ) = $Obj->inout( "$suffix" );

              # We need two temporary files at this point, one to hold
              # the pasted file pre-map masking, and one to hold an
              # AST Region.
              my $temp10 = new ORAC::TempFile;
              my $temp11 = new ORAC::TempFile;

              if( scalar( @{$paste_inputs{$moment}{$region}} ) == 1 ) {

                my $params = "in=${$paste_inputs{$moment}{$region}}[0] out=$temp10";
                $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );

              } else {

                orac_say " Pasting together temporary maps to form $moment map.";

                my $title = $Frm->uhdr( "ORAC_OBJECT" );
                _PASTE_FILES_ FILES=$paste_inputs{$moment}{$region} OUT=$temp10 TITLE=$title

              }

              # Test to see if we actually got any emission.
              $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp10" );
              my ( $ORAC_STATUS, $mean ) = $Mon{'kappa_mon'}->get( "stats", "mean" );
              ( $ORAC_STATUS, my $numgood ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );
              if( $mean == 0 || $numgood == 0 ) {
                orac_say " Line in position $region has no detected emission. Skipping to next line.";
                next;
              }
              $line_number++;

              # For SCANs only...
              if( $Frm->uhdr( "ORAC_SAMPLE_MODE" ) eq 'scan' ) {

                _MASK_AST_REGION_ IN=$temp10 OUT=$out GROUP=$group

              } else {
                $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp10 out=$out" );
              }

              orac_say "Created " . ( $region == 0 ? "" : "line " ) . "$moment map in $out.";

              if( $per_line && $region != 0 ) {
                _GET_DIMENSIONS_ FILE=$out
                my $flbound = $_GET_DIMENSIONS_{FLBOUND};
                my $fubound = $_GET_DIMENSIONS_{FUBOUND};
                orac_say sprintf( " Collapsed over velocity range: %.3f to %.3f km/s",
                                  $flbound->[2], $fubound->[2] );
              }

              _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRODUCT VALUE=$moment
              $Obj->sync_headers;

              # Copy the output to a group file if requested.
              if( $group != 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) {
                ( undef, my $groupout ) = $Grp->inout( "_$moment" );

                $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$out out=$groupout" );

                my $tGrp = new $Grp;
                $tGrp->groupid( $Grp->groupid );
                $tGrp->allow_header_sync(1);
                $tGrp->file( $groupout );

                orac_say "$out to $groupout:";
                orac_say " Copied to Group file.";

                if( defined( $tag ) && $tag eq $moment && $region == 0 ) {
                  _TAG_AS_REPRESENTATIVE_ FILE=$groupout UPDATE=0 GROUP=1 SUFFIX=rimg
                }

              }

              # Tag the moment map if the current moment is the
              # requested one.
              if( defined( $tag ) && $tag eq $moment && $region == 0 ) {
                if( $group == 2 ) {
                  my $Frm = new $Obj;
                  $Frm->file( $out );
                  _TAG_AS_REPRESENTATIVE_ FILE=$out UPDATE=0 GROUP=$group2 SUFFIX=rimg
                } else {
                  _TAG_AS_REPRESENTATIVE_ FILE=$out UPDATE=0 GROUP=$group SUFFIX=rimg
                }
              }

              # Find the position of the peak, then extract a spectrum
              # from that position, but only if the moment is 'integ'.
              if( $moment eq 'integ' && $region == 0 ) {

                my $tempfile = new ORAC::TempFile;

                # Do a smooth first.
                $Mon{'kappa_mon'}->obeyw( "block", "in=$out out=$tempfile box=3" );

                $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$tempfile" );
                my( $ORAC_STATUS, @maxpos ) = $Mon{'kappa_mon'}->get( "stats", "maxpos" );
                $Obj->uhdr( "INTEG_MAX_POS", \@maxpos );

                my $tagspec = defined( $tag );

                if( $group == 2 ) {
                  my $Frm = new $Obj;
                  $Frm->files( $Obj->files );
                  $Frm->uhdr( "INTEG_MAX_POS", \@maxpos );
                  _EXTRACT_MAXVALUE_SPECTRUM_ TAG=$tagspec GROUP=$group2
                } else {
                  _EXTRACT_MAXVALUE_SPECTRUM_ TAG=$tagspec GROUP=$group
                }
              }

              orac_say "";

            }
          }
        }

        # Tidy-up output.
        orac_say "";

      }
    }
  }
}


