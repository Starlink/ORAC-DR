# -*-perl-*-

=head1 NAME

_CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_ - Create moments maps by
smoothing and detecting emission regions.

=head1 DESCRIPTION

This primitive is used to create moments maps. It first smooths the
cube along the frequency axis, then in the spatial axes. It then masks
out emission regions using a previously-determined mask (see
_CREATE_BASELINE_MASK_), and then calculates the RMS in the
emission-free regions. This RMS is used to set a threshold for
clump-finding. The clumps are then turned into an emission mask
(masking out non-clumps), and the masked cube is then collapsed to
form the moment map.

=head1 ARGUMENTS

=over 4

=item FREQUENCY_SMOOTH = INTEGER (Given)

The number of channels to smooth in the frequency axis when smoothing
to determine baselines. This number should be small (~10) for
narrow-line observations and large (~25) for broad-line
observations. [25]

=item GROUP = INTEGER (Given)

How to process group files. 0 means use the current Frame object. 1
means use the current Group object. 2 means use each Frame member of
the current Group object. [0]

=item MOMENTS = STRING (Given)

The moment maps to create. These are any of the values allowed for the
ESTIMATOR parameter to the COLLAPSE method, but in reality this should
probably be 'integ', 'iwc', and/or 'itd'. Any number of moments can be
given in a comma-separated string. ['integ']

=item ORDER = INTEGER (Given)

The polynomial order that will be used when estimating baselines. [1]

=item RMS_THRESHOLD = REAL (Given)

The RMS threshold above which emission will be considered to be a
clump. [4.5]

=item SPATIAL_SMOOTH = INTEGER (Given)

The number of pixels to smooth in both spatial axes when smoothing to
determine baselines. [3]

=item TAG = STRING (Given)

Which moment map to tag as a representative image. ['']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS cubes.

=back

=head1 OUTPUT DATA

=over 4

=item *

The moments map(s) with suffix equal to the given moment(s) by the
MOMENTS parameter.

=back

=head1 TASKS

CUPID: FINDCLUMPS
KAPPA: ADD, BLOCK, COLLAPSE, DIV, MULT, NDFCOPY, NDFTRACE, NOMAGIC,
       PASTE, PLUCK, SETBB, SETVAR, STATS

=head1 REQUIRED PERL MODULES

None, but see _COMPONENT_EXISTS_.

=head1 SEE ALSO

_COMPONENT_EXISTS_, _CREATE_BASELINE_MASK_

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Handle parameters.
my $freqsmooth = get_prim_arg( $_PRIM_ARGS_, "FREQUENCY_SMOOTH", 25 );
my $group = get_prim_arg( $_PRIM_ARGS_, "GROUP", 0 );
my $moments = get_prim_arg( $_PRIM_ARGS_, "MOMENTS", 'integ' );
my $order = get_prim_arg( $_PRIM_ARGS_, "ORDER", 1 );
my $rms_thresh = get_prim_arg( $_PRIM_ARGS_, "RMS_THRESHOLD", 4.5 );
my $spatsmooth = get_prim_arg( $_PRIM_ARGS_, "SPATIAL_SMOOTH", 3 );
my $tag = get_prim_arg( $_PRIM_ARGS_, "TAG", undef );

my $group2 = ( $group == 2 ? 0 : $group );

my @moments = split /,/, $moments;

my @objs;
if( $group == 0 ) {
  push @objs, $Frm;
} elsif( $group == 1 ) {
  push @objs, $Grp;
} elsif( $group == 2 ) {
  @objs = $Grp->members;
}

if( $group != 1 || ( $group == 1 && $Grp->lastallmembers( $Frm ) ) ) {

  if( ! ( $group == 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) ) {

    foreach my $Obj ( @objs ) {

      if( ! defined( $Obj->uhdr( "BASELINE_MASKS" ) ) ) {

        _CREATE_BASELINE_MASK_ GROUP=$group FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order

      }

      # Collapse each of the files making up the current object.
      my @collapsed;
      my %paste_inputs;

      foreach my $i ( 1 .. $Obj->nfiles ) {

        if( $Obj->uhdr( "SPARSE" ) ) {

          orac_warn $Obj->file( $i ) . " is a sparse cube. Cannot create moments map for a sparse cube.\n";

        } else {

          # We need NDF for the VAL__BADD constant.
          use NDF;

          ( my $in, undef ) = $Obj->inout( "_blah", $i );

          orac_say "Creating moments maps for $in.";

          my $masks = $Obj->uhdr( "BASELINE_MASKS" );
          my $mask = $masks->[$i];

          # Only do this if the cube isn't 1xMxN or Mx1xN.
          _GET_DIMENSIONS_ FILE=$in
          my $dims = $_GET_DIMENSIONS_{DIMS};
          my $lbound = $_GET_DIMENSIONS_{LBOUND};
          my $ubound = $_GET_DIMENSIONS_{UBOUND};

          if( $dims->[0] == 1 ||
              $dims->[1] == 1 ) {
            orac_warn "Cannot create moment map with a " . $dims->[0] . "x" . $dims->[1] . "x" . $dims->[2] . " cube.\n";

            # If both dimensions are 1, then copy this file into the _sp.
            if( $dims->[0] == 1 && $dims->[1] == 1 ) {

              {
                my $Frm = $Obj;
                $Frm->uhdr( "INTEG_MAX_POS", [ 1, 1 ] );
                _EXTRACT_MAXVALUE_SPECTRUM_ TAG=1 GROUP=0
              }

            }

          } else {

            # Smooth the cube.
            orac_say " Smoothing cube in frequency with $freqsmooth-pixel tophat.";
            my $temp1 = new ORAC::TempFile;
            my $temp1file = $temp1->file;
            my $params = "in=$in out=$temp1file axes=[1,3] box=[1,$freqsmooth] estimator=mean";
            $Mon{'kappa_mon'}->obeyw( "block", "$params" );

            orac_say " Smoothing cube in spatial with $spatsmooth-pixel tophat.";
            my $temp2 = new ORAC::TempFile;
            my $temp2file = $temp2->file;
            if( $dims->[0] < 3 || $dims->[1] < 3 ) {
              $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$temp1file out=$temp2file" );
            } else {
              $params = "in=$temp1file out=$temp2file axes=[1,2] box=[$spatsmooth,$spatsmooth] estimator=mean";
              $Mon{'kappa_mon'}->obeyw( "block", "$params" );
            }

            # Mask out lines.
            orac_say " Masking out lines using $mask.";
            my $temp3 = new ORAC::TempFile;
            my $temp3file = $temp3->file;
            $params = "in1=$temp2file in2=$mask out=$temp3file";
            $Mon{'kappa_mon'}->obeyw( "add", "$params" );

            # Copy the variance across, but only if the input cube has
            # a variance.
            $params = "ndf=$temp2file";
            $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "$params" );
            my ( $ORAC_STATUS, $var ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "variance" );
            if( uc( $var ) eq 'TRUE' ) {
              $params = "ndf=$temp3file from=$temp2file comp=VARIANCE";
              $Mon{'ndfpack_mon'}->obeyw( "setvar", "$params" );
            }

            # Get stats on central-ish regions.
            my $xlow  = int( $lbound->[0] + 0.165 * $dims->[0] + 0.5 );
            my $xhigh = int( $ubound->[0] - 0.165 * $dims->[0] - 0.5 );
            my $ylow  = int( $lbound->[1] + 0.165 * $dims->[1] + 0.5 );
            my $yhigh = int( $ubound->[1] - 0.165 * $dims->[1] - 0.5 );
            my $zlow  = int( $lbound->[2] + 0.165 * $dims->[2] + 0.5 );
            my $zhigh = int( $ubound->[2] - 0.165 * $dims->[2] - 0.5 );
            my $section = "$xlow:$xhigh,$ylow:$yhigh,$zlow:$zhigh";
            $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$temp3file($section)" );
            ( $ORAC_STATUS, my $sigma ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

            my $colin = new ORAC::TempFile;

            if( $sigma != &NDF::VAL__BADD() ) {

              orac_say " RMS in smoothed baseline regions is " . sprintf( "%0.3f", $sigma );

              # Create parameter file for FINDCLUMPS.
              my $fc_param = "findclumps$$.param";
              open my $fc_fh, ">", $fc_param;
              print $fc_fh "ClumpFind.Minpix=50\n";
              print $fc_fh "ClumpFind.AllowEdge=1\n";
              print $fc_fh "ClumpFind.FwhmBeam=0\n";
              print $fc_fh "ClumpFind.MaxBad=9999\n";
              print $fc_fh "ClumpFind.VeloRes=0\n";
              print $fc_fh "ClumpFind.Tlow=$rms_thresh*RMS\n";
              close $fc_fh;

              # Run FINDCLUMPS.
              orac_say " Finding clumps higher than $rms_thresh-sigma.";
              my $temp4 = new ORAC::TempFile;
              my $temp4file = $temp4->file;
              $params = "in=$temp2file rms=$sigma config='^$fc_param' method=clumpfind out=$temp4file outcat=\! deconv=no";
              $Mon{'cupid_mon'}->obeyw( "findclumps", "$params" );
              unlink( $fc_param );

              # Check number of clumps using NCLUMPS.
              ( $ORAC_STATUS, my $nclumps ) = $Mon{'cupid_mon'}->get( "findclumps", "nclumps" );

              # If we have no clumps, we can't make a clump mask, so
              # skip the masking and just go straight to the moment
              # map creation.
              if( $nclumps ) {

                # Set clumps to be 1 everywhere (i.e. "clump mask").
                my $temp6 = new ORAC::TempFile;
                $params = "in1=$temp4file in2=$temp4file out=$temp6";
                $Mon{'kappa_mon'}->obeyw( "div", "$params" );

                # Set bad data to zero.
                my $temp7 = new ORAC::TempFile;
                $params = "in=$temp6 out=$temp7 repval=0";
                $Mon{'kappa_mon'}->obeyw( "nomagic", "$params" );

                # Multiply clump mask by input cube.
                orac_say " Masking non-clump data.";
                $params = "in1=$in in2=$temp7 out=$colin";
                $Mon{'kappa_mon'}->obeyw( "mult", "$params" );

              } else {

                orac_say " No clumps found, using full cube for map creation.";
                $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$colin" );

              }

            } else {

              orac_say " Bad value returned for RMS determination. Using full cube for map creation.";
              $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$colin" );

            }

            # For each moment, collapse the masked cube into a
            # temporary file.
            my $i = 1;
            foreach my $moment ( @moments ) {

              if( ! exists( $paste_inputs{$moment} ) ) {
                $paste_inputs{$moment} = ();
              }

              # Set any pixels with a BORDER QUALITY value to bad.
              $params = "ndf=$colin bb=255";
              $Mon{'ndfpack_mon'}->obeyw( "setbb", "$params" );

              # Copy the variance from the input cube.
              $params = "ndf=$colin from=$in comp=VARIANCE";
              $Mon{'ndfpack_mon'}->obeyw( "setvar", "$params" );

              # Run the COLLAPSE.
              orac_say " Collapsing to form temporary $moment map.";
              my $temp8 = new ORAC::TempFile;
              my $temp8file = $temp8->file;
              $params = "in=$colin out=$temp8file estimator=$moment ";
              $params .= "axis=SPEC wlim=0.0 trim=false";
              if( uc( $moment ) eq 'IWC' ) {
                $params .= " variance=false";
              } else {
                $params .= " variance=true";
              }
              $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

              push @{$paste_inputs{$moment}}, $temp8file;
              push @collapsed, $temp8;
              $i++;
            }
          }
        }

        orac_say;

      }

      # Paste together the files in @collapsed into $out.
      foreach my $moment ( @moments ) {

        my( $in, $out ) = $Obj->inout( "_$moment" );

        if( defined( $paste_inputs{$moment} ) ) {

          if( scalar( @{$paste_inputs{$moment}} ) == 1 ) {

            my $params = "in=${$paste_inputs{$moment}}[0] out=$out";
            $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );

          } else {

            orac_say " Pasting together temporary maps to form $moment map.";

            my $title = $Frm->uhdr( "ORAC_OBJECT" );
            _PASTE_FILES_ FILES=$paste_inputs{$moment} OUT=$out TITLE=$title

          }

          orac_say "Created $moment map in $out.";

          _SET_FILE_FITS_ITEM_ FILE=$out KEY=PRODUCT VALUE=$moment
          $Obj->sync_headers;

          # Copy the output to a group file if requested.
          if( $group != 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) {
            ( undef, my $groupout ) = $Grp->inout( "_$moment" );

            $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$out out=$groupout" );

            my $tGrp = new $Grp;
            $tGrp->groupid( $Grp->groupid );
            $tGrp->allow_header_sync(1);
            $tGrp->file( $groupout );

            orac_say "$out to $groupout:";
            orac_say " Copied to Group file.";

            if( defined( $tag ) && $tag eq $moment ) {
              _TAG_AS_REPRESENTATIVE_ FILE=$groupout UPDATE=0 GROUP=1 SUFFIX=rimg
            }

          }

          # Tag the moment map if the current moment is the requested one.
          if( defined( $tag ) && $tag eq $moment ) {
            if( $group == 2 ) {
              my $Frm = new $Obj;
              $Frm->file( $out );
              _TAG_AS_REPRESENTATIVE_ FILE=$out UPDATE=0 GROUP=$group2 SUFFIX=rimg
            } else {
              _TAG_AS_REPRESENTATIVE_ FILE=$out UPDATE=0 GROUP=$group SUFFIX=rimg
            }
          }

          # Find the position of the peak, then extract a spectrum
          # from that position, but only if the moment is 'integ'.
          if( $moment eq 'integ' ) {

            $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$out" );
            my( $ORAC_STATUS, @maxpos ) = $Mon{'kappa_mon'}->get( "stats", "maxpos" );
            $Obj->uhdr( "INTEG_MAX_POS", \@maxpos );

            my $tagspec = defined( $tag );

            if( $group == 2 ) {
              my $Frm = new $Obj;
              $Frm->files( $Obj->files );
              $Frm->uhdr( "INTEG_MAX_POS", \@maxpos );
              _EXTRACT_MAXVALUE_SPECTRUM_ TAG=$tagspec GROUP=$group2
            } else {
              _EXTRACT_MAXVALUE_SPECTRUM_ TAG=$tagspec GROUP=$group
            }
          }
        }
      }

      # Tidy-up output.
      orac_say "";

    }
  }
}
