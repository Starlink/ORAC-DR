# -*-cperl-*-

=head1 NAME

_CREATE_CUBE_GROUP_ -- Create a cube from a group of time-series ACSIS
observations.

=head1 DESCRIPTION

This primitive takes time-series ACSIS cubes from each observation in
the current group and runs MAKECUBE on them to create a
spatial/spectral cube.

=head1 ARGUMENTS

=over 4

=item BYTES_PER_PIXEL = INTEGER (Given)

The number of bytes per pixel. [4]

=item CHUNKSIZE = INTEGER (Given)

The maximum sum of file sizes in megabytes of files to process
simultaneously in MAKECUBE to avoid a timeout.  The choice is
affected by processor speed and memory.  [4096]

=item MAXSIZE = INTEGER (Given)

The maximum size, in bytes, of the output cube. This value does not
include extra information such as variance or weight arrays, FITS
headers, or any other NDF extensions. [512000000]

=item PARAM1 = REAL (Given)

The first parameter required by the spreading method. This parameter
is required by all methods, and specifies how many arcseconds on
either side of the output position are to receive contributions from
the input pixel. A value of zero indicates that a suitable number
should be calculated automatically. [0]

=item PARAM2 = REAL (Given)

The second parameter required by the spreading method, but only for
SombCos, Gauss, SincSinc, SincCos, and SincGauss schemes. For the
SombCos, SincSinc, and SincCos schemes, it specifies the number of
arcseconds at which the envelope of the function goes to zero. The
minimum value is 1.0 pixels, and the run-time default value is 2.0
pixels.  For the Gauss and SincGauss scheme, it specifies the
full-width at half-maximum (FWHM) of the Gaussian envelope.  The
minimum value is 0.1 pixels, and the run-time default is 1.0
pixels. Note that these numbers are given in pixels and this parameter
takes the number of requested arcseconds. This is done because the
pixel scale could be automatically determined from the data. []

=item PIXSIZE = REAL (Given)

The output pixel scale. If not defined, this value is automatically
determined from the data. []

=item OVERRIDE = LOGICAL (Given)

Whether or not specific arguments can be overridden by the recipe
parameter system. [1]

=item SPREAD = STRING (Given)

The interpolation method to use when regridding the cube. This can be
any of those allowed by MAKECUBE, listed in the SPREAD
parameter. ['nearest']

=item SYSTEM = STRING (Given)

The celestial coordinate system for the output cube. Can be any one of
ICRS, GAPPT, FK5, FK4, FK4-NO-E, AZEL, GALACTIC, or ECLIPTIC. A
special value of TRACKING can also be given, in which case the system
used will be that used as the tracking system during the
observation.

If this argument is not defined, then the system is determined from
the data and is typically set to 'tracking'. The only case where this
does not apply is if the observation is a scan and the scanning was
done in AZ/EL, in which case the system will be set to 'AZEL'.

This argument can be overridden by the RECPAR_SYSTEM uhdr via the
recipe parameter system. [undef]

=item TAG = BOOLEAN (Given)

Whether or not to tag the resulting cube(s) as 'reduced'. See the
_TAG_AS_REDUCED_PRODUCT_ primtive. [0]

=item TILEBORDER = INTEGER (Given)

The size of the border to be added to tiles. This is used when
smoothing the cube in spatial extent in later processing, so as to not
add edge effects. [0]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=back

=head1 OUTPUT DATA

=over 4

=item *

A cube (or set of cubes) whose filename is of the form
gaYYYYMMDD_NN_SS_cubeMMM.sdf, where YYYYMMDD is the UT date, NN is the
observation number, SS is the zero-padded subsystem number, and MMM is
the zero-padded tile number. Tiles are numbered starting from 1 and
increasing monotonically, counting from the bottom left corner in
spatial extent and proceeding in a raster fashion from left to right.

=back

=head1 TASKS

KAPPA: NDFTRACE.
SMURF: MAKECUBE.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008, 2010 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

use Math::Trig;

#  Define the scale factor to determine the pixel size in arcsec given
#  the observed frequency in Ghz.  This assumes a Nyquist sampling of
#  four pixels across the beam and a standard radiation pattern.  The
#  beam size is 1.2 * lambda / D radians, where D is the JCMT aperture of
#  15m.  Thus the factor is 1.2 * c/10**9 * ( 3600*180/pi ) / (4 * 15),
#  where c is the velocity of light in m/s.  The value has more
#  precision than needed, but it shows that the value is floating point.
use constant FREQ2PIXSIZE => 1236.7;
use constant MEGABYTE => 1048576;
use File::Copy;

# Deal with parameters.
my $system_arg = get_prim_arg( $_PRIM_ARGS_, "SYSTEM", undef );
my $spread = uc( get_prim_arg( $_PRIM_ARGS_, "SPREAD", 'NEAREST' ) );
my $sp_param1 = get_prim_arg( $_PRIM_ARGS_, "PARAM1", 0 );
my $sp_param2 = get_prim_arg( $_PRIM_ARGS_, "PARAM2", undef );
my $ppixsize = get_prim_arg( $_PRIM_ARGS_, "PIXSIZE", undef );
my $tileborder = get_prim_arg( $_PRIM_ARGS_, "TILEBORDER", 0 );
my $tag = get_prim_arg( $_PRIM_ARGS_, "TAG", 0 );
my $maxsize = get_prim_arg( $_PRIM_ARGS_, "MAXSIZE", 512000000 );
my $bytes_per_pixel = get_prim_arg( $_PRIM_ARGS_, "BYTES_PER_PIXEL", 4 );
my $chunksize = get_prim_arg( $_PRIM_ARGS_, "CHUNKSIZE", 4096 );
my $override = get_prim_arg( $_PRIM_ARGS_, "OVERRIDE", 1 );

# Override various parameters via the recipe parameter system.
if( $override ) {
  $chunksize = ( defined( $Frm->uhdr( "RECPAR_CHUNKSIZE" ) ) ?
                  $Frm->uhdr( "RECPAR_CHUNKSIZE" )            :
                  $chunksize );
  $sp_param1 = ( defined( $Frm->uhdr( "RECPAR_PARAM1" ) ) ?
                 $Frm->uhdr( "RECPAR_PARAM1" )            :
                 $sp_param1 );
  $sp_param2 = ( defined( $Frm->uhdr( "RECPAR_PARAM2" ) ) ?
                 $Frm->uhdr( "RECPAR_PARAM2" )            :
                 $sp_param2 );
  $ppixsize = ( defined( $Frm->uhdr( "RECPAR_PIXSIZE" ) ) ?
                $Frm->uhdr( "RECPAR_PIXSIZE" )            :
                $ppixsize );
  $spread = ( defined( $Frm->uhdr( "RECPAR_SPREAD_METHOD" ) ) ?
              $Frm->uhdr( "RECPAR_SPREAD_METHOD" )            :
              $spread );
  $system_arg = ( defined( $Frm->uhdr( "RECPAR_SYSTEM" ) ) ?
                  $Frm->uhdr( "RECPAR_SYSTEM" )            :
                  $system_arg );
}

# Only process if we're on the last member of a group.
if( $Grp->lastallmembers( $Frm ) ) {

  # We don't need to go through with all of this if there's only one
  # member of the group.
  if( $Grp->uhdr( "COPY_FRAME_CUBE" ) ) {

    # Keep the product around so we can set it once we're done.
    my $prod = $Frm->product;

    # Retrieve the tagged frame and copy them into the Group object.
    _RETRIEVE_TAG_ TAG=POST_CREATE_CUBE_FRAME

    # Now copy over each of the Frame files.
    foreach my $i ( 1 .. $Frm->nfiles ) {

      my $in = $Frm->file( $i );
      ( undef, my $out ) = $Grp->inout( "_cube", $i );

      $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$out" );

      $Grp->allow_header_sync( 1 );
      $Grp->file( $i, $out );
      $Grp->sync_headers( $i );

      orac_print "$in to $out:\n";
      orac_print " Copied to Group file.\n";

    }

    # Set Frame back to whatever it was before.
    _RETRIEVE_TAG_ TAG=PREVIOUS
    $Frm->product( $prod );
    $Frm->sync_headers;

  } else {

    # Create the command-line parameters for MAKECUBE.
    # ================================================

    # We want to go through each member Frm in the Grp and determine
    # the MAKECUBE parameters individually. Then, we'll take the
    # smallest pixelscale and use that for the output cube.

    my $obstype = $Frm->uhdr( "ORAC_OBSERVATION_TYPE" );
    my %pixsize;
    my %crota;
    my %system;
    my %usedetpos;
    foreach my $Frm ( $Grp->members ) {

      _GET_MAKECUBE_PARAMS_ TYPE=$obstype
      my $mc_params = $_GET_MAKECUBE_PARAMS_{PARAMS};
      my $mc_hash = $_GET_MAKECUBE_PARAMS_{HASH};

      if( lc( $obstype ) ne 'raster' ) {

        # If we're not doing a raster, then we have to run MAKECUBE in
        # autogrid, then determine the pixel scale from the result of
        # that. _GET_MAKECUBE_PARAMS_ returns autogrid=yes for
        # anything that isn't a raster.

        my $inlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
        my $inlist_fh = $inlist->handle;
        foreach my $i ( 1 .. $Frm->nfiles ) {
          print $inlist_fh $Frm->file( $i ) . "\n";
        }
        $inlist->handle->close;

        orac_print "Determining parameters for output cube...";
        $Mon{'smurf_mon'}->obeyw( "makecube", "$mc_params in='^$inlist' out=!" );
        orac_print "done.\n";

        # Get the returned pixsize and crota, but only if this isn't a
        # sparse cube.
        my ( $ORAC_STATUS, $sparse ) = $Mon{'smurf_mon'}->get( "makecube", "sparse" );
        if( uc( $sparse ) eq 'FALSE' ) {
          ( $ORAC_STATUS, my $pixsize ) = $Mon{'smurf_mon'}->get( "makecube", "pixsize" );
          ( $ORAC_STATUS, my $crota ) = $Mon{'smurf_mon'}->get( "makecube", "crota" );

          # Stick these into the hash.
          $pixsize{$Frm->file(1)} = $pixsize;
          $crota{$Frm->file(1)} = $crota;
        }
      } else {
        # Raster parameters come directly from the
        # _GET_MAKECUBE_PARAMS_ primitive results.
        $pixsize{$Frm->file} = ( defined( $ppixsize ) ? $ppixsize : $mc_hash->{pixsize} );
        $crota{$Frm->file} = $mc_hash->{crota};
      }
      $usedetpos{$Frm->file(1)} = $mc_hash->{usedetpos};
      $system{$Frm->file(1)} = $mc_hash->{system};
    }

    # Define a variable that'll hold parameters to MAKECUBE.
    my $params = '';

    # We have a hash with a bunch of systems in it. If they're all the
    # same, use that. Otherwise set the system to 'ICRS'.
    my %seen = ();
    my @uniq = grep { ! $seen{$_} ++ } values %system;
    my $system = ( $#uniq == 0 ? $uniq[0] : 'ICRS' );

    $system = ( defined( $system_arg ) ? $system_arg : $system );

    # Ditto with USEDETPOS, but default to 'no'.
    %seen = ();
    @uniq = grep { ! $seen{$_} ++ } values %usedetpos;
    my $usedetpos = ( $#uniq == 0 ? $uniq[0] : 'no' );
    my $tiledims;
    my $sp_params;

    # Check to see if we have any pixel sizes back from the previous
    # MAKECUBE runs. If we don't have any, then all of the resulting
    # cubes will be sparse, so set autogrid=yes and ignore
    # tiling. Otherwise, we want to find the smallest pixel size and
    # go with that.
    if ( scalar values %pixsize == 0 ) {

      orac_warn "Resulting cube will be sparse.\n";
      $Grp->uhdr( "SPARSE", 1 );
      $params = "autogrid=yes system=$system";

    } else {

      $Grp->uhdr( "SPARSE", 0 );

      my $pixsize = 100;
      if( ! defined( $ppixsize ) ) {
        foreach my $value ( values %pixsize ) {
          $pixsize = ( $value > $pixsize ) ? $pixsize : $value;
        }

        # Check the pixel size. If it's smaller than a quarter of the
        # beamsize, set it to a quarter of the beamsize.
        my $lofreqs = defined( $Frm->hdr( "LOFREQS" ) ) ?
                      $Frm->hdr( "LOFREQS" )            :
                      $Frm->jcmtstate( "FE_LOFREQ" );

        my $min_pixsize = int( FREQ2PIXSIZE / $lofreqs + 0.5 );
        $pixsize = ( $pixsize < $min_pixsize ) ? $min_pixsize : $pixsize;
      } else {
        $pixsize = $ppixsize;
      }

      # We have a hash with a bunch of rotation angles in it. Set the
      # rotation angle to be the average of all of these. Deal with
      # the wrap-around by averaging the sin and cos instead of the angle.
      my $sin_a = 0;
      my $cos_a = 0;

      map { $sin_a += sin( $_ * pi/180.0 ) } values %crota;
      map { $cos_a += cos( $_ * pi/180.0 ) } values %crota;

      $sin_a /= scalar values %crota;
      $cos_a /= scalar values %crota;
      my $crota = sprintf "%6.2f", atan2($sin_a, $cos_a) * 180.0/pi;
      $crota = 0.00 if ( abs($crota) < 0.2 );

      # However! If we have a user-defined system, set the CROTA to 0.
      if( defined( $system_arg ) ) {
        $crota = 0;
      }

      # Find out how big our tiles are going to be.  Since we do not
      # want the tile dimensions to vary in order to enable tiles from
      # each chunk to be combined, disable the ability to adjust the
      # tile dimensions arbitrarily.  This is achieved by setting the
      # dimension negative.
      _GET_TILE_DIMENSIONS_ TILEBORDER=$tileborder MAXSIZE=$maxsize BYTES_PER_PIXEL=$bytes_per_pixel
      $tiledims = -1 * $_GET_TILE_DIMENSIONS_{TILEDIMS};

      # Get the parameter string to send to makecube.
      _GET_SPREAD_PARAMS_ METHOD=$spread PARAM1=$sp_param1 PARAM2=$sp_param2 PIXSIZE=$pixsize
      $sp_params = $_GET_SPREAD_PARAMS_{PARAMSTRING};

      # Set up MAKECUBE parameters.
      $params  = "pixsize=$pixsize crota=$crota spread=$spread params=$sp_params usedetpos=$usedetpos";
      $params .= " tiledims=$tiledims system=$system autogrid=yes tileborder=$tileborder trimtiles=yes";

    }

    # Always use badmask=and.
    $params .= " badmask=and";

    # Quick hack for hybrid-mode observations.
    if( $Frm->uhdr( "ISHYBRID" ) ) {
      $params .= " specunion=YES";
    }

    # If the data units are Kelvin, then we can generate a variance
    # from TSYS. Otherwise, we can generate a variance from the spread
    # of the input data values contributing to each output pixel.
    $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=" . $Frm->file(1) . " fullframe" );
    my ( $ORAC_STATUS, $units ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "units" );
    if( $units eq 'K' ) {
      $params .= " genvar=tsys inweight=true";
    } else {
      $params .= " genvar=spread inweight=false";
    }

    # Determine the reference sky co-ordinates and spectral bounds for all the files
    # ==============================================================================

    # Form a list of all the input filenames and determine their total size.
    # Also store the filenames in a GRP list text file.
    my $inlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
    my $inlist_fh = $inlist->handle;
    my @infiles;
    my $totalsize = 0;
    my $num_files = 0;
    foreach my $Frm ( $Grp->members ) {
      foreach my $i ( 1 .. $Frm->nfiles ) {
        print $inlist_fh $Frm->file( $i ) . "\n";
        push @infiles, $Frm->file( $i );
        my $fullname = $Frm->file( $i ) . ".sdf";
        $totalsize += ( -s $fullname ) / MEGABYTE;
        $num_files++;
      }
    }
    $inlist->handle->close;

    # Do not create the output file, thus this is a quick operation.
    $Mon{'smurf_mon'}->obeyw( "makecube", "$params in='^" . $inlist->file . "' out=!" );
    ( $ORAC_STATUS, my $reflon ) = $Mon{'smurf_mon'}->get( "makecube", "reflon" );
    ( $ORAC_STATUS, my $reflat ) = $Mon{'smurf_mon'}->get( "makecube", "reflat" );
    ( $ORAC_STATUS, my @flbnd ) = $Mon{'smurf_mon'}->get( "makecube", "flbnd");
    ( $ORAC_STATUS, my @fubnd ) = $Mon{'smurf_mon'}->get( "makecube", "fubnd" );
    my $specbounds = "'" . $flbnd[2] . "," . $fubnd[2] . "'";
    $params .= " reflon=$reflon reflat=$reflat specunion specbounds=$specbounds";

    # Obtain the total number of tiles.
    ( $ORAC_STATUS, my $totaltile ) = $Mon{'smurf_mon'}->get( "makecube", "ntile" );

    # Chunking not required
    # =====================

    my ( $in, $out ) = $Grp->inout( "_cube" );
    if ( $totalsize / MEGABYTE <= $chunksize ) {
      orac_print "Creating cube from " . join( ", ", @infiles ) . "... ";

      $Mon{'smurf_mon'}->obeyw( "makecube", "$params in='^" . $inlist->file . "' out=$out" );
      orac_say "done.";

    } else {

      # Divide the list into manageable chunks to prevent a timeout.
      # ============================================================

      # The approach is to attempt to reduce each observation separately
      # on the same grid of tiles, and only chunk an observation if it
      # contains too much data.  Then combine each observation of a tile.
      # Thus edge artefacts from smoothing in chunks rather than the
      # observation as whole is reduced.

      # We want to find the extreme bounds of the tiles.  The central tile
      # is symmetric around bound (0,0).  Initialise the limits accordingly.
      my @full_lb = ( 1, 1 );
      my @full_ub = ( -1, -1 );

      my $fi = 0;
      my @chunk_ntile;

      # Process each observation separately.
      my $chunk_index = 0;
      foreach my $Frm ( $Grp->members ) {

        my $sumsize = 0;
        my @chfiles;

        # Look at each input file within the Frame and see if it needs
        # chunking.
        foreach my $i ( 1 .. $Frm->nfiles ) {
          my $fullname = $Frm->file( $i ) . ".sdf";
          my $filesize = ( -s $fullname )/ MEGABYTE;

          # Continue to add files to the current chunk until the size
          # limit is surpassed.  Spectral-cube formation is always
          # required for the last file in the Frame.
          if ( ( $sumsize + $filesize ) <= $chunksize && $i < $Frm->nfiles ) {
            $sumsize += $filesize;
            push @chfiles, $infiles[ $fi ];
            $fi++;

          } else {

            # Append the final input time-series file to the the list
            # for the final chunk of the Frame.  This rarely may cause the
            # final chunk to be larger than CHUNKSIZE.
            if ( $i == $Frm->nfiles ) {
              push @chfiles, $infiles[ $fi ];
              $fi++;
            }

            # Create a text listing all the output files.
            my $outlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
            my $outlist_fh = $outlist->handle;

            # Find and report the number of files in the chunk.
            my $chunk = @chfiles;
            my $string = ( $chunk == 1 ) ? "file" : "files";
            $chunk_index++;
            orac_print "Chunk: $chunk_index contains $chunk $string.\n";

            # Form text file listing the chunk's members for MAKECUBE.
            my $chlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
            my $chlist_fh = $chlist->handle;

            for ( my $k = 0; $k < $chunk; $k++ ) {
              print $chlist_fh $chfiles[ $k ] . "\n";
            }
            $chlist->handle->close;

            # Form tiles for current chunk. Use suffix to delineate the
            # chunks.
            my ( $in, $out ) = $Grp->inout( "_cube" );
            $out .= "_ch" . "$chunk_index";

            # Process the current manageable chunk of input time series
            # into spectral cubes.
            orac_print "Creating cube $out from " . join( ", ", @chfiles ) . "...\n";

            $Mon{'smurf_mon'}->obeyw( "makecube", "$params in='^" . $chlist->file . "' out=$out" );
            orac_say "done.";
            undef $chlist;

            # Find and record the number of tiles in the current chunk.
            ( $ORAC_STATUS, my $ntile ) = $Mon{'smurf_mon'}->get( "makecube", "ntile" );
            push @chunk_ntile, $ntile;

            # Assign tiles in the current chunk to their index within the
            # full set of tiles, as if processing all the time series
            # simultaneously.

            # The tiles are always numbered from 1 at the lower left to ntile
            # at the upper right.  Thus the lower bound of the first tile will
            # be most negative and the upper bound of the last tile will be
            # the most positive.
            my $lb_file= ( $ntile > 1 ) ? $out . "_1" : $out;
            _GET_DIMENSIONS_ FILE=$lb_file
            my @lbnd = @{$_GET_DIMENSIONS_{LBOUND}};
            $full_lb[0] = min( $lbnd[0], $full_lb[0] );
            $full_lb[1] = min( $lbnd[1], $full_lb[1] );

            my $ub_file= ( $ntile > 1 ) ? $out . "_" . $ntile : $out;
            _GET_DIMENSIONS_ FILE=$ub_file
            my @ubnd = @{$_GET_DIMENSIONS_{UBOUND}};
            $full_ub[0] = max( $ubnd[0], $full_ub[0] );
            $full_ub[1] = max( $ubnd[1], $full_ub[1] );

            # Start a new list of files for the new chunk.
            if ( $i < $Frm->nfiles ) {
              @chfiles = ( $infiles[ $fi ] );
              $sumsize = $filesize;
            }
          }
        }
      }
      my $total_chunk = $chunk_index;
      orac_print "Spatial extent of tiles is (" . $full_lb[0] . "," .
                 $full_lb[1] . ") to (" . $full_ub[0] . "," . $full_ub[1] .")\n";

      # Assign files in each chunk to the grand-mosaic tiles.
      # =====================================================
      #
      ( undef, my $out ) = $Grp->inout( "_cube" );
      if ( $total_chunk > 1 ) {

        # Reset the tile dimensions to the original value.
        $tiledims *= -1;

        # Find the number of tiles along each spatial axis, and
        # hence the x-y indices of the centre.  This assumes that
        # the reference point is at the centre of a tile.
        my $fulltile = $tiledims + 2 * $tileborder;
        my $halftile = int( $fulltile / 2 );
        my $nx = int( $full_ub[0] / $tiledims + 0.5 ) + 1 +
                 int( abs( $full_lb[0] ) / $tiledims + 0.5 );
        my $ny = int( $full_ub[1] / $tiledims + 0.5 ) + 1 +
                 int( abs( $full_lb[1] ) / $tiledims + 0.5 );
        my @centre_index;
        $centre_index[0] = int( ( $nx + 1 ) / 2 );
        $centre_index[1] = int( ( $ny + 1 ) / 2 );

        my @tilenames;

        # Store the tile spatial upper and lower bounds, constrained by
        # the actual limiting bounds.  The bounds must always be integer
        # so apply the half-tile shift as integer.  Also the limits are
        # not symmetric, being offset from (1,1) not (0,0).
        my ( @tile_xl, @tile_xu, @tile_yl, @tile_yu );
        $halftile = int( ( $tiledims + 1 ) / 2 );
        foreach my $c ( 1 .. $totaltile ) {
          my $xi = ( $c - 1 ) % $nx + 1;
          my $yi = int( ( $c - 1 ) / $nx ) + 1;
          $tile_xl[$c] = max( $full_lb[0], 1 - $halftile - $tileborder +
                              ( $xi - $centre_index[0] ) * $tiledims );
          $tile_xu[$c] = min( $full_ub[0], $tileborder + $halftile +
                              ( $xi - $centre_index[0] ) * $tiledims  );

          $tile_yl[$c] = max( $full_lb[1], 1 - $halftile - $tileborder +
                              ( $yi - $centre_index[1] ) * $tiledims );
          $tile_yu[$c] = min( $full_ub[1], $tileborder + $halftile +
                              ( $yi - $centre_index[1] ) * $tiledims );
          orac_print "Tile: " . $c . "  bounds (" . $tile_xl[$c] . "," . $tile_yl[$c] . ") ";
          orac_print "to : (" . $tile_xu[$c] . "," . $tile_yu[$c] .")\n";

        }

        foreach my $c ( 1 .. $total_chunk ) {
          foreach my $t ( 1 .. $chunk_ntile[$c - 1] ) {
            my $chunk_file = $out . "_ch" . $c;
            if ( $chunk_ntile[$c - 1] > 1 ) { $out .= "_" . $t }
            _GET_DIMENSIONS_ FILE=$chunk_file
            my @lbnd = @{$_GET_DIMENSIONS_{LBOUND}};
            my @ubnd = @{$_GET_DIMENSIONS_{UBOUND}};
            orac_print "Chunk: $chunk_file has bounds ($lbnd[0],$lbnd[1]) to ($ubnd[0],$ubnd[1]).\n";

            # Find the tile indices that the current chunk spans along
            # each axis, using the offsets from the centre (0,0).
            my @ti_lb = ( 0, 0 );
            my @ti_ub = ( 0, 0 );
            for ( my $i = 0; $i < 2; $i++ ) {
              $ti_lb[$i] = int( $lbnd[$i] / $tiledims +
                                ( $lbnd[$i] >= 0 ? +1 : -1 ) * 0.5 ) + $centre_index[$i];
              $ti_ub[$i] = int( $ubnd[$i] / $tiledims +
                                ( $ubnd[$i] >= 0 ? +1 : -1 ) * 0.5 ) + $centre_index[$i];
            }
            orac_print "Tiles: $chunk_file spans tiles ($ti_lb[0],$ti_lb[1]) to ($ti_ub[0],$ti_ub[1]).\n";

            # Convert the x,y indices to a tile index to store the
            # contributing chunk names, constrained with bounds to lie
            # solely within the tile.
            my $tileindex;
            my $tile_section;
            for ( my $j = $ti_lb[1]; $j <= $ti_ub[1]; $j++ ) {
              for ( my $i = $ti_lb[0]; $i <= $ti_ub[0]; $i++ ) {
                $tileindex = $i + $nx * ( $j - 1 );
                $tile_section = "(" . $tile_xl[$tileindex] . ":" . $tile_xu[$tileindex] . "," .
                                 $tile_yl[$tileindex] . ":" . $tile_yu[$tileindex] . ",)";
                $tilenames[$tileindex] .= $chunk_file . $tile_section . " ";
                orac_print "File " . $chunk_file . " is in Tile " . $tileindex . ".\n";
              }
            }
          }
        }

        foreach my $c ( 1 .. $totaltile ) {

          # Form text file listing the chunk's members for MAKEMOS.
          my $mmlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
          my $mmlist_fh = $mmlist->handle;

          $tilenames[$c] =~ s/^\s+//;
          my @frames = split ( ' ', $tilenames[$c] );
          my $nframe = @frames;
          orac_print "Number of frames in current tile: " . $nframe . "\n";

          # Mimic MAKECUBE's output-NDF naming convention, i.e. exclude the
          # _<tile> suffix if there is only one tile.
          my $mmout = ( $totaltile > 1 ) ? $out . "_" . $c : $out;

          if ( $nframe > 1 ) {
            my $mm_params = "usevar method=mean genvar nozero noscale";
            foreach my $i ( 1.. $nframe ) {
              print $mmlist_fh $frames[ $i - 1 ] . "\n";
              orac_print "  " . $frames[ $i - 1 ] . "\n";
            }
            $mmlist->handle->close;

            # Combine the tiles as if we had processed all the data in
            # one MAKECUBE invocation.
            orac_print "Running MAKEMOS on Tile $c to form $mmout.\n";
            $Mon{'ccdpack_reg'}->obeyw( "makemos", "$mm_params in='^" . $mmlist->file . "' out=$mmout" );
            undef $mmlist;

          } elsif ( $nframe > 1 ) {
            orac_print "Only one file contributes to Tile $c\n";
            orac_print "Rename ". $frames[0] . " to $mmout \n";
            copy( $frames[0] . ".sdf", $mmout . ".sdf" );

          } else {
            orac_print "No files contribute to Tile $c\n";
          }
        }
      }
    }
    undef $inlist;

    # Get DATE-OBS and DATE-END from the members of the group. Find the
    # earliest DATE-OBS and the latest DATE-END and stick these into the
    # Grp header.
    my @utstart = sort map { $_->uhdr( "ORAC_UTSTART" ) } $Grp->members;
    my @utend = sort map { $_->uhdr( "ORAC_UTEND" ) } $Grp->members;
    my $dateobs = $utstart[0]->datetime;
    my $dateend = $utend[-1]->datetime;

    # We need to rename the output cube(s), as MAKECUBE creates _N and
    # we want _cubeNNN.
    my @files;
    my $numbad = 0;
    my $outfilenumber = 1;
    if( $totaltile > 1 ) {
      foreach my $j ( 1 .. $totaltile ) {
        my $makecube_outfile = "${out}_$j.sdf";
        my $outfile = sprintf( "$out%03d", $outfilenumber ) . ".sdf";

        if( -e $makecube_outfile ) {

          # Run STATS to find out if this tile is blank or not.
          $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$makecube_outfile" );
          ( my $ORAC_STATUS, my $numgood ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );
          if( $numgood == 0 ) {
            unlink( $makecube_outfile );
            $numbad++;
            next;
          }

          rename( $makecube_outfile, $outfile ) or die "Could not rename $makecube_outfile to $outfile: $!\n";
          $outfile =~ s/\.sdf$//;

          _SET_FILE_FITS_ITEM_ FILE=$outfile KEY=DATE-OBS VALUE=$dateobs
          _SET_FILE_FITS_ITEM_ FILE=$outfile KEY=DATE-END VALUE=$dateend

          push( @files, $outfile );
          $outfilenumber++;
        }
      }

    # The number of tiles is only one.  MAKECUBE does not append a _1
    # suffix.  Again we still want CUBENNN naming.
    } else {
      my $outfile = "${out}001.sdf";
      rename( $out . ".sdf", $outfile ) or die "Could not rename " . $out . ".sdf to $outfile: $!\n";
      $outfile =~ s/\.sdf$//;

      _SET_FILE_FITS_ITEM_ FILE=$outfile KEY=DATE-OBS VALUE=$dateobs
      _SET_FILE_FITS_ITEM_ FILE=$outfile KEY=DATE-END VALUE=$dateend

      push( @files, $outfile );
    }

    $totaltile -= $numbad;

    orac_print " " . scalar( @files ) . " cube" . ( $totaltile > 1 ? 's' : '' ) . " formed: ";

    $Grp->allow_header_sync( 1 );
    $Grp->product( "cube" );
    $Grp->files( @files );
    my $filestring = join ", ", @files;
    orac_print "$filestring\n";

  }

  # Tag as reduced, if requested.
  if( $tag ) {
    orac_say "";
    _TAG_AS_REDUCED_PRODUCT_ GROUP=1 UPDATE=1 FLAG_QUAL_BAD=1
  }

  $Grp->readhdr;

  $Display->display_data( $Grp ) if defined $Display;

}

# Tidy-up output.
orac_print "\n";
