# -*-perl-*-

=head1 NAME

_CREATE_CUBE_GROUP_ -- Create a cube from a group of time-series ACSIS
observations.

=head1 DESCRIPTION

This primitive takes time-series ACSIS cubes from each observation in
the current group and runs MAKECUBE on them to create a
spatial/spectral cube.

=head1 ARGUMENTS

=over 4

=item BYTES_PER_PIXEL = INTEGER (Given)

The number of bytes per pixel. [4]

=item MAXSIZE = INTEGER (Given)

The maximum size, in bytes, of the output cube. This value does not
include extra information such as variance or weight arrays, FITS
headers, or any other NDF extensions. [512000000]

=item PARAMS = STRING (Given)

An optional array which consists of additional parameters required by
the Sinc, SincSinc, SincCos, SincGauss, Somb, SombCos, and Gauss
spreading methods (see parameter SPREAD). See documentation for the
PARAMS parameter for MAKECUBE. ['']

=item SPREAD = STRING (Given)

The interpolation method to use when regridding the cube. This can be
any of those allowed by MAKECUBE, listed in the SPREAD
parameter. ['nearest']

=item TAG = BOOLEAN (Given)

Whether or not to tag the resulting cube(s) as 'reduced'. See the
_TAG_AS_REDUCED_PRODUCT_ primtive. [0]

=item TILEBORDER = INTEGER (Given)

The size of the border to be added to tiles. This is used when
smoothing the cube in spatial extent in later processing, so as to not
add edge effects. [0]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=back

=head1 OUTPUT DATA

=over 4

=item *

A cube (or set of cubes) whose filename is of the form
gaYYYYMMDD_NN_SS_cubeMMM.sdf, where YYYYMMDD is the UT date, NN is the
observation number, SS is the zero-padded subsystem number, and MMM is
the zero-padded tile number. Tiles are numbered starting from 1 and
increasing monotonically, counting from the bottom left corner in
spatial extent and proceeding in a raster fashion from left to right.

=back

=head1 TASKS

KAPPA: NDFTRACE.
SMURF: MAKECUBE.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Deal with parameters.
my $spread = uc( get_prim_arg( $_PRIM_ARGS_, "SPREAD", 'NEAREST' ) );
my $sp_param1 = get_prim_arg( $_PRIM_ARGS_, "PARAM1", 0 );
my $sp_param2 = get_prim_arg( $_PRIM_ARGS_, "PARAM2", undef );
my $ppixsize = get_prim_arg( $_PRIM_ARGS_, "PIXSIZE", undef );
my $tileborder = get_prim_arg( $_PRIM_ARGS_, "TILEBORDER", 0 );
my $tag = get_prim_arg( $_PRIM_ARGS_, "TAG", 0 );
my $maxsize = get_prim_arg( $_PRIM_ARGS_, "MAXSIZE", 512000000 );
my $bytes_per_pixel = get_prim_arg( $_PRIM_ARGS_, "BYTES_PER_PIXEL", 4 );

# Only process if we're on the last member of a group.
if( $Grp->lastallmembers( $Frm ) ) {

  # We don't need to go through with all of this if there's only one
  # member of the group.
  if( $Grp->uhdr( "COPY_FRAME_CUBE" ) ) {

    # Keep the product around so we can set it once we're done.
    my $prod = $Frm->product;

    # Retrieve the tagged frame and copy them into the Group object.
    _RETRIEVE_TAG_ TAG=POST_CREATE_CUBE_FRAME

    # Now copy over each of the Frame files.
    foreach my $i ( 1 .. $Frm->nfiles ) {

      my $in = $Frm->file( $i );
      ( undef, my $out ) = $Grp->inout( "_cube", $i );

      $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$out" );

      $Grp->allow_header_sync( 1 );
      $Grp->file( $i, $out );
      $Grp->sync_headers( $i );

      orac_print "$in to $out:\n";
      orac_print " Copied to Group file.\n";

    }

    # Set Frame back to whatever it was before.
    _RETRIEVE_TAG_ TAG=PREVIOUS
    $Frm->product( $prod );
    $Frm->sync_headers;

  } else {

    # We want to go through each member Frm in the Grp and determine
    # the MAKECUBE parameters individually. Then, we'll take the
    # smallest pixelscale and use that for the output cube.

    my $obstype = $Frm->uhdr( "ORAC_OBSERVATION_TYPE" );
    my %pixsize;
    my %crota;
    my %system;
    my %usedetpos;
    foreach my $Frm ( $Grp->members ) {

      _GET_MAKECUBE_PARAMS_ TYPE=$obstype
      my $mc_params = $_GET_MAKECUBE_PARAMS_{PARAMS};
      my $mc_hash = $_GET_MAKECUBE_PARAMS_{HASH};

      if( lc( $obstype ) ne 'raster' ) {

        # If we're not doing a raster, then we have to run MAKECUBE in
        # autogrid, then determine the pixel scale from the result of
        # that. _GET_MAKECUBE_PARAMS_ returns autogrid=yes for
        # anything that isn't a raster.

        my $inlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
        my $inlist_fh = $inlist->handle;
        foreach my $i ( 1 .. $Frm->nfiles ) {
          print $inlist_fh $Frm->file( $i ) . "\n";
        }
        $inlist->handle->close;

        orac_print "Determining parameters for output cube...";
        $Mon{'smurf_mon'}->obeyw( "makecube", "$mc_params in='^$inlist' out=!" );
        orac_print "done.\n";

        # Get the returned pixsize and crota, but only if this isn't a
        # sparse cube.
        my ( $ORAC_STATUS, $sparse ) = $Mon{'smurf_mon'}->get( "makecube", "sparse" );
        if( uc( $sparse ) eq 'FALSE' ) {
          ( $ORAC_STATUS, my $pixsize ) = $Mon{'smurf_mon'}->get( "makecube", "pixsize" );
          ( $ORAC_STATUS, my $crota ) = $Mon{'smurf_mon'}->get( "makecube", "crota" );

          # Stick these into the hash.
          $pixsize{$Frm->file(1)} = $pixsize;
          $crota{$Frm->file(1)} = $crota;
        }
      } else {
        # Raster parameters come directly from the
        # _GET_MAKECUBE_PARAMS_ primitive results.
        $pixsize{$Frm->file} = ( defined( $ppixsize ) ? $ppixsize : $mc_hash->{pixsize} );
        $crota{$Frm->file} = $mc_hash->{crota};
      }
      $usedetpos{$Frm->file(1)} = $mc_hash->{usedetpos};
      $system{$Frm->file(1)} = $mc_hash->{system};
    }

    # Define a variable that'll hold parameters to MAKECUBE.
    my $params = '';

    # We have a hash with a bunch of systems in it. If they're all the
    # same, use that. Otherwise set the system to 'ICRS'.
    my %seen = ();
    my @uniq = grep { ! $seen{$_} ++ } values %system;
    my $system = ( $#uniq == 0 ? $uniq[0] : 'ICRS' );

    # Ditto with USEDETPOS, but default to 'no'.
    %seen = ();
    @uniq = grep { ! $seen{$_} ++ } values %usedetpos;
    my $usedetpos = ( $#uniq == 0 ? $uniq[0] : 'no' );

    # Check to see if we have any pixel sizes back from the previous
    # MAKECUBE runs. If we don't have any, then all of the resulting
    # cubes will be sparse, so set autogrid=yes and ignore
    # tiling. Otherwise, we want to find the smallest pixel size and
    # go with that.
    if ( scalar values %pixsize == 0 ) {

      orac_warn "Resulting cube will be sparse.\n";
      $Grp->uhdr( "SPARSE", 1 );
      $params = "autogrid=yes system=$system";

    } else {

      $Grp->uhdr( "SPARSE", 0 );

      my $pixsize = 100;
      if( ! defined( $ppixsize ) ) {
        foreach my $value ( values %pixsize ) {
          $pixsize = ( $value > $pixsize ) ? $pixsize : $value;
        }

        # Check the pixel size. If it's smaller than a quarter of the
        # beamsize, set it to a quarter of the beamsize.
        my $lofreqs = $Frm->hdr( "LOFREQS" );
        my $min_pixsize = int( $lofreqs * 0.011467099683 + 0.5 );
        $pixsize = ( $pixsize < $min_pixsize ) ? $min_pixsize : $pixsize;
      } else {
        $pixsize = $ppixsize;
      }

      # We have a hash with a bunch of rotation angles in it. If
      # they're all the same, use that. Otherwise set the rotation
      # angle to zero.
      %seen = ();
      @uniq = grep { ! $seen{$_} ++ } values %crota;
      my $crota = ( $#uniq == 0 ? $uniq[0] : 0 );

      # Find out how big our tiles are going to be.
      _GET_TILE_DIMENSIONS_ TILEBORDER=$tileborder
      my $tiledims = $_GET_TILE_DIMENSIONS_{TILEDIMS};

      # Sort out the spread parameters. These were given in arcseconds
      # and we want to convert them to pixels. $sp_param1 is easy, we
      # just divide it. $sp_param2's default depends on the spread
      # function, so that takes a little more work to calculate.
      my $sp_param1_pixel = $sp_param1 / $pixsize;
      my $sp_param2_pixel;
      if( defined( $sp_param2 ) ) {
        $sp_param2_pixel = $sp_param2 / $pixsize;
      } else {
        if( $spread =~ /^(SOMBCOS|SINCSINC|SINCCOS)$/ ) {
          $sp_param2_pixel = 2;
        } elsif( $spread =~ /^(GAUSS|SINCGAUSS)$/ ) {
          $sp_param2_pixel = 1;
        }
      }
      my $sp_params;
      if( $spread =~ /^(LINEAR|NEAREST)$/ ) {
        $sp_params = "''";
      } elsif( $spread =~ /^(SINC|SOMB)$/ ) {
        $sp_params = "[$sp_param1_pixel]";
      } elsif( $spread =~ /^(SOMBCOS|SINCSINC|SINCCOS|GAUSS|SINCGAUSS)$/ ) {
        $sp_params = "[$sp_param1_pixel,$sp_param2_pixel]";
      }

      # Set up MAKECUBE parameters.
      $params  = "pixsize=$pixsize crota=$crota spread=$spread params=$sp_params usedetpos=$usedetpos";
      $params .= " tiledims=$tiledims system=$system autogrid=yes tileborder=$tileborder trimtiles=yes";

    }

    # Always use badmask=and.
    $params .= " badmask=and";

    # Quick hack for hybrid mode observations.
    if( $Frm->uhdr( "ISHYBRID" ) ) {
      $params .= " specunion=YES";
    }

    # If the data units are Kelvin, then we can generate a variance
    # from TSYS. Otherwise, we can generate a variance from the spread
    # of the input data values contributing to each output pixel.
    $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=" . $Frm->file(1) . " fullframe" );
    my ( $ORAC_STATUS, $units ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "units" );
    if( $units eq 'K' ) {
      $params .= " genvar=tsys inweight=true";
    } else {
      $params .= " genvar=spread inweight=false";
    }

    my $inlist = new ORAC::TempFile( OPEN => 1, SUFFIX => '.lis' );
    my $inlist_fh = $inlist->handle;
    foreach my $Frm ( $Grp->members ) {
      foreach my $i ( 1 .. $Frm->nfiles ) {
        print $inlist_fh $Frm->file( $i ) . "\n";
      }
    }
    $inlist->handle->close;

    my ( $in, $out ) = $Grp->inout( "_cube" );

    orac_print "Creating cube...";

    $Mon{'smurf_mon'}->obeyw( "makecube", "$params in='^" . $inlist->file . "' out=$out" );
    orac_print "done.\n";

    # Handle tiles.
    ( $ORAC_STATUS, my $ntile ) = $Mon{'smurf_mon'}->get( "makecube", "ntile" );

    # Get DATE-OBS and DATE-END from the members of the group. Find the
    # earliest DATE-OBS and the latest DATE-END and stick these into the
    # Grp header.
    my @utstart = sort map { $_->uhdr( "ORAC_UTSTART" ) } $Grp->members;
    my @utend = sort map { $_->uhdr( "ORAC_UTEND" ) } $Grp->members;
    my $dateobs = $utstart[0]->datetime;
    my $dateend = $utend[-1]->datetime;

    # We need to rename the output cube(s), as MAKECUBE creates _N and
    # we want _cubeNNN.
    my @files;
    my $numbad = 0;
    if( $ntile > 1 ) {
      foreach my $j ( 1 .. $ntile ) {
        my $makecube_outfile = "${out}_$j.sdf";
        my $outfile = sprintf( "$out%03d", $j ) . ".sdf";

        if( -e $makecube_outfile ) {

          # Run STATS to find out if this tile is blank or not.
          $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$makecube_outfile" );
          ( $ORAC_STATUS, my $numgood ) = $Mon{'kappa_mon'}->get( "stats", "numgood" );
          if( $numgood == 0 ) {
            $numbad++;
            next;
          }

          rename( $makecube_outfile, $outfile );
          $outfile =~ s/\.sdf$//;

          _SET_FILE_FITS_ITEM_ FILE=$outfile KEY=DATE-OBS VALUE=$dateobs
          _SET_FILE_FITS_ITEM_ FILE=$outfile KEY=DATE-END VALUE=$dateend

          push( @files, $outfile );
        }
      }
    } else {
      my $outfile = "${out}001.sdf";
      rename( $out . ".sdf", $outfile );
      $outfile =~ s/\.sdf$//;

      _SET_FILE_FITS_ITEM_ FILE=$outfile KEY=DATE-OBS VALUE=$dateobs
      _SET_FILE_FITS_ITEM_ FILE=$outfile KEY=DATE-END VALUE=$dateend

      push( @files, $outfile );
    }

    $ntile -= $numbad;

    orac_print " " . scalar( @files ) . " cube" . ( $ntile > 1 ? 's' : '' ) . " formed: ";

    $Grp->allow_header_sync( 1 );
    $Grp->product( "cube" );
    $Grp->files( @files );
    my $filestring = join ", ", @files;
    orac_print "$filestring\n";

  }

  # Tag as reduced, if requested.
  if( $tag ) {
    _TAG_AS_REDUCED_PRODUCT_ GROUP=1 UPDATE=1
  }

  $Grp->readhdr;

  $Display->display_data( $Grp ) if defined $Display;

}

# Tidy-up output.
orac_print "\n";
