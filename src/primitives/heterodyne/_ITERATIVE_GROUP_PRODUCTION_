# -*-perl-*-

=head1 NAME

_ITERATIVE_GROUP_PRODUCTION_ - Iteratively create group co-adds for
heterodyne data.

=head1 DESCRIPTION

This primitive creates a group co-added cube from all members of the
current group. It then baselines the cube and creates moments maps.

In the process of baselining the group cube, this primitive also
creates a baseline mask file, masking out emission. It then runs this
mask through UNMAKECUBE to create time-series masks. These masks are
applied to the original time-series data, which are then
baselined. The baselined time-series data are then run through
MAKECUBE to create individual baselined cubes for each
observation. Moments maps are then made from these cubes.

=head1 ARGUMENTS

=over 4

=item EDGES = INTEGER (Given)

Percentage of the full range to fit on either edge of the spectrum for
baselining purposes. If set to zero, then perform smoothing and
automatic baseline detection. [0]

=item FLATFIELD = BOOLEAN (Given)

Whether or not to flat-field the baselined time-series data. [0]

=item FREQUENCY_SMOOTH = INTEGER (Given)

The number of channels to smooth in the frequency axis when smoothing
to determine baselines. This number should be small (~10) for
narrow-line observations and large (~25) for broad-line
observations. [25]

=item ITERATIONS = INTEGER (Given)

The number of iterations to perform. [1]

=item MOMENTS = STRING (Given)

The moment maps to create. These are any of the values allowed for the
ESTIMATOR parameter to the COLLAPSE method, but in reality this should
probably be 'integ', 'iwc', and/or 'itd'. Any number of moments can be
given in a comma-separated string. ['integ']

=item METHOD = STRING (given)

Method to use to find emission in the data: 'clumpfind', 'fellwalker',
or 'thresh'. ['clumpfind']

=item RMS_THRESHOLD = REALS (Given)

The RMS threshold above which emission will be considered to be a
clump. A separate threshold can be specified for each moments map
requested. The last specified number will be applied to any further
moments requested. Typically 'integ' can tolerate a rms of 3-sigma,
but the higher order moments need a higher threshold. Comma-separated
string in the same order as the requested MOMENTS. [3.0,4.0]

=item ORDER = INTEGER (Given)

The polynomial order that will be used when estimating baselines. [1]

=item PARAM1 = REAL (Given)

The first parameter required by the spreading method. This parameter
is required by all methods, and specifies how many arcseconds on
either side of the output position are to receive contributions from
the input pixel. A value of zero indicates that a suitable number
should be calculated automatically. [0]

=item PARAM2 = REAL (Given)

The second parameter required by the spreading method, but only for
SombCos, Gauss, SincSinc, SincCos, and SincGauss schemes. For the
SombCos, SincSinc, and SincCos schemes, it specifies the number of
arcseconds at which the envelope of the function goes to zero. The
minimum value is 1.0, and the run-time default value is 2.0.  For the
Gauss and SincGauss scheme, it specifies the full-width at
half-maximum (FWHM) of the Gaussian envelope.  The minimum value is
0.1, and the run-time default is 1.0. []

=item PIXSIZE = REAL (Given)

The output pixel scale. If not defined, this value is automatically
determined from the data. []

=item QA = LOGICAL (Given)

Whether or not to perform quality assurance tests on output files. [1]

=item REBIN = STRING (Given)

A comma-separated list of requested rebinning resolutions, in km/s. A
rebinned cube will be created for each requested resolution. Only the
group cube will be rebinned. []

=item SPATIAL_SMOOTH = INTEGER (Given)

The number of pixels to smooth in both spatial axes when smoothing to
determine baselines. [3]

=item SPREAD = STRING (Given)

The method to use when spreading each input pixel value out between a
group of neighbouring output pixels when using MAKECUBE to generate a
cube. ['nearest']

=item TILEBORDER = INTEGER (Given)

The size of the border to be added to tiles. This is used when
smoothing the cube in spatial extend in later processing so as to not
add edge effects when merging tiles together. [0]

=back

=head1 NOTES

=over 4

This primitive is suitable for ACSIS data.

=back

=head1 OUTPUT DATA

=over 4

=back

=head1 TASKS

See _CREATE_CUBE_GROUP_, _REMOVE_BASELINE_THROUGH_SMOOTHING_,
_CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_, _RECREATE_MASKED_TIMESERIES_
_REMOVE_BASELINE_MASKED_TIMESERIES_, and
_CREATE_CUBE_FRAME_FROM_GROUP_.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities
Council.  All Rights Reserved.

=cut

# Handle arguments that get passed to later primitives.
my $edges = get_prim_arg( $_PRIM_ARGS_, "EDGES", 0 );
my $flatfield = get_prim_arg( $_PRIM_ARGS_, "FLATFIELD", 0 );
my $freqsmooth = get_prim_arg( $_PRIM_ARGS_, "FREQUENCY_SMOOTH", 25 );
my $iterations = get_prim_arg( $_PRIM_ARGS_, "ITERATIONS", 1 );
my $moments = get_prim_arg( $_PRIM_ARGS_, "MOMENTS", 'integ' );
my $method =  get_prim_arg( $_PRIM_ARGS_, "METHOD", 'clumpfind' );
my $rms_levels =  get_prim_arg( $_PRIM_ARGS_, "RMS_THRESHOLD", '3.0,4.0' );
my $order = get_prim_arg( $_PRIM_ARGS_, "ORDER", 1 );
my $pixsize = get_prim_arg( $_PRIM_ARGS_, "PIXSIZE", undef );
my $qa = get_prim_arg( $_PRIM_ARGS_, "QA", 1 );
my $rebin = get_prim_arg( $_PRIM_ARGS_, "REBIN", undef );
my $sp_param1 = get_prim_arg( $_PRIM_ARGS_, "PARAM1", 0 );
my $sp_param2 = get_prim_arg( $_PRIM_ARGS_, "PARAM2", undef );
my $spatsmooth = get_prim_arg( $_PRIM_ARGS_, "SPATIAL_SMOOTH", 3 );
my $spread = get_prim_arg( $_PRIM_ARGS_, "SPREAD", 'nearest' );
my $tileborder = get_prim_arg( $_PRIM_ARGS_, "TILEBORDER", 0 );

# Only process if we're on the last member of a group.
if( $Grp->lastallmembers( $Frm ) ) {

  my @good = $Grp->check_membership;
  if( ! @good ) {
    orac_warn "No good members in current group. Cannot do group processing.\n";
  } else {

    orac_print "Beginning iterative group production.\n";

    _MERGE_AST_REGIONS_

    my $iter = 1;
    while( $iter <= $iterations ) {

      orac_say "Iteration $iter of $iterations.\n";

      _CREATE_CUBE_GROUP_ SPREAD=$spread PARAM1=$sp_param1 PARAM2=$sp_param2 TILEBORDER=$tileborder PIXSIZE=$pixsize

      if( $edges ) {
        _REMOVE_BASELINE_ EDGES=$edges ORDER=$order GROUP=1 TAG=1
      } else {
        _REMOVE_BASELINE_THROUGH_SMOOTHING_ FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order GROUP=1 TAG=1
      }

      _CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_ GROUP=1 MOMENTS=$moments METHOD=$method RMS_THRESHOLD=$rms_levels FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order TAG=integ

      _CREATE_NOISE_MAP_ GROUP=1 QA=$qa

      if( defined( $rebin ) ) {
        foreach my $res ( split ",", $rebin ) {
          _REBIN_VELOCITY_SCALE_ GROUP=1 PIXELSCALE=$res
        }
      }

      _RECREATE_MASKED_OBS_FILES_ INTERP=$spread PARAM1=$sp_param1 PARAM2=$sp_param2 PIXSIZE=$pixsize TILEBORDER=$tileborder

      _REMOVE_BASELINE_MASKED_TIMESERIES_

      if( $flatfield ) {
        _REMOVE_FLAT_FIELD_ GROUP=2
      }

      _SET_TAG_ TAG=TIMESERIES_MASKED_BASELINED GROUP=2

      _CREATE_CUBE_FRAME_FROM_GROUP_ SPREAD=$spread PARAM1=$sp_param1 PARAM2=$sp_param2 TILEBORDER=$tileborder PIXSIZE=$pixsize

      _CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_ GROUP=2 MOMENTS=$moments METHOD=$method RMS_THRESHOLD=$rms_levels FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order TAG=integ

      _CREATE_NOISE_MAP_ GROUP=2 QA=$qa

      _RETRIEVE_TAG_ TAG=TIMESERIES_MASKED_BASELINED GROUP=2

      $iter++;
    }

    orac_say "Iterations completed. Creating final group files.\n";

    _CREATE_CUBE_GROUP_ SPREAD=$spread PARAM1=$sp_param1 PARAM2=$sp_param2 TILEBORDER=$tileborder PIXSIZE=$pixsize

    if( $edges ) {
      _REMOVE_BASELINE_ EDGES=$edges ORDER=$order GROUP=1 TAG=1
    } else {
      _REMOVE_BASELINE_THROUGH_SMOOTHING_ FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order GROUP=1 TAG=1
    }

    _CREATE_MOMENTS_MAPS_THROUGH_SMOOTHING_ GROUP=1 MOMENTS=$moments METHOD=$method RMS_THRESHOLD=$rms_levels FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order TAG=integ

    _CREATE_NOISE_MAP_ GROUP=1 QA=$qa

    if( defined( $rebin ) ) {
      foreach my $res ( split ",", $rebin ) {
        _REBIN_VELOCITY_SCALE_ GROUP=1 PIXELSCALE=$res
      }
    }

  }

}

# Tidy-up output.
orac_print "\n";


