# -*-perl-*-

=head1 NAME

_CREATE_CUBE_FRAME_ -- Create a cube from a time-series ACSIS
observation and stuff it in the Frm object.

=head1 DESCRIPTION

This primitive takes a time-series ACSIS cube and, using
SMURF/MAKECUBE, transforms it into a spatial/spectral cube.

=head1 ARGUMENTS

=over 4

=item BYTES_PER_PIXEL = INTEGER (Given)

The number of bytes per pixel. [4]

=item MAXSIZE = INTEGER (Given)

The maximum size, in bytes, of the output cube. This value does not
include extra information such as variance or weight arrays, FITS
headers, or any other NDF extensions. [512000000]

=item SPREAD = STRING (Given)

The interpolation method to use when regridding the cube. This can be
any of those allowed by MAKECUBE, listed in the SPREAD
parameter. ['nearest']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=back

=head1 OUTPUT DATA

=over 4

=item *

A cube whose filename is of the form aYYYYMMDD_NNNNN_SS_cube.sdf,
where YYYYMMDD is the UT date, NNNN is the zero-padded observation
number, and SS is the zero-padded susbystem number.

=back

=head1 TASKS

SMURF: MAKECUBE.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2006 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut

orac_print "Creating cube.\n";

# Deal with parameters.
my $maxsize = ( defined( $_CREATE_CUBE_FRAME_{MAXSIZE} ) ?
                $_CREATE_CUBE_FRAME_{MAXSIZE}            :
                512000000 );

my $bytes_per_pixel = ( defined( $_CREATE_CUBE_FRAME_{BYTES_PER_PIXEL} ) ?
                        $_CREATE_CUBE_FRAME_{BYTES_PER_PIXEL}            :
                        4 );

my $spread = ( defined( $_CREATE_CUBE_FRAME_{SPREAD} ) ?
               $_CREATE_CUBE_FRAME_{SPREAD}            :
               'nearest' );

my $out;
my @files;

# Create a list of input images.
my $inlist = new ORAC::TempFile( OPEN => 1,
                                 SUFFIX => '.lis' );
my $inlist_fh = $inlist->handle;

foreach my $i ( 1..$Frm->nfiles ) {

  my ( $in, $tmp ) = $Frm->inout( "_cube", $i );

  if( $i == 1 ) {
    $out = $tmp;
  }

  print $inlist_fh "$in\n";
  push @files, $in;
}

$inlist->handle->close;

# Fix the output filename to remove the subscan number.
$out =~ s/_\d{4}_/_/;

# First we need to run MAKECUBE without output to find out what the
# size of the output cube will be.
my $params = "in='^" . $inlist->file . "' out=! autogrid spread=$spread";

# If we have a raster (SAM_MODE header), then we need to set the pixel
# scale manually.
my $raster = ($Frm->hdr("SAM_MODE") =~ /raster/i);
if ($raster) {
  my $pixsize = $Frm->hdr( "SCAN_VEL" ) * $Frm->hdr( "STEPTIME" );
  $params .= " pixsize=$pixsize";
  my $crota = 90 - $Frm->hdr( "MAP_PA" );
  $params .= " crota=$crota";
}

# If we're doing a pointing and the INSTAP header is defined, pass
# that to MAKECUBE using the DETECTORS parameter.
my $pointing = ( uc( $Frm->hdr( "OBS_TYPE" ) ) eq 'POINTING' );
my $instap = ( defined( $Frm->hdr( "INSTAP" ) ) ?
               $Frm->hdr( "INSTAP" ) :
               '' );
if( $pointing && $instap ne '' ) {
  $params .= " detectors=$instap";
}
if( $pointing ) {
  $params .= " system=azel";
}

# If we have a lower sideband observation and have to restrict the
# frequency axis, then we'll need to tell makecube to flip around the
# upper and lower bounds.
my $lsb = ( $Frm->hdr("OBS_SB") =~ /lsb/i );

orac_print " Determining size of output cube...";

$Mon{'smurf_mon'}->obeyw( "makecube", "$params" );

# Check to see if we would have a sparse cube. If so, we don't have to
# go through this song and dance.
my ( $ORAC_STATUS, $sparse ) = $Mon{'smurf_mon'}->get( "makecube", "sparse" );
$Frm->uhdr( "SPARSE_CUBE", ( uc( $sparse ) eq 'TRUE' ) );

# Get output bounds, but only if we don't have a sparse cube.
if( ! $Frm->uhdr( "SPARSE_CUBE" ) ) {
  ( $ORAC_STATUS, my @lbnd ) = $Mon{'smurf_mon'}->get( "makecube", "lbound" );
  ( $ORAC_STATUS, my @ubnd ) = $Mon{'smurf_mon'}->get( "makecube", "ubound" );
  ( $ORAC_STATUS, my @flbnd ) = $Mon{'smurf_mon'}->get( "makecube", "flbnd" );
  ( $ORAC_STATUS, my @fubnd ) = $Mon{'smurf_mon'}->get( "makecube", "fubnd" );

# And grid parameters to speed up next call
  ($ORAC_STATUS, my @pixsize ) = $Mon{'smurf_mon'}->get( "makecube", 'pixsize' );
  ($ORAC_STATUS, my $crota )   = $Mon{'smurf_mon'}->get( "makecube", 'crota' );

  orac_print "done.\n";

  my $x_length = abs( $ubnd[0] - $lbnd[0] + 1 );
  my $y_length = abs( $ubnd[1] - $lbnd[1] + 1 );
  my $f_length = abs( $ubnd[2] - $lbnd[2] + 1 );
  my $f_range = abs( $fubnd[2] - $flbnd[2] );

# Calculate the maximum number of available frequency channels.
  my $max_freq_chan = int( $maxsize / ( $x_length * $y_length * $bytes_per_pixel ) );

# If the maximum number of available frequency channels is less than
# the number in the output cube, then we need to tell MAKECUBE to
# restrict the frequency bounds.
  if( $max_freq_chan < $f_length ) {

    my $ratio = $max_freq_chan / $f_length;

  # We need to remove ( 1 - $ratio ) * $f_range / 2 from each end.
    my $upper = $fubnd[2] - ( 1 - $ratio ) * $f_range / 2;
    my $lower = $flbnd[2] + ( 1 - $ratio ) * $f_range / 2;

  # Get the units of the frequency axis.
    $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$files[0] fullframe" );
    ( $ORAC_STATUS, my $funit ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "funit" );

  # Tell the user what's going on.
    orac_print " Running MAKECUBE to create full cube would result in a file too large\n  for this computer to handle.\n";
    orac_print " Frequency range would have been ";
    orac_print sprintf( "%.3f to %.3f %s.\n", $flbnd[2], $fubnd[2], $funit );
    orac_print " Restricting frequency range to ";
    orac_print sprintf( "%.3f to %.3f %s.\n", $lower, $upper, $funit );

  # If it's LSB, swap them around.
    if( $lsb ) {
      ( $upper, $lower ) = ( $lower, $upper );
    }

    $params = "specbounds='$lower,$upper' ";

  } else {

    $params = "";

  }

# Set up the parameters to MAKECUBE. (use hints from previous call)
# Autogrid is required because without it the pixel grid is not positioned
# in an optimal way. (and the fractional pixel shift is not stored in an output
# parameter at present).
  $params .= "in='^" . $inlist->file . "' out=$out autogrid crota=$crota spread=$spread";

  if (@pixsize > 1) {
    $params .= " pixsize=[".join(",",@pixsize) ."] ";
  } else {
    $params .= " pixsize=$pixsize[0] ";
  }

# If the data units are Kelvin, then we can generate a variance from
# TSYS. Otherwise, we can generate a variance from the spread of the
# input data values contributing to each output pixel.
  $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$files[0] fullframe" );
  ( $ORAC_STATUS, my $units ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "units" );
  if( $units eq 'K' ) {
    $params .= " genvar=tsys inweight=true";
  } else {
    $params .= " genvar=spread inweight=false";
  }

} else {

  # We have a sparse cube, so set up the parameters differently.
  $params = "in='^" . $inlist->file . "' out=$out autogrid spread=$spread";

  # Send a warning.
  orac_warn "Sparse cube will be created in $out.\n";

}

if( $pointing && $instap ne '' ) {
  $params .= " detectors=$instap";
}

if( $pointing ) {
  $params .= " system=azel";
}

# Tell user what we're doing.
orac_print( " Creating cube from " . join( ", ", @files ) . "..." );

# Run MAKECUBE.
$Mon{'smurf_mon'}->obeyw( "makecube", "$params" );

orac_print( "done.\nCube formed in $out.\n" );

# Update the Frm object.
$Frm->files( $out );

# Display.
$Display->display_data( $Frm ) if defined $Display;

# Tidy-up output.
orac_print "\n";

