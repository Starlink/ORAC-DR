# -*-perl-*-

=head1 NAME

_CREATE_CUBE_FRAME_ -- Create a cube from a time-series ACSIS
observation and stuff it in the Frm object.

=head1 DESCRIPTION

This primitive takes a time-series ACSIS cube and, using
SMURF/MAKECUBE, transforms it into a spatial/spectral cube.

=head1 ARGUMENTS

=over 4

=item BYTES_PER_PIXEL = INTEGER (Given)

The number of bytes per pixel. [4]

=item MAXSIZE = INTEGER (Given)

The maximum size, in bytes, of the output cube. This value does not
include extra information such as variance or weight arrays, FITS
headers, or any other NDF extensions. [512000000]

=item PARAMS = STRING (Given)

An optional array which consists of additional parameters required by
the Sinc, SincSinc, SincCos, SincGauss, Somb, SombCos, and Gauss
spreading methods (see parameter SPREAD). See documentation for the
PARAMS parameter for MAKECUBE. ['']

=item SPREAD = STRING (Given)

The interpolation method to use when regridding the cube. This can be
any of those allowed by MAKECUBE, listed in the SPREAD
parameter. ['nearest']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS.

=back

=head1 OUTPUT DATA

=over 4

=item *

A cube whose filename is of the form aYYYYMMDD_NNNNN_SS_cube.sdf,
where YYYYMMDD is the UT date, NNNN is the zero-padded observation
number, and SS is the zero-padded susbystem number.

=back

=head1 TASKS

SMURF: MAKECUBE.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2006 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut

orac_print "Creating cube.\n";

# Deal with parameters.
my $maxsize = ( defined( $_CREATE_CUBE_FRAME_{MAXSIZE} ) ?
                $_CREATE_CUBE_FRAME_{MAXSIZE}            :
                512000000 );

my $bytes_per_pixel = ( defined( $_CREATE_CUBE_FRAME_{BYTES_PER_PIXEL} ) ?
                        $_CREATE_CUBE_FRAME_{BYTES_PER_PIXEL}            :
                        4 );

my $spread = ( defined( $_CREATE_CUBE_FRAME_{SPREAD} ) ?
               $_CREATE_CUBE_FRAME_{SPREAD}            :
               'nearest' );

my $makecube_params = ( defined( $_CREATE_CUBE_FRAME_{PARAMS} ) ?
                        $_CREATE_CUBE_FRAME_{PARAMS}            :
                        '' );

my @files;

# Create a list of input images.
my $inlist = new ORAC::TempFile( OPEN => 1,
                                 SUFFIX => '.lis' );
my $inlist_fh = $inlist->handle;

my $out = $Frm->inout( "_cube" );

foreach my $i ( 1..$Frm->nfiles ) {

  my ( $in, $tmp ) = $Frm->inout( "_cube", $i );

  print $inlist_fh "$in\n";
  push @files, $in;
}

$inlist->handle->close;

# Fix the output filename to remove the subscan number.
$out =~ s/_\d{4}_/_/;

# If we have either a HARP4 or a HARP5 jiggle, we need to hardwire the
# spread to SINCSINC and the params to [2,2]. Setting the pixel scale
# will come later.
my $jiggle_name = "";
if( defined( $Frm->hdr( "JIGL_NAM" ) ) ) {
  $jiggle_name = $Frm->hdr( "JIGL_NAM" );
  if( $jiggle_name =~ /harp[45]/i ) {
    $spread = "SINCSINC";
    $makecube_params = "[2,2]";
  }
}

# First we need to run MAKECUBE without output to find out what the
# size of the output cube will be.
my $params = "in='^" . $inlist->file . "' out=! autogrid spread=$spread";

if( uc( $spread ) ne 'NEAREST' ) {
  $params .= " params=$makecube_params";
}

# If we have either a HARP4 or a HARP5 jiggle, we need to set the
# pixel scale to 7.5 or 6 arcseconds, respectively.
if( $jiggle_name =~ /harp([45])/i ) {
  my $pixsize = ( $1 == 4 ? 7.5 : 6 );
  $params .= " pixsize=$pixsize";
}

# If we have a raster (SAM_MODE header), then we need to set the pixel
# scale manually.
my $raster = ($Frm->hdr("SAM_MODE") =~ /raster/i);
if ($raster) {
  my $pixsize = $Frm->hdr( "SCAN_VEL" ) * $Frm->hdr( "STEPTIME" );
  $params .= " pixsize=$pixsize";
  my $crota = 90 - $Frm->hdr( "MAP_PA" );

  # Ensure that CROTA lies between -45 and 45.
  while ( $crota < -45 || $crota > 45 ) {
    if( $crota < -45 ) {
      $crota += 90;
    } elsif( $crota > 45 ) {
      $crota -= 90;
    }
  }
  $params .= " crota=$crota";
  if( $Frm->hdr( "LOCL_CRD" ) eq 'AZEL' ) {
    $params .= " system=azel";
  }
}

# If we're doing a pointing and the INSTAP header is defined, pass
# that to MAKECUBE using the DETECTORS parameter.
my $pointing = ( uc( $Frm->hdr( "OBS_TYPE" ) ) eq 'POINTING' );
my $instap = ( defined( $Frm->hdr( "INSTAP" ) ) ?
               $Frm->hdr( "INSTAP" ) :
               '' );
if( $pointing && $instap ne '' ) {
  $params .= " detectors=$instap";
}
if( $pointing ) {
  $params .= " system=azel";
}

# If we have a lower sideband observation and have to restrict the
# frequency axis, then we'll need to tell makecube to flip around the
# upper and lower bounds.
my $lsb = ( $Frm->hdr("OBS_SB") =~ /lsb/i );

orac_print " Determining size of output cube...";

$Mon{'smurf_mon'}->obeyw( "makecube", "$params" );

# Check to see if we would have a sparse cube. If so, we don't have to
# go through this song and dance.
my ( $ORAC_STATUS, $sparse ) = $Mon{'smurf_mon'}->get( "makecube", "sparse" );
$Frm->uhdr( "SPARSE_CUBE", ( uc( $sparse ) eq 'TRUE' ) );

# Get output bounds, but only if we don't have a sparse cube.
if( ! $Frm->uhdr( "SPARSE_CUBE" ) ) {
  ( $ORAC_STATUS, my @lbnd ) = $Mon{'smurf_mon'}->get( "makecube", "lbound" );
  ( $ORAC_STATUS, my @ubnd ) = $Mon{'smurf_mon'}->get( "makecube", "ubound" );
  ( $ORAC_STATUS, my @flbnd ) = $Mon{'smurf_mon'}->get( "makecube", "flbnd" );
  ( $ORAC_STATUS, my @fubnd ) = $Mon{'smurf_mon'}->get( "makecube", "fubnd" );

# And grid parameters to speed up next call
  ($ORAC_STATUS, my @pixsize ) = $Mon{'smurf_mon'}->get( "makecube", 'pixsize' );
  ($ORAC_STATUS, my $crota )   = $Mon{'smurf_mon'}->get( "makecube", 'crota' );

  orac_print "done.\n";

  my $x_length = abs( $ubnd[0] - $lbnd[0] + 1 );
  my $y_length = abs( $ubnd[1] - $lbnd[1] + 1 );
  my $f_length = abs( $ubnd[2] - $lbnd[2] + 1 );
  my $f_range = abs( $fubnd[2] - $flbnd[2] );

  my $total_pixels = $x_length * $y_length * $f_length;
  my $total_bytes = $total_pixels * $bytes_per_pixel;
  orac_print " Total size of output cube: $total_pixels pixels ($total_bytes bytes)\n";
  orac_print " This computer can handle $maxsize bytes.\n";

  if( $maxsize < $total_bytes ) {
    my $ntiles = int( $total_bytes / $maxsize ) + 1;
    orac_print " Output cube will be split into $ntiles tiles.\n";

    # We'll tile along the long axis.
    my $x_out; # Length of the x-axis for each tile.
    my $y_out; # Length of the y-axis for each tile.
    if( $x_length > $y_length ) {
      $x_out = int ( $x_length / $ntiles ) + 1;
      $y_out = $y_length;
    } else {
      $x_out = $x_length;
      $y_out = int( $y_length / $ntiles ) + 1;
    }

    $params = "tiledims=[$x_out,$y_out] ";
    orac_print " Output cubes will have dimensions [$x_out,$y_out,$f_length]\n";

    $Frm->uhdr( "SPECTRAL_TRIMMED", 0 );
    $Frm->uhdr( "TILED_CUBE", 1 );

  } else {

    $Frm->uhdr( "SPECTRAL_TRIMMED", 0 );
    $Frm->uhdr( "TILED_CUBE", 0 );

    $params = "tiledims=! ";

  }

# Make sure CROTA is between -45 and 45.
  while ( $crota < -45 || $crota > 45 ) {
    if( $crota < -45 ) {
      $crota += 90;
    } elsif( $crota > 45 ) {
      $crota -= 90;
    }
  }

# Set up the parameters to MAKECUBE. (use hints from previous call)
# Autogrid is required because without it the pixel grid is not positioned
# in an optimal way. (and the fractional pixel shift is not stored in an output
# parameter at present).
  $params .= "in='^" . $inlist->file . "' out=$out autogrid crota=$crota spread=$spread";

  if (@pixsize > 1) {
    $params .= " pixsize=[".join(",",@pixsize) ."] ";
  } else {
    $params .= " pixsize=$pixsize[0] ";
  }

# If the data units are Kelvin, then we can generate a variance from
# TSYS. Otherwise, we can generate a variance from the spread of the
# input data values contributing to each output pixel.
  $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$files[0] fullframe" );
  ( $ORAC_STATUS, my $units ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "units" );
  if( $units eq 'K' ) {
    $params .= " genvar=tsys inweight=true";
  } else {
    $params .= " genvar=spread inweight=false";
  }

} else {

  # We have a sparse cube, so set up the parameters differently.
  $params = "in='^" . $inlist->file . "' out=$out autogrid spread=$spread";

  # Send a warning.
  orac_warn "Sparse cube will be created in $out.\n";

}

if( $pointing && $instap ne '' ) {
  $params .= " detectors=$instap";
}

if( $pointing ) {
  $params .= " system=azel";
}

if( uc( $spread ) ne 'NEAREST' ) {
  $params .= " params=$makecube_params";
}

# If it's a raster and the LOCL_CRD header is AZEL, set the system to
# azel.
if( $raster && $Frm->hdr( "LOCL_CRD" ) eq 'AZEL' ) {
  $params .= " system=azel";
}

# Tell user what we're doing.
orac_print( " Creating cube from " . join( ", ", @files ) . "..." );

# Run MAKECUBE.
$Mon{'smurf_mon'}->obeyw( "makecube", "$params" );

orac_print( "done.\n" );

# Retrieve the number of tiles created.
( $ORAC_STATUS, my $ntile ) = $Mon{'smurf_mon'}->get( "makecube", "ntile" );

if( $Frm->uhdr( "TILED_CUBE" ) ) {

  # We need to rename the output cubes, as MAKECUBE creates _cube_N
  # and we want _cubeNNN.
  my @files;
  foreach my $j ( 1 .. $ntile ) {
    my $makecube_outfile = "${out}_$j.sdf";
    my $outfile = "${out}" . sprintf( "%03d", $j ) . ".sdf";
    rename( $makecube_outfile, $outfile );
    $outfile =~ s/\.sdf$//;
    push( @files, $outfile );
  }

  orac_print " $ntile cubes formed: ";

  $Frm->files( @files );
  my $filestring = join ", ", @files;
  orac_print( "$filestring\n" );
} else {
  $Frm->files( $out );
  orac_print( "Cube formed in $out.\n" );
}

# Set the product.
$Frm->product( "CUBE" );

# Display.
$Display->display_data( $Frm ) if defined $Display;

# Tidy-up output.
orac_print "\n";

