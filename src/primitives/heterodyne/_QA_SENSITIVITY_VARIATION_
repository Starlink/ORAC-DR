# -*-perl-*-

=head1 NAME

_QA_SENSITIVITY_VARIATION_

=head1 DESCRIPTION

This primitive tests raw ACSIS time-series data for variation in the
RMS of the data. It first finds the mean RMS for the entire
observation, then calculates the RMS for each receptor after masking
out emission lines. These values are then printed and stored for later
use.

=head1 ARGUMENTS

=item METHOD = STRING (Given)

How to detect and mask out emission so as to not confuse matters when
the RMS is determined. 'NARROW' tells the primitive to mask out the
central 10% of the bandpass. 'STANDARD' tells the primitive to mask
out the central 25% of the bandpass. 'WIDE' tells the primitive to
mask out the central 50% of the bandpass. 'AUTO' tells the pipeline to
use MFITTREND to attempt to automatically find emission and mask that
out. ['AUTO']

=head1 OUTPUT DATA

=over 4

=item *

Files with emission lines masked out are created with the suffix _rms.

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS time-series data.

=item *

If the observed object is located in the JCMT Pointing Catalogue, then
the line velocity and width is used to mask out the emission
line.

=item *

The masked file names are stored in the QA_MASKED_FILES uhdr as an
array reference.

=item *

The receptor RMS values are stored in the QA_RMS_VALUES uhdr as a hash
reference, with the key being the OBSIDSS value and the value being a
further hash reference, where keys are the receptor name and values
are the corresponding RMS.

=back

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2008-2009 Science and Technology Facilities Council. All
Rights Reserved.

=cut

use JCMT::ACSIS::Array;
use ORAC::Constants qw/ :badvalues /;

# Handle parameters.
my $method = uc( get_prim_arg( $_PRIM_ARGS_, "METHOD", "AUTO" ) );

my @rms_files;
my %rms;
my %receptor_rms;
my %numgood;

my $key = $Frm->uhdr( "ORAC_OBSERVATION_ID" ) . "_" . $Frm->hdr( $Frm->uhdr( "ORAC_SUBSYSTEM_IDKEY" ) );

my $array_rms = 0;

foreach my $i ( 1 .. $Frm->nfiles ) {

  my ( $infile, $outfile ) = $Frm->inout( "_rms", $i );

  orac_print "Calculating RMS values for $infile.\n";

  my $temp1 = new ORAC::TempFile;
  my $temp2 = new ORAC::TempFile;
  my $temp3 = new ORAC::TempFile;

  # Retrieve the JCMT pointing catalogue and look up the current
  # object. If it is defined, then we use the line velocity and width
  # to mask out the line, then use the remaining (hopefully line-free)
  # regions to determine the RMS. If the object isn't defined, then
  # we'll fit a linear baseline and use the masking from MFITTREND to
  # mask out lines.
  use Astro::Catalog;
  my $object = $Frm->uhdr( "ORAC_OBJECT" );
  my $poicat = $Cal->find_file( "poi.dat" );
  my $jcmtcat = new Astro::Catalog( Format => 'JCMT',
                                    File => $poicat );
  my ( $result ) = $jcmtcat->popstarbyid( $object );
  if( defined( $result ) &&
      defined( $result->misc ) &&
      defined( $result->misc->{'velocity_range'} ) ) {

    my $range = $result->misc->{'velocity_range'};
    my $centre = $result->coords->rv;

    my $params = "in=$infile out=$temp1 section='$centre~$range,,' newval=bad";
    $Mon{'kappa_mon'}->obeyw( "chpix", "$params" );

  } else {
    $temp1 = $infile;
  }

  if( $method eq 'AUTO' ) {

    # Find dimensions.
    _GET_DIMENSIONS_
    my @lbnd = @{$_GET_DIMENSIONS_{LBOUND}};
    my @ubnd = @{$_GET_DIMENSIONS_{UBOUND}};

    # Fit and subtract a background from the spectrum.
    my $params = "in=$temp1 out=$temp2 mask=$temp3 order=1 subtract=true";
    $params .= " modifyin=false rmsclip=! axis=spec auto=true method=single";
    $params .= " numbin=" . ( int( ( $ubnd[0] - $lbnd[0] + 1 ) / 4 ) );
    $Mon{'kappa_mon'}->obeyw( "mfittrend", "$params" );

    # Mask out the baselined file.
    $Mon{'kappa_mon'}->obeyw( "add", "in1=$temp2 in2=$temp3 out=$outfile" );

  } else {

    my $centmask = 25;
    if( $method eq 'NARROW' ) {
      $centmask = 10;
    } elsif( $method eq 'WIDE' ) {
      $centmask = 50;
    }

    # Mask out the requested central portion.
    my $params = "in=$temp1 out=$outfile section='~$centmask\%,,' newval=bad";
    $Mon{'kappa_mon'}->obeyw( "chpix", "$params" );

  }

  # Get stats for the central 85% across all detectors.
  $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outfile(~85\%,,) clip=[3]" );
  my ( $ORAC_STATUS, $rmsmean ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

  if( $rmsmean != VAL__BADD ) {
    $array_rms += $rmsmean;
  }

  # Get stats for each receptor.
  my $array = new JCMT::ACSIS::Array( File => $infile );

  foreach my $receptor ( sort $array->receptors ) {

    my $pixel = $array->pixel( $receptor );
    $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outfile(~85\%,$pixel,) clip=[3]" );
    ( $ORAC_STATUS, my $pixrms ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

    if( ! defined( $receptor_rms{$receptor} ) ) {
      $receptor_rms{$receptor} = 0;
      $numgood{$receptor} = 0;
    }
    if( $pixrms > 0 && $pixrms != VAL__BADD ) {
      $receptor_rms{$receptor} += $pixrms;
      $numgood{$receptor}++;
    }
  }

  # Store the name of the RMS file. We can't update the frame
  # object because we want to continue on doing stats on the original
  # file. Add it to the intermediates list so we can clean it up later.
  $rms_files[$i] = $outfile;
  $Frm->push_intermediates( $outfile );

}

$array_rms /= $Frm->nfiles;
foreach my $receptor ( keys %receptor_rms ) {
  if( $receptor_rms{$receptor} != 0 ) {
    $receptor_rms{$receptor} /= $Frm->nfiles;
  } else {
    $receptor_rms{$receptor} = 'bad';
  }
}

if( $array_rms != 0 ) {
  orac_say sprintf( " RMS for entire array:   %7.2f K", $array_rms );
} else {
  orac_say " RMS for entire array: n/a (all values bad)";
}

_PRETTYPRINT_RECEPTOR_QA_ HASH=\%receptor_rms TYPE=RMS

$rms{$key} = \%receptor_rms;

# Store the hash of RMS hashes.
$Frm->uhdr( "QA_RMS_VALUES", \%rms );

# Store the array of masked files.
$Frm->uhdr( "QA_RMS_FILES", \@rms_files );

# Tidy-up output.
orac_print "\n";
