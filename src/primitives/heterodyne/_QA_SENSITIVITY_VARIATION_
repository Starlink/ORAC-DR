# -*-perl-*-

=head1 NAME

_QA_SENSITIVITY_VARIATION_

=head1 DESCRIPTION

This primitive tests raw ACSIS time-series data for variation in the
RMS of the data. It first finds the mean RMS for the entire
observation, then calculates the RMS for each receptor after masking
out emission lines. These values are then printed and stored for later
use.

=head1 ARGUMENTS

None.

=head1 OUTPUT DATA

=over 4

=item *

Files with emission lines masked out are created with the suffix _msk.

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS time-series data.

=item *

If the observed object is located in the JCMT Pointing Catalogue, then
the line velocity and width is used to mask out the emission
line. Otherwise, a linear baseline is fit to the data, and any values
clipped by successive 2-, 2-, 2.5-, and 3-sigma clipping levels are
masked.

=item *

The masked file names are stored in the QA_MASKED_FILES uhdr as an
array reference.

=item *

The receptor RMS values are stored in the QA_RMS_VALUES uhdr as a hash
reference, with the key being the OBSIDSS value and the value being a
further hash reference, where keys are the receptor name and values
are the corresponding RMS.

=back

=head1 AUTHORS

Brad Cavanagh <b.cavanagh@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 2008-2009 Science and Technology Facilities Council. All
Rights Reserved.

=cut

use JCMT::ACSIS::Array;
use NDF;

my @masked_files;
my %rms;
my %receptor_rms;

my $key = $Frm->uhdr( "ORAC_OBSERVATION_ID" ) . "_" . $Frm->uhdr( "ORAC_SUBSYSTEM_IDKEY" );

my $array_rms = 0;

foreach my $i ( 1 .. $Frm->nfiles ) {

  my ( $infile, $outfile ) = $Frm->inout( "_msk", $i );

  orac_print "Calculating RMS values for $infile.\n";

  my $temp1 = new ORAC::TempFile;
  my $temp2 = new ORAC::TempFile;
  my $temp3 = new ORAC::TempFile;

  # Retrieve the JCMT pointing catalogue and look up the current
  # object. If it is defined, then we use the line velocity and width
  # to mask out the line, then use the remaining (hopefully line-free)
  # regions to determine the RMS. If the object isn't defined, then
  # we'll fit a linear baseline and use the masking from MFITTREND to
  # mask out lines.
  use Astro::Catalog;
  my $object = $Frm->uhdr( "ORAC_OBJECT" );
  my $poicat = $Cal->find_file( "poi.dat" );
  my $jcmtcat = new Astro::Catalog( Format => 'JCMT',
                                    File => $poicat );
  my ( $result ) = $jcmtcat->popstarbyid( $object );
  if( defined( $result ) &&
      defined( $result->misc ) &&
      defined( $result->misc->{'velocity_range'} ) ) {

    my $range = $result->misc->{'velocity_range'};
    my $centre = $result->coords->rv;

    my $params = "in=$infile out=$temp1 section='$centre~$range,,' newval=bad";
    $Mon{'kappa_mon'}->obeyw( "chpix", "$params" );

  } else {
    $temp1 = $infile;
  }

  # Find dimensions.
  _GET_DIMENSIONS_
  my @lbnd = @{$_GET_DIMENSIONS_{LBOUND}};
  my @ubnd = @{$_GET_DIMENSIONS_{UBOUND}};

  # Fit a background to the spectrum.
  my $params = "in=$temp1 out=$temp2 mask=$temp3 order=1 subtract=true";
  $params .= " modifyin=false rmsclip=! axis=spec auto=true method=single";
  $params .= " numbin=" . ( int( ( $ubnd[0] - $lbnd[0] + 1 ) / 8 ) );
  $Mon{'kappa_mon'}->obeyw( "mfittrend", "$params" );

  # Mask out the baselined file.
  $Mon{'kappa_mon'}->obeyw( "add", "in1=$temp2 in2=$temp3 out=$outfile" );

  # Find the extent along the first axis (which for CALs is the
  # frequency axis)
  my $extent = $ubnd[0] - $lbnd[0];

  # Only use the central 85%. This avoids noisy ends.
  $extent = int( $extent * 0.85 );

  # Get stats for this extent across all detectors.
  $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outfile(~$extent,,)" );
  my ( $ORAC_STATUS, $rmsmean ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

  if( $rmsmean != &NDF::VAL__BADD ) {
    $array_rms += $rmsmean;
  }

  # Get stats for each receptor.
  my $array = new JCMT::ACSIS::Array( File => $infile );

  foreach my $receptor ( sort $array->receptors ) {

    my $pixel = $array->pixel( $receptor );
    $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outfile(~$extent,$pixel,)" );
    ( $ORAC_STATUS, my $pixrms ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

    if( $pixrms > 0 && $pixrms != &NDF::VAL__BADD ) {
      $receptor_rms{$receptor} += $pixrms;
    } else {
      $receptor_rms{$receptor} = "bad";
    }

  }

  # Store the name of the masked file. We can't update the frame
  # object because we want to continue on doing stats on the original
  # file.
  $masked_files[$i] = $outfile;

}

$array_rms /= $Frm->nfiles;
foreach my $receptor ( keys %receptor_rms ) {
  if( $receptor_rms{$receptor} ne 'bad' ) {
    $receptor_rms{$receptor} /= $Frm->nfiles;
  }
}

if( $array_rms != 0 ) {
  orac_say sprintf( " RMS for entire array:   %7.2f K", $array_rms );
} else {
  orac_say " RMS for entire array: n/a (all values bad)";
}

_PRETTYPRINT_RECEPTOR_QA_ HASH=\%receptor_rms TYPE=RMS

$rms{$key} = \%receptor_rms;

# Store the hash of RMS hashes.
$Frm->uhdr( "QA_RMS_VALUES", \%rms );

# Store the array of masked files.
$Frm->uhdr( "QA_MASKED_FILES", \@masked_files );

# Tidy-up output.
orac_print "\n";
