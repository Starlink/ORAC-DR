# -*-perl-*-

=head1 NAME

_QA_RMS_TSYS_CONSISTENCY_ - Compare Tsys-calculated RMS values with
measured RMS values and optionally mask out those that fail to meet a
given threshold.

=head1 DESCRIPTION

This primitive compares RMS values calculated from the Tsys with those
measured from the data. Each spectrum has two RMS values calculated
for it, and if these values differ by more than a given amount, then
the spectrum fails the test. If a given percentage of spectra out of
the entire observation fail the test, then the observation is flagged
as either questionable or bad.

Failed spectra can be optionally masked.

=head1 ARGUMENTS

=over 4

=item MASK = STRING (Given)

The name of the survey to use when masking spectra. The special
"telescope" survey can be used to mask spectra failing the
less-stringent telescope thresholds. If left undefined, then no
spectra will be masked. ['']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS data.

=back

=head1 OUTPUT DATA

=over 4

=item *

If masking is done (see MASK argument), then the masked timeseries
data with suffix _tsmsk.

=back

=head1 TASKS

KAPPA: COLLAPSE, COPYBAD, DIV, MANIC, NDFCOPY, NUMB, POW, THRESH.

=head1 REQUIRED PERL MODULES

JCMT::ACSIS::Array, JSA::QA, Starlink::HDSPACK.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

# Determine if we're supposed to use this as a mask for a survey.
my $mask = get_prim_arg( $_PRIM_ARGS_, "MASK", undef );
my $survey = get_prim_arg( $_PRIM_ARGS_, "SURVEY", undef );

my @surveys = qw/ GBS NGS SLS Telescope /;

use Starlink::HDSPACK qw/ create_hdsobj copy_hdsobj /;
use JSA::QA;

my $masked_files = $Frm->uhdr( "QA_MASKED_FILES" );

foreach my $i ( 1 .. scalar( @$masked_files ) - 1 ) {

  my ( $infile, $outfile ) = $Frm->inout( "_tsmsk", $i );
  my $masked_file = $masked_files->[$i];

  my $temp1file = new ORAC::TempFile;
  my $temp2file = new ORAC::TempFile;
  my $temp3file = new ORAC::TempFile;
  my $temp4file = new ORAC::TempFile;
  my $temp5file = new ORAC::TempFile;

  # Make sure this file has a VARIANCE component.
  _COMPONENT_EXISTS_ FILE=$infile COMPONENT=VARIANCE
  my $exists = $_COMPONENT_EXISTS_{EXISTS};
  if( ! $exists ) {
    orac_throw "Cannot perform Tsys/RMS consistency checks on a file that has no VARIANCE component\n";
  }

  # We need to collapse down the masked file around the central 85%.
  _GET_DIMENSIONS_
  my $lbnd = $_GET_DIMENSIONS_{LBOUND};
  my $ubnd = $_GET_DIMENSIONS_{UBOUND};
  my $extent = int( ( $ubnd->[0] - $lbnd->[0] ) * 0.85 );

  # Collapse it using the sigma estimator to get the standard
  # deviation.
  my $params = "in=$masked_file(~$extent,,) out=$temp1file estimator=sigma axis=spec trim=true wlim=0.0 variance=false";
  $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

  # Now copy a frequency slice out of the input file. It doesn't
  # matter where, since we're interested in the variance component and
  # that doesn't vary with frequency.
  $params = "in=$infile(~1,,) out=$temp2file trim=true";
  $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "$params" );

  # Create an HDS object into which we can copy the variance array.
  my $ORAC_STATUS = ( create_hdsobj( $temp3file, 'NDF', [0] ) ? ORAC__OK : ORAC__ERROR );
  $ORAC_STATUS = ( copy_hdsobj( "$temp2file.VARIANCE", "$temp3file.DATA_ARRAY" ) ? ORAC__OK : ORAC__ERROR );

  # Square-root it.
  $params = "in=$temp3file out=$temp4file power=0.5";
  $Mon{'kappa_mon'}->obeyw( "pow", "$params" );

  # At this point, if we're doing an RxA sample the temp4file could be
  # 1D, so turn it into 2D.
  _GET_DIMENSIONS_ FILE=$temp4file
  my $temp4dims = $_GET_DIMENSIONS_{DIMS};
  if( scalar( @{$temp4dims} ) == 1 ) {

    my $temp6file = new ORAC::TempFile;
    $params = "in=$temp4file out=$temp6file axes=[0,1] lbound=1 ubound=1";
    $Mon{'kappa_mon'}->obeyw( "manic", "$params" );

    $temp4file = $temp6file;
  }

  # Divide the measured RMS by the calculated RMS.
  $params = "in1=$temp1file in2=$temp4file out=$temp5file";
  $Mon{'kappa_mon'}->obeyw( "div", "$params" );

  # Retrieve the QA parameters file and set up a new JSA::QA object.
  my $qaparamfile = $Cal->qaparams;
  my $qa = new JSA::QA( file => $qaparamfile );

  # Set up a hash of options to pass to the QA object.
  _SETUP_QA_OPTIONS_
  my $opts = $_SETUP_QA_OPTIONS_{'OPTS'};
  my %opts = %$opts;

  # Set up a list of surveys to analyse.
  my @analyse_surveys;
  if( defined( $survey ) ) {
    if( uc( $survey ) eq 'ALL' ) {
      @analyse_surveys = @surveys;
    } else {
      push @analyse_surveys, $survey;
    }
  } else {
    push @analyse_surveys, ( defined( $Frm->hdr( "SURVEY" ) ) ?
                             $Frm->hdr( "SURVEY" )            :
                             "Telescope" );
  }

  # Run QA analysis on each requested survey.
  foreach my $analyse_survey ( @analyse_surveys ) {

    $opts{'survey'} = $analyse_survey;

    # Retrieve the constant(s) for the difference tolerance and the
    # questionable/bad limits.
    my $rmstol_const      = 'RMSTSYSTOL';
    my $rmstolquest_const = 'RMSTSYSTOL_QUEST';
    my $rmstolfail_const  = 'RMSTSYSTOL_FAIL';
    my $rmstol = $qa->get_data( key => $rmstol_const, %opts );
    my $rmstolquest = $qa->get_data( key => $rmstolquest_const, %opts );
    my $rmstolfail = $qa->get_data( key => $rmstolfail_const, %opts );

    my $tol = $rmstol + 1;
    $params = "in=$temp5file value=$tol above";
    $Mon{'kappa_mon'}->obeyw( "numb", "$params" );
    ( $ORAC_STATUS, my $numb_above ) = $Mon{'kappa_mon'}->get( "numb", "number" );

    # Find out how many pixels are below the tolerance to get a ratio.
    $params = "in=$temp5file value=$tol noabove";
    $Mon{'kappa_mon'}->obeyw( "numb", "$params" );
    ( $ORAC_STATUS, my $numb_below ) = $Mon{'kappa_mon'}->get( "numb", "number" );

    # Figure out if this is a pass, a questionable, or a fail.
    my $percent = $numb_above / ( $numb_above + $numb_below );

    orac_print "Tsys versus RMS consistency check ";

    if( $percent > $rmstolfail ) {
      orac_print( " failed ", "bold white on_red" );
    } elsif( $percent > $rmstolquest ) {
      orac_print( " is questionable ", "bold black on_yellow" );
    } else {
      orac_print( " passed ", "bold white on_green" );
    }

    orac_print " for $analyse_survey for $infile.\n";

    orac_print sprintf( " %.2f%% of the samples had a calculated RMS that differed by more than %d%% from the measured RMS.\n", $percent * 100, $rmstol * 100 );

    # Mask out the bad pixels, if requested.
    if( defined( $mask ) && ( uc( $analyse_survey ) eq $mask ) ) {

      my $temp6file = new ORAC::TempFile;
      my $temp7file = new ORAC::TempFile;
      $params = "in=$temp5file out=$temp6file thrlo=-100000 newlo=bad thrhi=$tol newhi=bad";
      $Mon{'kappa_mon'}->obeyw( "thresh", "$params" );

      # Expand out to size of input cube.
      $params = "in=$temp6file out=$temp7file axes=[0,1,2] lbound=" . $lbnd->[0] . " ubound=" . $ubnd->[0];
      $Mon{'kappa_mon'}->obeyw( "manic", "$params" );

      # Copy bad pixels from this to output cube.
      $params = "in=$infile ref=$temp7file out=$outfile";
      $Mon{'kappa_mon'}->obeyw( "copybad", "$params" );

      orac_say "Masked out bad samples to form $outfile.";

      # Update the Frame object.
      $Frm->file( $i, $outfile );
    }
  }
}

# Tidy up output.
orac_say "";
