# -*-perl-*-

=head1 NAME

_QA_TIMESERIES_CHECK_ - Perform quality-assurance tests on time-series
data.

=head1 DESCRIPTION

This primitive performs quality-assurance tests applicable to
time-series data. Using previously-calculated values for RMS and Tsys,
it runs various QA tests to check if the RMS and Tsys values are
within spec. See the documentation for the JSA::QA Perl module for
information on these tests.

=head1 ARGUMENTS

=over 4

=item MASK_BAD = LOGICAL (Given)

Whether or not to mask bad receptors as calculated by the QA. [1]

=item METHOD = STRING (Given)

How to detect and mask out emission so as to not confuse matters when
the RMS is determined. 'NARROW' tells the primitive to mask out the
central 10% of the bandpass. 'STANDARD' tells the primitive to mask
out the central 25% of the bandpass. 'WIDE' tells the primitive to
mask out the central 50% of the bandpass. 'AUTO' tells the pipeline to
use MFITTREND to attempt to automatically find emission and mask that
out. ['AUTO']

=item SURVEY = CHARACTER (Given)

The specific survey to analyse. If no survey is given, then all
surveys (and the default 'Telescope') survey will be tested.

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS time-series data.

=item *

Tsys values must be in a hash reference within another hash reference
in the QA_TSYS_VALUES uhdr. This hash reference is created by the
_QA_SYSTEM_TEMPERATURE_ primitive, which must be run before this
primitive.

=item *

RMS values must be in a hash reference within another hash reference
in the QA_RMS_VALUES uhdr. This hash reference is created by the
_QA_SENSITIVITY_VARIATION_ primitive, which must be run before this
primitive.

=item *

The QA tests are performed using various constants which are defined
according to survey, molecule transition, and frequency. If a
molecular transition is defined (i.e. the MOLECULE and TRANSITI FITS
headers are defined) then these are used in preference to the
frequency (obtained from the LOFREQS FITS header). See the qa.ini file
in the ACSIS calibration file directory for these constants.

=item *

If any bad receptors are flagged, they are removed by a call to
_SORT_TIMESERIES_.

=back

=head1 OUTPUT DATA

None.

=head1 TASKS

None.

=head1 REQUIRED PERL MODULES

JSA::QA.

=head1 SEE ALSO

_QA_SENSITIVITY_VARIATION_, _QA_SYSTEM_TEMPERATURE_,
_SETUP_QA_OPTIONS_, _SORT_TIMESERIES_.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

my $maskbad = get_prim_arg( $_PRIM_ARGS_, "MASK_BAD", 1 );
my $method = uc( get_prim_arg( $_PRIM_ARGS_, "METHOD", "AUTO" ) );
my $survey = get_prim_arg( $_PRIM_ARGS_, "SURVEY", undef );

my @surveys = qw/ GBS SLS NGS Telescope /;

my $isok = eval { require JSA::QA; 1; };
if( ! $isok ) {
  orac_warn "Could not load the JSA::QA Perl module: $@\n";
  orac_warn "Continuing with data reduction.\n";
} else {

  my $tsys_values_href = $Frm->uhdr( "QA_TSYS_VALUES" );
  my $rms_values_href = $Frm->uhdr( "QA_RMS_VALUES" );

  my $qaparamfile = $Cal->qaparams;

  # Set up new QA object using this file.
  my $qa = new JSA::QA( file => $qaparamfile );

  foreach my $file ( sort keys %$tsys_values_href ) {

    my $tsys_values = $tsys_values_href->{$file};
    my $rms_values = $rms_values_href->{$file};

    if( ! defined( $tsys_values ) ) {
      orac_warn "Must run Tsys QA calculations before running Tsys QA checks for file $file.\n";
      orac_warn "Possible programming error.\n";
      next;
    }
    if( ! defined( $rms_values ) ) {
      orac_warn "Must run RMS QA calculations before running RMS QA checks for file $file.\n";
      orac_warn "Possible programming error.\n";
      next;
    }

    my ( $tsys_result, %result, %opts );

    # Set up a hash of options to pass to the QA object.
    _SETUP_QA_OPTIONS_
    my $opts = $_SETUP_QA_OPTIONS_{'OPTS'};
    %opts = %$opts;

    # Set up a list of surveys to analyse.
    my @analyse_surveys;
    if( defined( $survey ) ) {
      if( uc( $survey ) eq 'ALL' ) {
        @analyse_surveys = @surveys;
      } else {
        push @analyse_surveys, $survey;
      }
    } else {
      push @analyse_surveys, ( defined( $Frm->uhdr( "ORAC_SURVEY" ) ) ?
                               $Frm->uhdr( "ORAC_SURVEY" )            :
                               "Telescope" );
    }

    # Print results header.
    if( defined( $opts{'molecule'} ) ) {
      my $transition = $Frm->hdr( "TRANSITI" );
      $transition =~ s/\s+//g;
      orac_print "QA results for " . $Frm->hdr( "MOLECULE" ) . " $transition:\n";
    } else {
      orac_print sprintf( "QA results at %.4f GHz:\n", $Frm->hdr( "LOFREQS" ) );
    }

    # Run QA analysis on each requested survey.
    foreach my $analyse_survey ( @analyse_surveys ) {

      $opts{'survey'} = $analyse_survey;
      $tsys_result = $qa->analyse_tsys( $tsys_values, %opts );

      # Now we need to filter out those flagged as bad. Then get the
      # RMS result for the rest.
      my %bad_receptors = map { $_, 1 } @{$tsys_result->bad_receptors};

      my %temp_rms;
      foreach my $receptor ( keys %$tsys_values ) {
        next if exists $bad_receptors{$receptor};
        $temp_rms{$receptor} = $rms_values->{$receptor};
      }

      # Check to see if we've got any receptors left.
      if( scalar keys %temp_rms == 0 ) {

        if( uc( $survey ) ne 'ALL' ) {

          orac_err "All receptors were rejected due to high Tsys.\n";
          $Frm->isgood(0);
          my $ORAC_STATUS = ORAC__TERM;

        } else {
          $result{$analyse_survey} = $tsys_result;
          next;
        }
      }

      # Now run the RMS test with the new "clean" RMS hash.
      my $rms_result = $qa->analyse_timeseries_rms( \%temp_rms,
                                                    %opts );

      # Merge the results. If any of the tests fail, then the whole
      # survey QA test fails.
      my $merged_result = $tsys_result->merge( $rms_result );

      $result{$analyse_survey} = $merged_result;
    }

    # Display the results.
    foreach my $result_survey ( sort keys %result ) {
      my $pass = $result{$result_survey}->pass;
      my $rms_stats = $result{$result_survey}->rms_stats;
      my $tsys_stats = $result{$result_survey}->tsys_stats;
      my $notes = $result{$result_survey}->notes;
      my $fail_reasons = $result{$result_survey}->fail_reasons;
      orac_print " Time-series QA ";
      orac_print ( ( $pass ? " passed " : " failed " ),
                   ( $pass ? "bold white on_green" : "bold white on_red" ) );
      orac_say " for $result_survey.";
      if( defined( $rms_stats ) &&
          defined( $rms_stats->{min} ) &&
          defined( $rms_stats->{max} ) &&
          defined( $rms_stats->{mean} ) ) {
        orac_print "  RMS statistics: ";
        orac_say sprintf( "minimum: %.2f maximum: %.2f mean: %.2f",
                            $rms_stats->{min},
                            $rms_stats->{max},
                            $rms_stats->{mean} );
      }
      if( defined( $tsys_stats ) &&
          defined( $tsys_stats->{min} ) &&
          defined( $tsys_stats->{max} ) &&
          defined( $tsys_stats->{mean} ) ) {
        orac_print "  Tsys statistics: ";
        orac_say sprintf( "minimum: %.2f maximum: %.2f mean: %.2f",
                            $tsys_stats->{min},
                            $tsys_stats->{max},
                            $tsys_stats->{mean} );
      }
      if( defined( $notes ) &&
          scalar @$notes >= 1 ) {
        orac_print "  QA note" . ( scalar @$notes > 1 ? "s" : "" ) . ":\n";
        orac_print "   " . join( "\n ", @$notes );
        orac_print "\n";
      }
      if( ! $pass ) {
        orac_print "  Failure reason" . ( scalar @$fail_reasons > 1 ?
                                         "s"                                                 :
                                         "" );
        orac_say ":";
        orac_print "   " . join( "\n ", @$fail_reasons );
        orac_say "";

        if( scalar keys %result == 1 ) {
          $Frm->isgood(0);
          orac_say " Will not add current frame to group.";
        }

      }
      orac_say "";
    }

    # Sort out bad receptors. They'll be added to the calibration system
    # for either the specific survey or for everything, and only for the
    # current LOFREQ +/- 1 GHz.
    my $lofreq = $Frm->hdr( "LOFREQS" );
    my $survey_br = defined( $Frm->uhdr( "SURVEY_BR" ) ) ? $Frm->uhdr( "SURVEY_BR" ) : 'Telescope';

    my @bad_receptors = @{$result{$survey_br}->bad_receptors};

    if( $maskbad && scalar( @bad_receptors ) > 0 && $result{$survey_br}->pass ) {
      my %recep_hash = ( %{$Frm->hdr},
                         LOFREQ_MAX => $lofreq + 1,
                         LOFREQ_MIN => $lofreq - 1,
                         DETECTORS => ( join ',',@bad_receptors ),
                         SURVEY_BR => $survey_br,
                       );

      orac_say "Using $survey_br results to mask out receptors " . join( ",", sort @bad_receptors );

      $Cal->bad_receptors_qa_index->add( $file, \%recep_hash );
      _SORT_TIMESERIES_
      _QA_SYSTEM_TEMPERATURE_
      _QA_SENSITIVITY_VARIATION_ METHOD=$method
    }
  }
}

