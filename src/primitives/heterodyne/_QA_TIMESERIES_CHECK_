# -*-cperl-*-

=head1 NAME

_QA_TIMESERIES_CHECK_ - Perform quality-assurance tests on time-series
data.

=head1 DESCRIPTION

This primitive performs quality-assurance tests applicable to
time-series data. Using previously-calculated values for RMS and Tsys,
it runs various QA tests to check if the RMS and Tsys values are
within spec. See the documentation for the JSA::QA Perl module for
information on these tests.

=head1 ARGUMENTS

=over 4

=item MASK_BAD = LOGICAL (Given)

Whether or not to mask bad receptors as calculated by the QA. [1]

=item METHOD = STRING (Given)

How to detect and mask out emission so as to not confuse matters when
the RMS is determined. 'NARROW' tells the primitive to mask out the
central 10% of the bandpass. 'STANDARD' tells the primitive to mask
out the central 25% of the bandpass. 'WIDE' tells the primitive to
mask out the central 50% of the bandpass. 'AUTO' tells the pipeline to
use MFITTREND to attempt to automatically find emission and mask that
out. ['AUTO']

=item SURVEY = CHARACTER (Given)

Behaviour depends whether or not the instrument (obtained from the
ORAC_INSTRUMENT internal header) is HARP.

For HARP this argument behaves as follows.  If a value is supplied,
it requests that QA tests use the given survey's QA parameters. If
'all' is given, then run QA using every survey's QA parameters
If left undefined, then use the survey as supplied in the SURVEY
FITS header.

For non-HARP instruments the SURVEY argument is ignored and QA tests
against the instrument as if it were a survey and the special Telescope
category.

[undef']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS time-series data.

=item *

Tsys values must be in a hash reference within another hash reference
in the QA_TSYS_VALUES uhdr. This hash reference is created by the
_QA_SYSTEM_TEMPERATURE_ primitive, which must be run before this
primitive.

=item *

RMS values must be in a hash reference within another hash reference
in the QA_RMS_VALUES uhdr. This hash reference is created by the
_QA_SENSITIVITY_VARIATION_ primitive, which must be run before this
primitive.

=item *

The QA tests are performed using various constants which are defined
according to survey or non-HARP frontend like RXB, molecule
transition, and frequency. If a molecular transition is defined (i.e.
the MOLECULE and TRANSITI FITS headers are defined) then these are
used in preference to the frequency (obtained from the LOFREQS FITS
header). See the qa.ini file in the ACSIS calibration file directory
for these constants.

=item *

If any bad receptors are flagged, they are removed by a call to
_SORT_TIMESERIES_.

=item *

The LEGACY internal headers of the Frame being analysed is set
to false if it is not defined on input.

=back

=head1 OUTPUT DATA

None.

=head1 TASKS

None.

=head1 REQUIRED PERL MODULES

JSA::QA.

=head1 SEE ALSO

_QA_SENSITIVITY_VARIATION_, _QA_SYSTEM_TEMPERATURE_,
_SETUP_QA_OPTIONS_, _SORT_TIMESERIES_.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>
Malcolm J. Currie E<lt>mjc@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008, 2013-2014 Science and Technology Facilities Council.
All Rights Reserved.

=cut

my $maskbad = get_prim_arg( $_PRIM_ARGS_, "MASK_BAD", 1 );
my $method = uc( get_prim_arg( $_PRIM_ARGS_, "METHOD", "AUTO" ) );
my $survey = get_prim_arg( $_PRIM_ARGS_, "SURVEY", undef );

my @surveys = qw/ GBS SLS NGS Telescope /;

my $isok = eval { require JSA::QA; 1; };
if( ! $isok ) {
  orac_warn "Could not load the JSA::QA Perl module: $@\n";
  orac_warn "Continuing with data reduction.\n";
} else {

  my $tsys_values_href = $Frm->uhdr( "QA_TSYS_VALUES" );
  my $rms_values_href = $Frm->uhdr( "QA_RMS_VALUES" );

  # Prevent errors from the qaparams calibration matching the LEGACY
  # header if this primitive is not being called in a 'legacy' recipe.
  # A legacy recipe steering primitive should define the LEGACY
  # internal header, but other recipes will not.
  $Frm->uhdr( "LEGACY", 0 ) if ( ! defined( $Frm->uhdr( "LEGACY" ) ) );

  # Retrieve the QA parameters file and set up a new JSA::QA object.
  my $qaparamfile = $Cal->qaparams;

  # Set up new QA object using this file.  Treat non-HARP instruments
  # as a survey as these older instruments either pre-date ACSIS or are
  # not used by the surveys.  This is to avoid messy syntax additions
  # to qaparams.ini and the header translations of ORAC_SURVEY.
  my $qa;
  my $instrument = uc( $Frm->uhdr( "ORAC_INSTRUMENT" ) );
  if ( $instrument ne "HARP" ) {
    $qa = new JSA::QA( file => $qaparamfile, survey => $instrument );
  } else {
    $qa = new JSA::QA( file => $qaparamfile );
  }

  foreach my $file ( sort keys %$tsys_values_href ) {

    my $tsys_values = $tsys_values_href->{$file};
    my $rms_values = $rms_values_href->{$file};

    if( ! defined( $tsys_values ) ) {
      orac_warn "Must run Tsys QA calculations before running Tsys QA checks for file $file.\n";
      orac_warn "Possible programming error.\n";
      next;
    }
    if( ! defined( $rms_values ) ) {
      orac_warn "Must run RMS QA calculations before running RMS QA checks for file $file.\n";
      orac_warn "Possible programming error.\n";
      next;
    }

    my ( $tsys_result, %result, %opts );

    # Set up a hash of options to pass to the QA object.
    _SETUP_QA_OPTIONS_
    my $opts = $_SETUP_QA_OPTIONS_{'OPTS'};
    %opts = %$opts;

    # Set up a list of surveys to analyse.
    my @analyse_surveys;
    if ( $instrument ne "HARP" ) {
      push @analyse_surveys, $instrument;
      if ( defined( $Frm->uhdr( "ORAC_SURVEY" ) ) ) {
         push @analyse_surveys, $Frm->uhdr( "ORAC_SURVEY" );
      }
      push @analyse_surveys, "Telescope";

    } elsif ( defined( $survey ) ) {
      if( uc( $survey ) eq 'ALL' ) {
        @analyse_surveys = @surveys;
      } else {
        push @analyse_surveys, $survey;
      }

    } else {
      push @analyse_surveys, ( defined( $Frm->uhdr( "ORAC_SURVEY" ) ) ?
                               $Frm->uhdr( "ORAC_SURVEY" )            :
                               "Telescope" );
    }

    # Print results header.
    if( defined( $opts{'molecule'} ) ) {
      my $transition = $Frm->hdr( "TRANSITI" );
      $transition =~ s/\s+//g;
      orac_print "QA results for " . $Frm->hdr( "MOLECULE" ) . " $transition:\n";
    } else {
      orac_print sprintf( "QA results at %.4f GHz:\n", $Frm->hdr( "LOFREQS" ) );
    }

    my %tsys_result;
    my %rms_result;

    # Run QA analysis on each requested survey.
    foreach my $analyse_survey ( @analyse_surveys ) {

      $opts{'survey'} = $analyse_survey;
      $tsys_result = $qa->analyse_tsys( $tsys_values, %opts );

      $tsys_result{$analyse_survey} = $tsys_result;

      # Now we need to filter out those flagged as bad. Then get the
      # RMS result for the rest.
      my %bad_receptors = map { $_, 1 } @{$tsys_result->bad_receptors};

      my %temp_rms;
      foreach my $receptor ( keys %$tsys_values ) {
        next if exists $bad_receptors{$receptor};
        $temp_rms{$receptor} = $rms_values->{$receptor};
      }

      # Check to see if we've got any receptors left.
      if( scalar keys %temp_rms == 0 ) {

        if( defined( $survey ) && uc( $survey ) ne 'ALL' ) {

          orac_err "All receptors were rejected due to high Tsys.\n";
          $Frm->isgood(0);
          my $ORAC_STATUS = ORAC__TERM;

        } else {
          $result{$analyse_survey} = $tsys_result;
          $rms_result{$analyse_survey} = new JSA::QA::Result( pass => 0 );
          next;
        }
      }

      # Now run the RMS test with the new "clean" RMS hash.
      my $rms_result = $qa->analyse_timeseries_rms( \%temp_rms,
                                                    %opts );

      $rms_result{$analyse_survey} = $rms_result;

      # Merge the results. If any of the tests fail, then the whole
      # survey QA test fails.
      my $merged_result = $tsys_result->merge( $rms_result );

      $result{$analyse_survey} = $merged_result;
    }

    # Display the results.
    foreach my $result_survey ( sort keys %result ) {
      my $pass = $result{$result_survey}->pass;
      my $rms_stats = $result{$result_survey}->rms_stats;
      my $tsys_stats = $result{$result_survey}->tsys_stats;
      my $notes = $result{$result_survey}->notes;
      my $fail_reasons = $result{$result_survey}->fail_reasons;
      orac_print " Time-series QA ";
      orac_print ( ( $pass ? " passed " : " failed " ),
                   ( $pass ? "bold white on_green" : "bold white on_red" ) );
      orac_say " for $result_survey.";
      if( defined( $rms_stats ) &&
          defined( $rms_stats->{min} ) &&
          defined( $rms_stats->{max} ) &&
          defined( $rms_stats->{mean} ) ) {
        orac_print "  RMS statistics: ";
        orac_say sprintf( "minimum: %.2f maximum: %.2f mean: %.2f",
                            $rms_stats->{min},
                            $rms_stats->{max},
                            $rms_stats->{mean} );
      }
      if( defined( $tsys_stats ) &&
          defined( $tsys_stats->{min} ) &&
          defined( $tsys_stats->{max} ) &&
          defined( $tsys_stats->{mean} ) ) {
        orac_print "  Tsys statistics: ";
        orac_say sprintf( "minimum: %.2f maximum: %.2f mean: %.2f",
                            $tsys_stats->{min},
                            $tsys_stats->{max},
                            $tsys_stats->{mean} );
      }
      if( defined( $notes ) &&
          scalar @$notes >= 1 ) {
        orac_print "  QA note" . ( scalar @$notes > 1 ? "s" : "" ) . ":\n";
        orac_print "   " . join( "\n ", @$notes );
        orac_print "\n";
      }
      if( ! $pass ) {
        orac_print "  Failure reason" . ( scalar @$fail_reasons > 1 ?
                                         "s"                                                 :
                                         "" );
        orac_say ":";
        orac_print "   " . join( "\n ", @$fail_reasons );
        orac_say "";

        if( scalar keys %result == 1 ) {
          $Frm->isgood(0);
          orac_say " Will not add current frame to group.";
        }

      }
      orac_say "";

      _QA_REPORT_RECEPTORS_ RMS=$rms_result{$result_survey} SURVEY=$result_survey TSYS=$tsys_result{$result_survey}

    }

    # Sort out bad receptors. They'll be added to the calibration system
    # for either the specific survey or for everything, and only for the
    # current LOFREQ +/- 1 GHz.
    my $lofreq = $Frm->hdr( "LOFREQS" );
    my $survey_br = defined( $Frm->uhdr( "SURVEY_BR" ) ) ? $Frm->uhdr( "SURVEY_BR" ) : 'Telescope';

    my @bad_receptors = @{$result{$survey_br}->bad_receptors};

    if( $maskbad && scalar( @bad_receptors ) > 0 && $result{$survey_br}->pass ) {
      my %recep_hash = ( %{$Frm->hdr},
                         LOFREQ_MAX => $lofreq + 1,
                         LOFREQ_MIN => $lofreq - 1,
                         DETECTORS => ( join ',',@bad_receptors ),
                         SURVEY_BR => $survey_br,
                       );

      orac_say "Using $survey_br results to mask out receptors " . join( ",", sort @bad_receptors );

      $Cal->bad_receptors_qa_index->add( $file, \%recep_hash );
      _MASK_RECEPTORS_ RECEPTORS=\@bad_receptors
      _QA_SYSTEM_TEMPERATURE_
      _QA_SENSITIVITY_VARIATION_ METHOD=$method
    }
  }
}

