# -*-perl-*-

=head1 NAME

_QA_MAP_RMS_FREQ_UNIFORMITY_ - Run quality-assurance test to check for
uniformity in RMS across the frequency range of a reduced map.

=head1 DESCRIPTION

This primitive tests line-free regions of reduced cubes for average
RMS noise. It compares the RMS in the upper and lower 10% of the
frequency bounds, after masking out lines, and if the RMS values
differ by more than a given percentage (which varies from survey to
survey), then the test is considered to fail.

A line mask is obtained from the BASELINE_MASKS internal user
header. If no such masks are available, then new masks are created
using the _CREATE_BASELINE_MASK_ primitive.

=head1 ARGUMENTS

=over 4

=item FREQUENCY_SMOOTH = INTEGER (Given)

If a baseline mask has not already been found, then smooth in
frequency space by the given number of pixels. [25]

=item GROUP = INTEGER (Given)

How to process group files. 0 means use the current Frame object. 1
means use the current Group object. 2 means use each Frame member of
the current Group object. [0]

=item ORDER = INTEGER (Given)

The polynomial order that will be used when estimating baselines. Only
used if baselining has not been done. [5]

=item SPATIAL_SMOOTH = INTEGER (Given)

The number of pixels to smooth in both spatial axes when smoothing to
determine baselines. [3]

=item SURVEY = STRING (Given)

If supplied, run QA using the given survey's QA parameters. If 'all'
is given, then run QA using every survey's QA parameters. If left
undefined, then use the survey as supplied in the SURVEY FITS
header. ['']

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for reduced ACSIS cubes.

=item *

The survey name is obtained from the SURVEY FITS header. If this
header is blank, then the special pseudo-survey "Telescope" is used.

=back

=head1 OUTPUT DATA

=over 4

=item *

RMS maps for the lower and upper bounds in cubes with suffix _rmslo
and _rmshi.

=back

=head1 TASKS

KAPPA: ADD, COLLAPSE, NDFCOPY, STATS.

=head1 REQUIRED PERL MODULES

JSA::QA.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

use JSA::QA;

# We need to bring in the smoothing parameters and baselining
# parameters in case we don't already have a baseline mask.
my $freqsmooth = get_prim_arg( $_PRIM_ARGS_, "FREQUENCY_SMOOTH", 25 );
my $group = get_prim_arg( $_PRIM_ARGS_, "GROUP", 0 );
my $order = get_prim_arg( $_PRIM_ARGS_, "ORDER", 5 );
my $spatsmooth = get_prim_arg( $_PRIM_ARGS_, "SPATIAL_SMOOTH", 3 );
my $survey = get_prim_arg( $_PRIM_ARGS_, "SURVEY", undef );

my @surveys = qw/ GBS NGS SLS Telescope /;

# Set up a list of surveys to analyse.
my @analyse_surveys;
if( defined( $survey ) ) {
  if( uc( $survey ) eq 'ALL' ) {
    @analyse_surveys = @surveys;
  } else {
    push @analyse_surveys, $survey;
  }
} else {
  push @analyse_surveys, ( defined( $Frm->hdr( "SURVEY" ) ) ?
                           $Frm->hdr( "SURVEY" )            :
                           "Telescope" );
}

# Figure out what we're doing with groups/frames.
my @objs;
if( $group == 0 ) {
  push @objs, $Frm;
} elsif( $group == 1 ) {
  push @objs, $Grp;
} elsif( $group == 2 ) {
  @objs = $Grp->members;
} else {
  orac_throw "Programming error: GROUP parameter to _QA_MAP_RMS_UNIFORMITY_ must be 0, 1, or 2";
}

if( $group != 1 || ( $group == 1 && $Grp->lastmember( $Frm ) ) ) {

  if( ! ( $group == 1 && $Grp->uhdr( "COPY_FRAME_CUBE" ) ) ) {

    foreach my $Obj ( @objs ) {

      my ( undef, $outlo ) = $Obj->inout( "_rmslo" );
      my ( undef, $outhi ) = $Obj->inout( "_rmshi" );

      # Two arrays holding collapsed regions from high and low
      # frequency ends.
      my @collapsedlo;
      my @collapsedhi;

      foreach my $i ( 1 .. $Obj->nfiles ) {

        my ( $in, undef ) = $Obj->inout( "_blah", $i );

        if( $Obj->uhdr( "SPARSE" ) ) {

          orac_warn $Obj->file( $i ) . " is a sparse cube. Cannot currently process QA on sparse cubes.\n";

        } else {

          orac_say "Checking RMS uniformity for $in.";

          my $collapsedlo = new ORAC::TempFile;
          my $collapsedhi = new ORAC::TempFile;

          # Make sure a baseline mask is available.
          if( ! defined( $Obj->uhdr( "BASELINE_MASKS" ) ) ) {

            _CREATE_BASELINE_MASK_ GROUP=$group FREQUENCY_SMOOTH=$freqsmooth SPATIAL_SMOOTH=$spatsmooth ORDER=$order

          }

          my $masks = $Obj->uhdr( "BASELINE_MASKS" );
          my $mask = $masks->[$i];

          # Mask out the emission.
          orac_say " Masking out lines using $mask.";
          my $masked = new ORAC::TempFile;
          my $params = "in1=$in in2=$mask out=$masked";
          $Mon{'kappa_mon'}->obeyw( "add", "$params" );

          # Get dimensions of the masked cube.
          _GET_DIMENSIONS_ FILE=$masked
          my $lbound = $_GET_DIMENSIONS_{LBOUND};
          my $ubound = $_GET_DIMENSIONS_{UBOUND};
          my $dims = $_GET_DIMENSIONS_{DIMS};

          # Take 10% from either end to collapse over.
          my $ubnd_spread = ( $ubound->[2] - int( $dims->[2] * 0.1 ) ) . ":" . $ubound->[2];
          my $lbnd_spread = $lbound->[2] . ":" . ( $lbound->[2] + int( $dims->[2] * 0.1 ) );

          # Collapse.
          $params  = "in=$in(,,$lbnd_spread) out=$collapsedlo estimator=rms";
          $params .= " axis=SPEC wlim=0.0 trim=false variance=false";
          $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

          $params  = "in=$in(,,$ubnd_spread) out=$collapsedhi estimator=rms";
          $params .= " axis=SPEC wlim=0.0 trim=false variance=false";
          $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

          push @collapsedlo, $collapsedlo;
          push @collapsedhi, $collapsedhi;

        }
      }

      if( scalar( @collapsedlo ) == 1 ) {

        $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$collapsedlo[0] out=$outlo" );
        $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$collapsedhi[0] out=$outhi" );

      } else {

        orac_say "\n Pasting together temporary noise maps to form full noise maps.";

        _PASTE_FILES_ FILES=\@collapsedlo OUT=$outlo
        _PASTE_FILES_ FILES=\@collapsedhi OUT=$outhi

      }

      # Report to user.
      orac_say " RMS map from lower 10% of frequency range created in $outlo.";
      orac_say " RMS map from upper 10% of frequency range created in $outhi.";

      _SET_FILE_FITS_ITEM_ FILE=$outlo KEY=PRODUCT VALUE=rmslo
      _SET_FILE_FITS_ITEM_ FILE=$outhi KEY=PRODUCT VALUE=rmshi

      # Get the mean RMS for the low and high.
      $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outlo" );
      my ( $ORAC_STATUS, $rmslo ) = $Mon{'kappa_mon'}->get( "stats", "mean" );
      $Mon{'kappa_mon'}->obeyw( "stats", "ndf=$outhi" );
      ( $ORAC_STATUS, my $rmshi ) = $Mon{'kappa_mon'}->get( "stats", "mean" );

      # Report to user.
      orac_say sprintf( " RMS in lower 10%%: %.4fK", $rmslo );
      orac_say sprintf( " RMS in upper 10%%: %.4fK", $rmshi );

      my $perc = 100 * abs( $rmslo - $rmshi ) / ( ( $rmslo < $rmshi ) ? $rmslo : $rmshi );

      orac_say sprintf( " Percentage difference: %.2f%%", $perc );

      # Do QA tests.
      _SETUP_QA_OPTIONS_
      my %opts = %{$_SETUP_QA_OPTIONS_{'OPTS'}};
      my $qaparamfile = $Cal->qaparams;
      my $qa = new JSA::QA( file => $qaparamfile );

      # Go through each survey and report QA results.
      foreach my $analyse_survey ( sort @analyse_surveys ) {

        $opts{'survey'} = $analyse_survey;

        my $RMSVAR_SPEC = $qa->get_data( key => 'RMSVAR_SPEC', %opts );
        orac_print " Frequency RMS uniformity ";
        if( $perc < $RMSVAR_SPEC * 100 ) {
          orac_print( " passed ", "bold white on_green" );
        } else {
          orac_print( " failed ", "bold white on_red" );
        }
        orac_say " for $opts{'survey'} for current map.";
      }

      orac_say "";

    }
  }
}
