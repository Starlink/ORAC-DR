# -*-cperl-*-

=head1 NAME

_DESPIKE_ - Remove large spikes from a time-series cube.

=head1 DESCRIPTION

This primitive removes large spikes from a time-series cube. It first
collapses the cube along the time axis, using the RMS estimator. It
then optionally collapses along the detector axis, again using the RMS
estimator, to form an RMS spectrum representative of the entire
cube. High RMS values across one or two channels are considered to be
spikes.

After creating the RMS spectrum, this primitive finds the background,
using a user-specified box size (see BACKGROUND_BOX parameter,
below). This "background" is subtracted from the RMS spectrum. Then
large deviations are masked, using the KAPPA/FFCLEAN task (see
BACKGROUND_BOX and BACKGROUND_CLIP parameters, below).

A spike mask spectrum is thus created and grown to the size of the
original time-series cube. The bad pixels are copied from the spike
mask to the time-series cube, thus masking out spikes.

=head1 ARGUMENTS

=over 4

=item BACKGROUND_BOX = INTEGER (Given)

The size, in pixels, of the box used to both find the "background" and
for cleaning spikes. This box should be slightly wider than the widest
expected spike. Making this parameter too large will result in signal
being identified as a spike and thus masked out. [5]

=item BACKGROUND_CLIP = ARRAY (Given)

The clip levels to use when finding spikes in the background-
subtracted RMS spectrum. Multiple values result in multiple clip
levels. If supplying only one clip level, do not supply square
brackets (i.e. supply "3", without quotes). If supplying more than
one, supply square brackets and comma-separate the levels (i.e. supply
"[3,3,5]", without quotes). ['[3,5]']

=item PER_DETECTOR = BOOLEAN (Given)

Whether or not to perform the second collapse along the detector
axis. If a spike is not seen in all detectors, consider setting this
value to 1 (for true). [0]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for ACSIS time-series cubes.

=back

=head1 OUTPUT DATA

=over 4

=item *

The despiked time-series cube with _ds suffix.

=back

=head1 TASKS

CUPID: FINDBACK.

KAPPA: COLLAPSE, COPYBAD, FFCLEAN, STATS, SUB, WCSALIGN.

=head1 REQUIRED PERL MODULES

None.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

my $back_box = ( defined( $_PRIM_ARGS_->{'BACKGROUND_BOX'} ) ?
                 $_PRIM_ARGS_->{'BACKGROUND_BOX'}            :
                 5 );
my $back_clip = ( defined( $_PRIM_ARGS_->{'BACKGROUND_CLIP'} ) ?
                  $_PRIM_ARGS_->{'BACKGROUND_CLIP'}            :
                  '[3,5]' );
my $per_detector = ( defined( $_PRIM_ARGS_->{'PER_DETECTOR'} ) ?
                     $_PRIM_ARGS_->{'PER_DETECTOR'}            :
                     0 );

foreach my $i ( 1 .. $Frm->nfiles ) {

  my( $in, $out ) = $Frm->inout( "_ds", $i );

  # Collapse along the time axis.
  my $temp1 = new ORAC::TempFile;
  my $temp1file = $temp1->file;
  my $params = "in=$in out=$temp1file estimator=rms axis=3 wlim=0.0";
  $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );

  # Collapse along the channel axis unless otherwise told not to.
  my ( $temp2, $temp2file );
  if( $per_detector ) {
    $temp2file = $temp1file;
  } else {
    $temp2 = new ORAC::TempFile;
    $temp2file = $temp2->file;
    $params = "in=$temp1file out=$temp2file estimator=rms axis=2 wlim=0.0";
    $Mon{'kappa_mon'}->obeyw( "collapse", "$params" );
  }

  # Do a clipped stats to determine the RMS.
  $params = "ndf=$temp2file clip=[2,3,3]";
  $Mon{'kappa_mon'}->obeyw( "stats", "$params" );
  my( $ORAC_STATUS, $sigma ) = $Mon{'kappa_mon'}->get( "stats", "sigma" );

  # Find the "background" using a box size as specified by the user.
  my $temp3 = new ORAC::TempFile;
  my $temp3file = $temp3->file;
  $params = "in=$temp2file out=$temp3file rms=$sigma";
  if( $per_detector ) {
    $params .= " box=[$back_box,1]";
  } else {
    $params .= " box=$back_box";
  }
  $Mon{'cupid_mon'}->obeyw( "findback", "$params" );

  # Subtract this "background" from the RMS-spectrum to get only the
  # spikes (and some residuals from the actual signal).
  my $temp4 = new ORAC::TempFile;
  my $temp4file = $temp4->file;
  $params = "in1=$temp1file in2=$temp3file out=$temp4file";
  $Mon{'kappa_mon'}->obeyw( "sub", "$params" );

  # Mask any large deviations.
  my $temp5 = new ORAC::TempFile;
  my $temp5file = $temp5->file;
  $params = "in=$temp4file out=$temp5file clip=$back_clip";
  if( $per_detector ) {
    $params .= " box=[$back_box,1]";
  } else {
    $params .= " box=$back_box";
  }
  $Mon{'kappa_mon'}->obeyw( "ffclean", "$params" );

  # Grow the mask spectrum back to the size of the original cube.
  my $temp6 = new ORAC::TempFile;
  my $temp6file = $temp6->file;
  $params = "in=$temp5file out=$temp6file ref=$in method=nearest accept";
  $Mon{'kappa_mon'}->obeyw( "wcsalign", "$params" );

  # Copy the bad pixels from this mask cube to the original cube.
  $params = "in=$in ref=$temp6file out=$out";
  $Mon{'kappa_mon'}->obeyw( "copybad", "$params" );

  orac_print "$in to $out:\n";
  orac_print " Despiked.\n";

  # Set the product.
  $Frm->product( "despike" );

  # Update the Frame object.
  $Frm->file( $i, $out );
}

# Display, if necessary.
$Display->display_data( $Frm ) if defined $Display;

# Tidy-up output.
orac_print "\n";
