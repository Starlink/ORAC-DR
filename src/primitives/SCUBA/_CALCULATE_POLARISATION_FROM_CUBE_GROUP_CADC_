=head1 NAME

CALCULATE_POLARISATION_FROM_CUBE_GROUP

=head1 DESCRIPTION

Calculate the I,P and THETA from the groups by coadding the 
IQU cubes generated by _GENERATE_IQU_CUBE_FRAME_.

=head1 PARAMETERS

BIN - binning factor (default = 2)
S2N - Signal-to-noise clip level (default = 2)

=head1 TASKS

CCDPACK mosaic is used to average the cubes since it can take
origin information into account.

Will fall back to Kappa MATHS if CCDPACK is not available.
This will lead to truncation of areas not covered by both maps
and should be avoided if possible!

The _CALCULATE_POLARISATION_FROM_CUBE_FRAME_ is used to calculate
and display the polarisation properties.

=head1 PREREQUISITES

The previous frame primitive should leave the Frames so that
they contain an IQU cube. This primitive will not work if that
is not the case (eq the cube generation step is missing or
the frame now points to an I frame).

=head1 NOTES

The group coadding only occurs when there are at least two observations
in the group.

If kappa MATHS is used for the averaging, no more than 26 cubes
can be combined.

=cut

# ROR 2006-06-08; modify for CADC-specific version
# Bin parameter
my $bin = ($_CALCULATE_POLARISATION_FROM_CUBE_GROUP_CADC_{BIN} || 2);
my $Sig2N = ($_CALCULATE_POLARISATION_FROM_CUBE_GROUP_CADC_{'S2N'} || 2);

# ROR 2006-10-06 : do this regardless of how many files are in the group
# Check that we are processing the last frame of the group
# if ($Grp->lastmember($Frm) && $Grp->num >=1) {
if ($Grp->lastmember($Frm)) {

  # Loop over sub-instruments and group members
  # and generate
  my @out;  # Averaged cube names

  # Loop over sub instruments that are found in the current frame
  foreach my $sub ($Frm->subs) {

    # Now need to find all the input frames for this sub-instrument
    # that are part of this group
    my @members = $Grp->membernamessub($sub);
    my $ncubes = $#members + 1;

    # No point averaging one cube
    #if ($ncubes > 1) {
    if (1) {
      # ROR 2006-06-08: change the suffix from _avcube to _iqu, as is done for the frame files.

      # ROR 2006-06-08 ; prepend '_iqu' to the file suffix if it is not already there
      $Grp->filesuffix( '_iqu' . $Grp->filesuffix ) unless $Grp->filesuffix =~ /_iqu/;

      # Generate a temp output name from the group and suffix, then strip off the file extension
      my $out = $Grp->grpoutsub($sub) . $Grp->filesuffix;
      $out =~ s/\.\w*$//;
      push(@out, $out);
      
      orac_print "Calculating mean of IQU cubes for sub $sub from $ncubes cubes.\n";

      if (defined $Mon{ccdpack_reg}) {

	orac_print "Mosaicing the following frames:\n".join("\n",@members)."\n";

	# If block to make it easy to switch between mosaicing methods
	# - default is to mosaic cubes all in one go.
	if (1) {

	  # Mosaic all 3 planes in one go (only need to mosaic planes
	  # separately if we are scaling and correcting for zero point
	
	  # Create text file for mosaic names
	  my $tmp = new ORAC::TempFile || 
	    die "Error opening makemos input file\n";

	  print {$tmp->handle} join("\n", @members) ."\n";
	  $tmp->handle->close || die "Error closing makemos input file\n";

	  # Arguments
	  my $args = "in=^". $tmp->file ." noscale nozero method=mean usevar genvar title='Average IQU cube'";

	  # Run CCDPACK makemos
	  $Mon{ccdpack_reg}->obeyw("makemos","$args out=${out}");

	} else {

	  # Do this instead if we want to turn on scale or zero correction

	  # need to mosaic the I, Q and U planes separately and then
	  # regenerate the cube

	  my @planes = qw(I Q U);

	  foreach my $i (0..$#planes) {
	    my $plane = $i + 1;
	    orac_print "Mosaicing the $planes[$i] data\n";

	    # Create text file for mosaic names
	    my $tmp = new ORAC::TempFile || 
	      die "Error opening makemos input file\n";

	    print {$tmp->handle} join("(,,$plane)\n", @members) ."(,,$plane)\n";
	    $tmp->handle->close || die "Error closing makemos input file\n";

	    # We are using the first member as a reference
	    my $ref = $members[0] . "(,,$plane)";

	    my $args = "in=^". $tmp->file ." noscale nozero method=mean usevar genvar title='Average $planes[$i]'";

	    # Run CCDPACK -- currently with noscale/nozero [simply change
	    # previous line to turn on these corrections]
	    $Mon{ccdpack_reg}->obeyw("makemos","$args out=${out}_mos$planes[$i] ref=$ref");

	  }

	  orac_print "Putting cube back together...\n";
	  # Now paste the planes back into the cube
	  $Mon{kappa_mon}->obeyw("paste","in=${out}_mos$planes[0] p1=${out}_mos$planes[1] p2=${out}_mos$planes[2] title='Average IQU cube' out=$out");

	}

	# Copy world coordinates
	$Mon{ndfpack_mon}->obeyw("wcscopy","ndf=$out like=$members[0] ok=true");

      } else {
	orac_print "MAKEMOS not available -- using KAPPA instead.\n This will lead to truncation of non-overlapping regions\n";

	# Kappa maths can only combine up to 26 input files
	if ($#members > 25) {
	  orac_err("Can only process a maximum of 26 IQU cubes\n");
	  my $ORAC_STATUS = ORAC__ERROR;
	}

	# Create maths string (not unicode compliant!)
	# generate "ia + ib + ic .... " expression for kappa maths
	my $exp = '('.join ("+",grep {$_ = "i".chr($_+96)} (1..$ncubes)) . ")/$ncubes";

	# Generate "ia=cube1 ib=cube2...."
	my $args = join(" ", grep {
	  $_ = "i".chr($_+96)."=" . $members[$_-1];
	} (1..$ncubes));

	# Run maths
	$Mon{kappa_mon}->obeyw("maths","exp='$exp' out=$out $args title='Average IQU'");
      }

      # Propagate the OBJECT header from the Frm into the FITS headers.
      # This comment forces the FITS extension to exist.
      # Otherwise the call to _SET_FILE_FITS_ITEM_ may fail.
      $Mon{'ndfpack_mon'}->obeyw("fitsmod","ndf=$out edit=write keyword=COMMENT position=! value=! comment=!");
      my $object = $Frm->hdr('OBJECT');
      _SET_FILE_FITS_ITEM_ FILE=$out KEY=OBJECT VALUE=$object COMMENT=Name|of|object STRING=1
    
    } else {
      # ROR 2006-10-06: this should never happen any more
      push(@out, $members[0]);
    }

  }

  # Dont really like this next bit but I cant work out how to 
  # have a primitive that truly can be used for frame and
  # group calculations

  my $TFrm = new $Frm;
  {
    # Now we want to call the frame cal_pol primitive
    # Need to create a $Frm that maskes the main $Frm
    # So that the primitive will use our pseudo frame
    # This frame will know nothing except the file names
    # so dont expect to use header information or sub instruments
    my $Frm = new $TFrm;

    $Frm->files(@out);  # Load it up with the output cube names

    # Copy the important headers from the first member of group
    $Frm->hdr("OBJECT", $Grp->members->[0]->hdr("OBJECT"));
    $Frm->hdr("RUN", $Grp->members->[0]->hdr("RUN") . "[GRP]");

    # The only problem is that the gui_id will return sN**
    # rather than gN**. Will live with this for now
    # Easiest fix is the make the prefix configurable in the Frame
    # object ->   $Frm->gui_prefix('g');

    _CALCULATE_POLARISATION_FROM_CUBE_FRAME_ BIN=$bin S2N=$Sig2N

    # Note that we do not erase the average cube

  }
  undef $TFrm;

}


# COPYRIGHT
#
#   Copyright (C) 1998-2000 Particle Physics and Astronomy Research
#   Council. All Rights Reserved.


