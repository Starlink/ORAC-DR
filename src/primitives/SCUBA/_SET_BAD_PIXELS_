=head1 NAME

_SET_BAD_PIXELS_ - Set requested bolometers to bad status

=head1 DESCRIPTION

Determine requested bad pixels and set those bolometers
to 'bad' in the input file. The bad bolometer list can
be determined in a number of ways specified by the
badbol() calibration method.

The pipeline can be configured to use 3 different methods
to determine the bad bolometer list:

 - 'index': Use an index file generated by noise observations
            using the reflector blade. The bolometers stored in this
            file are those that were above the noise threshold in
            the _REDUCE_NOISE_ primitive. The index file is generated
            by the _REDUCE_NOISE_ primitive
 - 'file' : Uses the contents of the file badbol.lis (contains a space
            separated list of bolometer names in the first line). This
            file is in ORAC_DATA_OUT. If the file is not found, no
            bolometers will be flagged.
            The input file is generated by hand, stored in $ORAC_DATA_OUT
            and is called badbol.lis. Currently the format should be:

              A1 A3 B15 H7

            or whatever (ie space separated).
 - colon separated list of bad bolometers
            If badbols=h7:12:g4,... then this list will be used
            as the bad bolometers throughout the reduction.

Which one is used can be specified on the oracdr command line
by using the -cal option. Default is to look for the 'file'
(badbol.lis).

The one wrinkles is that it is more helpful if we accept bolometer
names for the bad pixel designation in the file BUT change_quality
accepts bolometer numbers in the file.


This means that we have to convert the bolometer name to a
ADC number and channel number (fairly easy) and then see whether
this is present in the data before turning it off.

If the bolometer is designated as a number we simply pass it through
unchanged to CHANGE_QUALITY.

=head1 TASKS

SURF: CHANGE_QUALITY

=head1 NOTES

- Uses NDF calls to read the BOL_CHAN and BOL_ADC extensions!

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 1998-2003 Particle Physics and Astronomy Research
Council. All Rights Reserved.

=cut




# Read the bad bolometers in from 'wherever'
my @badbols = $Cal->badbol_list;

# Now that we have a list we should read in the BOL_ADC
# and BOL_CHAN arrays
if ($#badbols > -1) {
  use NDF;  # Import commands into my namespace
  my ($xloc, $indf, $status);
  # Open $Frm for read
  $status = &NDF::SAI__OK;
  ndf_begin();
  ndf_find(&NDF::DAT__ROOT(), $Frm->file, $indf, $status);

  # Find the SCUBA extension
  ndf_xloc($indf, 'SCUBA', 'READ', $xloc, $status);

  # Read BOL_CHAN and BOL_ADC
  my (@bolchan, @boladc, $el);
  cmp_getvd($xloc, 'BOL_CHAN', 200, @bolchan, $el, $status);
  cmp_getvd($xloc, 'BOL_ADC', 200, @boladc, $el, $status);

  # Annul locator and NDF id
  dat_annul($xloc, $status);
  ndf_annul($indf, $status);

  ndf_end($status);

  if ($status != &NDF::SAI__OK) {
    @bolchan = ();
    @boladc = ();
  }

  # Only proceed if we have something in @bolchan or @boladc

  if ($#bolchan > -1 && $#boladc > -1) {

    # Generate a look up table for the ADC lookup
    # I'm sure there is a better way to do this but...
    # Could do this using ord() and offsets from 'A'
    # but I have a feeling that might not be very general
    # (it assumes that B follows A in the character set....)

    my %lut = ( A => 1, B => 2, C => 3, D => 4, E => 5, F => 6,
		G => 7, H => 8, I => 9);

    # And now the revers lut
    my %numtoadc;
    for my $letter (keys %lut) {
      $numtoadc{$lut{$letter}} = $letter;
    }

    # Now loop over the selected bolometers.
    # so that a CHANGE_QUALITY string can be created
    my @match = (); # Store matching bolometers
    my @mname = (); # Names of matching bolometers

    foreach my $bol (@badbols) {

      # If we have a straight number it should always
      # match (unless it is too large)
      if ($bol =~ /^\d+$/) {

	# check range
	if ($bol <= scalar(@boladc) && $bol > 0) {

	  push(@match, $bol);

	  # Translate back to a name
	  my $index = $bol-1;
	  my $name = $numtoadc{$boladc[$index]} . $bolchan[$index];
	  push(@mname, $name);

	}

      } else {

	# Have a name
	my $adc = uc(substr($bol,0,1));
	my $chan = substr($bol,1);

	# Convert ADC letter to a ADC number
	my $adcl = $lut{$adc};

	# Now need to match the adc and chan with that
	# read from the file. Can I think of a fast way
	# to do this with grep? Unfortunately we need to
	# compare two files and remember the index of the
	# unique match
	for (my $i=0; $i <= $#bolchan; $i++) {
	  if ($adcl == $boladc[$i] && $chan == $bolchan[$i]) {
	    push(@match, $i+1); # Count from 1 not 0
	    push(@mname, $bol);
	    last;
	  }
	}
      }
    }

    # Now if @match contains some entries we can construct
    # a string for CHANGE_QUALITY and set the bolometers bad
    if ($#match > -1) {

      # If we have too many bolometers in the list we overrun the
      # buffer for the file name. Therefore do the change quality
      # in chunks of 10 bolometers at a time
      my $nmax = 10;
      for (my $n = 0; $n <= $#match; $n+=$nmax+1) {
	my $last = ( $n+$nmax < $#match ? $n+$nmax : $#match);

	my $in = $Frm->file . '{B' . join(",",@match[$n..$last]) . '}';

	# Run change_quality
	$Mon{surf_mon}->obeyw("change_quality","in='$in' bad_quality=yes");

      }
      # message
      my $bolstring = join(",",@mname);
      orac_print("Setting bolometers [$bolstring] to bad\n");

    }

  }
}


