#+
# Name:
#    _COMBINE_CHOPPED_SOURCE_
#
# Purpose:
#    Combines chopped and nodded images for NOD_CHOP recipes.
#
# Language:
#    Perl5
#
# Description:
#    This primitive forms a combined source file from the current group
#    file.  It expects the group file to be an integrated chopped and
#    nodded image, in which the source appears as two positive and two
#    negative images, or as a single positive and negative pair of
#    images.  The primitive optionally locates the centroid of each
#    each source, and extracts a symmetric region about each source.
#    These regions are combined (see argument METHOD) to create an
#    image of the source of twice (or root 2 for dual images) the
#    signal-to-noise of a single image, but normalised to yield the
#    average signal of a single image.  This maintains the scaling of
#    flux per unit exposure time.
#
#    The primitive also forms a quality map indicating the contributions
#    from each image of the source to help interpret the final combined
#    frame.
#
# Arguments:
#    CENTROID = LOGICAL (Given)
#       If true (1), centroid on the source in each sub-frame before
#       combining.  If successful, the resultant combined file has the
#       source centred.  Centroiding is not suitable for objects near
#       the detection limit or amorphous extended source.  Setting
#       CENTROID to false (0), means the combined file is centred about
#       the expected position of the source.  [1]
#    CLEAN = LOGICAL (Given)
#       If true (1), column then row patterns, say due to pickup or
#       bias variations, are filtered out by subtracting the median
#       of each column or row from all the values in that column or
#       row.  It's useful to help see faint sources.  [0]
#    METHOD = CHARACTER (Given)
#       The method used to combine frames, once all have the same
#       polarity.  See parameter METHOD of CCDPACK/MAKEMOS (SUN/139) for
#       the options.  The main two in practice will be "Median" or
#       "Mean".  The former excludes outliers but has problems in good
#       seeing where the registration is poor, as it biases against the
#       peak values of the steepening profile near the core, and hence
#       underestimate the flux.  In this circumstance the mean blurs the
#       psf profile, making it more of a plateau than a sharp peak.
#       However, the mean preserves the flux, at the cost of the odd
#       rogue value affecting the result.  ["Mean"]
#    QMAP = LOGICAL (Given)
#       If true (1), a quality map is generated. [0]
#    SMOOTH = INTEGER (Given)
#       If greater than 1 apply block smoothing with a square block size
#       equal to SMOOTH to the combined image.  For all other values,
#       there is no smoothing.  [0]
#
# Notes:
#    -  This primitive is suitable for Michelle in imaging mode.
#    -  Processing only occurs for object frames, and when the
#    steering header MAKE_MOSAIC is true.
#    -  The file to be combined may be specified through group user
#    header MOSAIC_FRAME, if $Grp->file is not the file from which to
#    combine images.
#    -  The centroid is found by first setting the initial positions to
#    the telescope offset in Cartesian co-ordinates for each nod position
#    from the centre of the mosaic, and using a search window equal
#    to the larger absolute telescope offset.  The telescope offsets are
#    derived from the first and second frames in the current-cycle group.
#    -  The average offsets of the centroid positions from the nominal
#    source locations are found; the nearest-integer offsets are stored
#    in $Cal->baseshift.  When argument CENTROID is false,
#    $Cal->baseshift is accessed, and if there is a valid shift vector,
#    the script offsets the nominal position of each region by this
#    vector.  This is to allow for misplaced instrument apertures
#    whenever the weak flux prevents centroiding.
#    -  The regions are made as large as possible such that there is no
#    duplication of pixels from the original group file.  In other words
#    the regions extend to the midpoints of the chop throw and nod
#    offsets.  User header ORAC_CHOP_ANGLE is used to select one of two
#    orientations (0 or +/-90 degrees) to derive the x-y half-widths of
#    the regions.  The exception occurs when the nodding moves off the
#    array, i.e. it results in only two images.  Then the regions are
#    the full width or height, depending on the chop orientation.
#    -  Before addition, the origins of each identically sized frame
#    are set to 0,0.
#    -  It determines for the current recipe cycle the two nod positions
#    from the first two frames (nod to beam A then beam B) of the current
#    cycle.  Those coupled with the chop throw and angle, and the mosaic
#    centre specify the approximate locations of the sources for the
#    centroid locating.
#    -  The quality map is derived from the four sub-frames, with
#    recommended smoothing if argument SMOOTH>1.  It is the sum of the
#    pixel values divided by their absolute values, after changing sign
#    for the negative sources.  In the map +4 indicates that a pixel had
#    positive contributions from the positive images and negative signal
#    from the negative images; the desired quality is +2 for double
#    images.  Thus it helps to discriminate from sources that have been
#    chopped into view, for which there are no positive or negative
#    counterparts (values +/-2) or noise (0, +/-2) for four sources;
#    or (0, -2) for two sources.
#    -  The steering header CYCLE_NUMBER specifies the recipe cycle
#    number.
#    -  The smoothed and raw combined images, and the quality map may
#    be displayed.
#    -  The name of the combined frame is stored is the group user
#    header called COMBINED_SOURCE_FRAME.
#
# Output Data:
#    -  Combined source frame inheriting the group file's name but with the
#    _cab suffix.  The smoothed version has a _scab suffix.
#    -  The quality map inheriting the group file's name but with the
#    _qcab suffix.
#    -  The extracted sections about image within the mosaic, inheriting
#    the group file's name but with the suffices _Ap, _An, _Bp, _Bn for
#    the positive (p) and negative (n) images in the A and B beams.
#
# Tasks:
#    CCDPACK: MAKEMOS; KAPPA: BLOCK, MATHS, NDFCOPY, SETORIGIN.
#
# Deficiencies:
#    -  Assumes an ABBA pattern comprising two positive and two negative
#    images.  If the nodding and jitter are in the same direction it
#    is possible to have a double positive image and two negatives.
#    -  The group and frame management is tricky.   In part it's having
#    access to both steering and mosaic headers.  The created _cab frame
#    needs to be accessed within primitives directly rather than using
#    the current frame.
#
# Authors:
#    MJC: Malcolm J. Currie (JAC)
#
# Copyright:
#    Copyright (C) 2001--2004 Particle Physics and Astronomy Research
#    Council.  All Rights Reserved.
#
#-

# Selection
# =========

# This should only be performed on OBJECT frames.
    if ( $Frm->uhdr( "ORAC_OBSERVATION_TYPE" ) =~ /OBJECT/ &&
         $Frm->uhdr( "MAKE_MOSAIC" ) ) {

# Obtain the cycle number.  Default to zero if undefined, so that recipes
# which do not support this feature will continue to work.
       my $cycleno = $Frm->uhdr( "CYCLE_NUMBER" );
       $cycleno = defined( $cycleno ) ? $cycleno : 0;

# Select those members in the current cycle.
       my $cycleGrp = $Grp->subgrp( CYCLE_NUMBER => $cycleno );

# Arguments
# =========
# Obtain the value for the combination method.
       my $method = get_prim_arg( $_PRIM_ARGS_, "METHOD", "mean" );

# Determine whether or not to centroid.
       my $centroid = get_prim_arg( $_PRIM_ARGS_, "CENTROID", 1 );

# Determine whether or not to filter column and row patterns.
       my $clean = get_prim_arg( $_PRIM_ARGS_, "CLEAN", 0 );

# Determine whether or not to generate a quality map.
       my $qmap = get_prim_arg( $_PRIM_ARGS_, "QMAP", 0 );

# Determine whether or not to fill bad pixels.
       my $smoothbox =get_prim_arg( $_PRIM_ARGS_, "SMOOTH", 0 );

       my $aperture;
       if ( $centroid ) {

# Specify the aperture.  Want to approximate it to the size of the symmetric
# non-overlapping region about a source.  Place a lower limit to ensure
# that there is a window to find an object with poor co-ordinates.  Since
# the signals of the same sign are diametrically opposite this can be moderately
# large, but set it lower in case the chops and nods are small for a reason.
          $aperture = max( abs( $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" ) ),
                           abs( $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" ) ) );
          $aperture = min( $Frm->uhdr( "ORAC_CHOP_THROW" ), 2.0 * $aperture );
          $aperture = max( $aperture, 3 );
       }

# Frame preliminaries.
# ====================

# Obtain the frame containing the mosaic from which the combined image
# is to be generated.  First try the user header for the reference.
       my $in;
       my $mosFrm = $Grp->uhdr( "MOSAIC_FRAME" );
       if ( defined( $mosFrm ) ) {
          $in = $mosFrm->file;

       } else {

# Create a new frame containing the mosaic.  This is needed to find the
# frame centre.  Process the group file by default.
          $in = $Grp->file;
          $mosFrm = new $Frm;
          $mosFrm->file( $in );

# Propagate the headers.
          %{ $mosFrm->hdr } = %{ $Grp->hdr };
          %{ $mosFrm->uhdr } = %{ $Grp->uhdr };
       }

# Record original telescope offsets.
       my $mos_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
       my $mos_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );

# Find the nominal locations of the images.
# =========================================

# Find the bounds of the array, and hence its centre.
       my ( $xmid, $ymid );
       {
          my $Frm = $mosFrm;
          _GET_FRAME_CENTRE_
          $xmid = $_GET_FRAME_CENTRE_{XCENTRE};
          $ymid = $_GET_FRAME_CENTRE_{YCENTRE};
       }

# Find the limiting telescope offsets.  Obtain the telescope offsets
# and apply the rotation matrix to convert these to pixels.  Assume
# that the first two frames are at the A and B offsets.
       my ( $xpA, $xpB, $xnA, $xnB, $ypA, $ypB, $ynA, $ynB );
       my ( $x_chop_offset, $y_chop_offset, $x_nod_offset, $y_nod_offset );
       my ( $Ara_chop_offset, $Adec_chop_offset, $Bra_chop_offset, $Bdec_chop_offset );
       my ( $A_raoff, $A_decoff, $B_raoff, $B_decoff );
       my $first = 1;

# Form a new temporary group.
       my $tempGrp = new $Grp;
       $tempGrp->push( $cycleGrp->frame( 0 ) );
       $tempGrp->push( $cycleGrp->frame( 1 ) );

       foreach my $Frm ( $tempGrp->members ) {
          _GET_CARTESIAN_TELESCOPE_OFFSETS_
          $x_nod_offset = $_GET_CARTESIAN_TELESCOPE_OFFSETS_{XOFF};
          $y_nod_offset = $_GET_CARTESIAN_TELESCOPE_OFFSETS_{YOFF};

# Obtain the chop throw offsets.
          _GET_CHOP_OFFSETS_
          $x_chop_offset = $_GET_CHOP_OFFSETS_{XOFF};
          $y_chop_offset = $_GET_CHOP_OFFSETS_{YOFF};

# Obtain the source positions for the A beam.
# -------------------------------------------

# The first frame in $tempGrp is in the A beam and the second is in
# the B beam.
          if ( $first ) {
             $Ara_chop_offset = $_GET_CHOP_OFFSETS_{RAOFF};
             $Adec_chop_offset = $_GET_CHOP_OFFSETS_{DECOFF};

# Since the sense of the chop throw is not provided, we assume the ABBA
# convention.  Note we have to subtract the chop offsets to obtain the
# negative positions.
             $xpA = $xmid + $x_nod_offset;
             $ypA = $ymid + $y_nod_offset;
             $xnA = $xpA - $x_chop_offset;
             $ynA = $ypA - $y_chop_offset;

# Record telescope offsets for centroiding.
             $A_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
             $A_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );
             $first = 0;

# Obtain the source positions for the B beam.
# -------------------------------------------
          } else {

             $Bra_chop_offset = $_GET_CHOP_OFFSETS_{RAOFF};
             $Bdec_chop_offset = $_GET_CHOP_OFFSETS_{DECOFF};

# Since the sense of the chop throw is not provided, we assume the ABBA
# convention.  Note we have to subtract the chop offsets to obtain the
# positive positions.
             $xnB = $xmid + $x_nod_offset;
             $ynB = $ymid + $y_nod_offset;
             $xpB = $xnB - $x_chop_offset;
             $ypB = $ynB - $y_chop_offset;

# Record telescope offsets for centroiding.
             $B_raoff = $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET" );
             $B_decoff = $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET" );
          }
       }

# Validate the positions.
# =======================

# For certain offsets the counterpart image may be off the array, so
# instead of four images were are left with only one positive and negative
# pair.

# Determine the bounds of the array.
       $Mon{ "ndfpack_mon" }->obeyw( "ndftrace", "ndf=$in" );
       ( my $ORAC_STATUS, my @lbound ) = $Mon{ "ndfpack_mon" }->get( "ndftrace", "lbound" );
       ( $ORAC_STATUS, my @ubound ) = $Mon{ "ndfpack_mon" }->get( "ndftrace", "ubound" );

# Determine if the each of the four images lies within the array.
# Thus later in the primitive only those images within in the
# array are porcessed.
       my $vpA = $xpA > $lbound[ 0 ] && $xpA < $ubound[ 0 ] &&
                 $ypA > $lbound[ 1 ] && $ypA < $ubound[ 1 ];
       my $vpB = $xpB > $lbound[ 0 ] && $xpB < $ubound[ 0 ] &&
                 $ypB > $lbound[ 1 ] && $ypB < $ubound[ 1 ];
       my $vnA = $xnA > $lbound[ 0 ] && $xnA < $ubound[ 0 ] &&
                 $ynA > $lbound[ 1 ] && $ynA < $ubound[ 1 ];
       my $vnB = $xnB > $lbound[ 0 ] && $xnB < $ubound[ 0 ] &&
                 $ynB > $lbound[ 1 ] && $ynB < $ubound[ 1 ];

# Count the number of sources visible.
       my $nsource = $vpA + $vnA + $vpB + $vnB;

# Use approximate positions to find the centroids.
# ================================================
       my ( $sectionAp, $sectionAn, $sectionBp, $sectionBn );

# Initialise displacements from nominal centre of the ABBA pattern.
       my @disp = ( 0, 0 );

       {

# Want to find centroids within the mosaic.
          my $Frm = $mosFrm;

          if ( $centroid ) {

# Initialise displacement measures.
             my ( $centre, $init, $found );
             my $xdisp = 0;
             my $ydisp = 0;
             my $num_centroid = 0;

# Locate the centroid of the visible positive A image.  This uses the
# telescope offsets to locate the source.  Hence first set the telescope
# offsets to those of the A beam.
             if ( $vpA ) {
                $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $A_raoff  );
                $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $A_decoff );

                _FIND_SOURCE_CENTROID_ POSITIVE=1 BOXSIZE=$aperture

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.  The
# centroiding can fail without giving an error, hence there is a test
# that the position is defined.  When there is no centroid found, give a
# warning but carry on with nominal position.  Update the position with the
# centroid's co-ordinates.
                $found = $_FIND_SOURCE_CENTROID_{FOUND};
                $centre = $_FIND_SOURCE_CENTROID_{CENTRE};

                if ( $$found && defined( $$centre[ 0 ] ) ) {
                   $xpA = $$centre[ 0 ];
                   $ypA = $$centre[ 1 ];

# Find the pixel displacement between the source and its expected
# location and add to the sum of the displacements.
                   $init = $_FIND_SOURCE_CENTROID_{INIT};
                   $xdisp += $$centre[ 0 ] - $$init[ 0 ];
                   $ydisp += $$centre[ 1 ] - $$init[ 1 ];
                   $num_centroid++;

                } else {
                   orac_err "Unable to locate positive A-beam source for " .
                            "combination.\n";
                }
             }

# Locate the centroid of the visible negative A beam.  This is
# approximately displaced from the A positive by the negative chop throw.
             if ( $vnA ) {
                my $neg_Ara_chop_offset = -1 * $Ara_chop_offset;
                my $neg_Adec_chop_offset= -1 * $Adec_chop_offset;
                _FIND_SOURCE_CENTROID_ POSITIVE=0 BOXSIZE=$aperture RAOFF=$neg_Ara_chop_offset DECOFF=$neg_Adec_chop_offset

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.  The
# centroiding can fail without giving an error, hence there is a test
# that the position is defined.  When there is no centroid found, give a
# warning but carry on with nominal position.  Update the position with the
# centroid's co-ordinates.
                $found = $_FIND_SOURCE_CENTROID_{FOUND};
                $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
                if ( $$found && defined( $$centre[ 0 ] ) ) {
                   $xnA = $$centre[ 0 ];
                   $ynA = $$centre[ 1 ];

# Find the pixel displacement between the source and its expected
# location and add to the sum of the displacements.
                   $init = $_FIND_SOURCE_CENTROID_{INIT};
                   $xdisp += $$centre[ 0 ] - $$init[ 0 ];
                   $ydisp += $$centre[ 1 ] - $$init[ 1 ];
                   $num_centroid++;

                } else {
                   orac_err "Unable to locate negative A-beam source for " .
                            "combination.\n";
                }
             }

# Locate the centroid of the visible B negative image.  This uses the
# telescope offsets to locate the source.  Hence first set the telescope
# offsets to those of the B beam.
             if ( $vnB ) {
                $Frm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $B_raoff  );
                $Frm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $B_decoff );

                _FIND_SOURCE_CENTROID_ POSITIVE=0 BOXSIZE=$aperture

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.  The
# centroiding can fail without giving an error, hence there is a test
# that the position is defined.  When there is no centroid found, give a
# warning but carry on with nominal position.  Update the position with the
# centroid's co-ordinates.
                $found = $_FIND_SOURCE_CENTROID_{FOUND};
                $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
                if ( $$found && defined( $$centre[ 0 ] ) ) {
                   $xnB = $$centre[ 0 ];
                   $ynB = $$centre[ 1 ];

# Find the pixel displacement between the source and its expected
# location and add to the sum of the displacements.
                   $init = $_FIND_SOURCE_CENTROID_{INIT};
                   $xdisp += $$centre[ 0 ] - $$init[ 0 ];
                   $ydisp += $$centre[ 1 ] - $$init[ 1 ];
                   $num_centroid++;

                } else {
                   orac_err "Unable to locate negative B-beam source for " .
                            "combination.\n";
                }
             }

# Locate the centroid of the visible positive B beam image.  This is
# approximately displaced from the B negative by the negative chop throw.
             if ( $vpB ) {
                my $neg_Bra_chop_offset = -1 * $Bra_chop_offset;
                my $neg_Bdec_chop_offset = -1 * $Bdec_chop_offset;
                _FIND_SOURCE_CENTROID_ POSITIVE=1 BOXSIZE=$aperture RAOFF=$neg_Bra_chop_offset DECOFF=$neg_Bdec_chop_offset

# It is possible that no centroid was found.  Get a reference to the flag,
# test the status, and report an error where centroiding failed.  The
# centroiding can fail without giving an error, hence there is a test
# that the position is defined.  When there is no centroid found, give a
# warning but carry on with nominal position.  Update the position with the
# centroid's co-ordinates.
                $found = $_FIND_SOURCE_CENTROID_{FOUND};
                $centre = $_FIND_SOURCE_CENTROID_{CENTRE};
                if ( $$found && defined( $$centre[ 0 ] ) ) {
                   $xpB = $$centre[ 0 ];
                   $ypB = $$centre[ 1 ];

# Find the pixel displacement between the source and its expected
# location and add to the sum of the displacements.
                   $init = $_FIND_SOURCE_CENTROID_{INIT};
                   $xdisp += $$centre[ 0 ] - $$init[ 0 ];
                   $ydisp += $$centre[ 1 ] - $$init[ 1 ];
                   $num_centroid++;

                } else {
                   orac_err "Unable to locate positive B-beam source for " .
                            "combination.\n";
                }
             }

# Determine the mean displacements from the nominal positions, and
# report the displacements.
             if ( $num_centroid > 0 ) {
                $xdisp /= $num_centroid;
                $ydisp /= $num_centroid;
                my $fs_x = sprintf( "%.2f", $xdisp );
                my $fs_y = sprintf( "%.2f", $ydisp );

                orac_print "Target displaced ($fs_x,$fs_y) pixels from " .
                           "nominal position.\n";

# For storage correct to the nearest pixel.  Record the displacements.
                my $xbase = nint( $xdisp );
                my $ybase = nint( $ydisp );
                @disp = ( $xbase, $ybase );

# File the base location in the calibration system.
# =================================================

# The value needs to be in a hash.  Use the current frame as a reference
# for this, as it has the same readout mode and speed/well depth as the
# others.
                my %hash = ( %{ $Frm->hdr }, BASESHIFT => \@disp );
                $Cal->baseshiftindex->add( $Frm->file, \%hash );

                orac_print "Base shift filed with the calibration system.\n";
             }

# Obtain the displacement from the calibration.
          } else {

# First attempt to obtain the value from the calibration system.
# If it's successful extract the x and y displacements, of which there
# must be two, and shift the nominal positions, otherwise use the current
# values.  Quicker to just apply shifts to all position and not test for
# visibility.
             my $base = eval { $Cal->baseshift };
             if ( !$@ ) {
                @disp = @$base;
                if ( $#disp == 1 ) {
                   $xpA += $disp[ 0 ];
                   $ypA += $disp[ 1 ];
                   $xnA += $disp[ 0 ];
                   $ynA += $disp[ 1 ];
                   $xpB += $disp[ 0 ];
                   $ypB += $disp[ 1 ];
                   $xnB += $disp[ 0 ];
                   $ynB += $disp[ 1 ];
                }
             }
          }

# Find bounds of regions about images.
# ====================================

# Derive the bounds of four equal-sized rectangles centred on each
# positive and negative image for four images, or two equal-sized
# rectangles where there are only two images of the source.  We could
# access the chop rotation angle, but it's simpler to decide on the
# position (quadrant) of the positive A signal.
#
# This combination loses sub-pixel registration, but should be adequate
# for aperture photometry.  This is also somewhat smaller than the
# telescope pointing errors.

# The sense of divisions depends on the chop angle.  Below makes an
# assumption regarding the orientation, being either 0, or +/-90 degrees.
          my ( $halfx, $halfy );
          my $chopangle = ( $Frm->uhdr( "ORAC_CHOP_ANGLE" ) || 0 );

# Chop orientation 0 degrees.
# ---------------------------
          if ( abs( $chopangle ) < 45 ) {

# Get width for four sources.
             if ( $vpA && $vnA ) {
                $halfx = 0.5 * abs( $xpA - $xnA );

# Get width for double source.
             } else {
                $halfx = 0.5 * ( $ubound[ 0 ] - $lbound[ 0 ] + 1 );
             }

# Get height for four sources.
             if ( $vpA && $vnB ) {
                $halfy = 0.5 * abs( $ypA - $ynB );

# Get height for two sources.
             } else {
                $halfy = 0.5 * ( $ubound[ 1 ] - $lbound[ 1 ] + 1 );
             }

# Chop orientation +/-90 degrees
# ------------------------------
          } else {

# Get width for four sources.
             if ( $vpA && $vnB ) {
                $halfx = 0.5 * abs( $xpA - $xnB );

# Get width for double source.
             } else {
                $halfx = 0.5 * ( $ubound[ 0 ] - $lbound[ 0 ] + 1 );
             }

# Get height for four sources.
             if ( $vpA && $vnA ) {
                $halfy = 0.5 * abs( $ypA - $ynA );

# Get height for two sources.
             } else {
                $halfy = 0.5 * ( $ubound[ 1 ] - $lbound[ 1 ] + 1 );
             }
          }

# For two source images we assume that they divide left-right or
# top-bottom.
          my ( $xmidisp, $ymidisp, $width, $height );
          if ( $nsource < 4 ) {

# Correct the centre for the displacement obtained from the calibration
# system or obtained by centroiding.
             $xmidisp = $xmid + $disp[ 0 ];
             $ymidisp = $ymid + $disp[ 1 ];

# Have symmetric regions centred on the source's nominal position.
#             $width = min( $xmidisp - $lbound[ 0 ], $ubound[ 0 ] - $xmidisp );
#             $height = min( $ymidisp - $lbound[ 1 ], $ubound[ 1 ] - $ymidisp );
              $width = 2 * int( $halfx );
              $height = 2 * int( $halfy );
          }

# Create an NDF bounds string for the positive A beam.
# ----------------------------------------------------
          my ( $x_lbnd, $y_lbnd, $x_ubnd, $y_ubnd );

# Only define bounds for a visible positive A-beam image of the
# source.
          if ( $vpA ) {
             $x_lbnd = int( $xpA - $halfx );
             $y_lbnd = int( $ypA - $halfy );
             $x_ubnd = int( $xpA + $halfx );
             $y_ubnd = int( $ypA + $halfy );

# Correct the default bounds for two sources.  First for 0-degree
# chop orientation.  The relative location of the counterpart negative
# image decides whether the positive image is to the left or right.  The
# division between left and right is at the effective (displaced) centre.
             if ( $nsource == 2 ) {
                if ( abs( $chopangle ) < 45 ) {
                   if ( ( ( $xpA > $xnA ) && $vnA ) ||
                        ( ( $xpA > $xnB ) && $vnB ) ) {
                      $x_lbnd = $xmidisp;
                      $x_ubnd = $x_lbnd + $width - 1;
                   } else {
                      $x_ubnd = $xmidisp;
                      $x_lbnd = $x_ubnd - $width + 1;
                   }

# For +/-90-degree chop orientation.  The relative location of the
# counterpart negative image decides whether the positive image is to
# the top or bottom.  The division between top and bottom is at the
# effective (displaced) centre.
                } else {
                   if ( ( ( $ypA > $ynA ) && $vnA ) ||
                        ( ( $ypA > $ynB ) && $vnB ) ) {
                      $y_lbnd = $ymidisp;
                      $y_ubnd = $y_lbnd + $height - 1;
                   } else {
                      $y_ubnd = $ymidisp;
                      $y_lbnd = $y_ubnd - $height + 1;
                   }
                }
             }

# Define an NDF section for the positive A beam.
             $sectionAp = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";
          }

# Create an NDF bounds string for the negative A beam.
# ----------------------------------------------------

# Only define bounds for a visible negative A-beam image of the
# source.
          if ( $vnA ) {
             $x_lbnd = int( $xnA - $halfx );
             $y_lbnd = int( $ynA - $halfy );
             $x_ubnd = int( $xnA + $halfx );
             $y_ubnd = int( $ynA + $halfy );

# Correct the default bounds for two sources.  First for 0-degree
# chop orientation.  The relative location of the counterpart positive
# image decides whether the negative image is to the left or right.  The
# division between left and right is at the effective (displaced) centre.
             if ( $nsource == 2 ) {
                if ( abs( $chopangle ) < 45 ) {
                   if ( ( ( $xnA > $xpA ) && $vpA ) ||
                        ( ( $xnA > $xpB ) && $vpB ) ) {
                      $x_lbnd = $xmidisp;
                      $x_ubnd = $x_lbnd + $width - 1;
                   } else {
                      $x_ubnd = $xmidisp;
                      $x_lbnd = $x_ubnd - $width + 1;
                   }

# For +/-90-degree chop orientation.  The relative location of the
# counterpart positive image decides whether the negative image is to
# the top or bottom.  The division between top and bottom is at the
# effective (displaced) centre.
                } else {
                   if ( ( ( $ynA > $ypA ) && $vpA ) ||
                        ( ( $ynA > $ypB ) && $vpB ) ) {
                      $y_lbnd = $ymidisp;
                      $y_ubnd = $y_lbnd + $height - 1;
                   } else {
                      $y_ubnd = $ymidisp;
                      $y_lbnd = $y_ubnd - $height + 1;
                   }
                }
             }

# Define an NDF section for the negative A beam.
             $sectionAn = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";
          }

# Create an NDF bounds string for the positive B beam.
# ----------------------------------------------------

# Only define bounds for a visible positive B-beam image of the
# source.
          if ( $vpB ) {
             $x_lbnd = int( $xpB - $halfx );
             $y_lbnd = int( $ypB - $halfy );
             $x_ubnd = int( $xpB + $halfx );
             $y_ubnd = int( $ypB + $halfy );

# Correct the default bounds for two sources.  First for 0-degree
# chop orientation.  The relative location of the counterpart negative
# image decides whether the positive image is to the left or right.  The
# division between left and right is at the effective (displaced) centre.
             if ( $nsource == 2 ) {
                if ( abs( $chopangle ) < 45 ) {
                   if ( ( ( $xpB > $xnB ) && $vnB ) ||
                        ( ( $xpB > $xnA ) && $vnA ) ) {
                      $x_lbnd = $xmidisp;
                      $x_ubnd = $x_lbnd + $width - 1;
                   } else {
                      $x_ubnd = $xmidisp;
                      $x_lbnd = $x_ubnd - $width + 1;
                   }

# For +/-90-degree chop orientation.  The relative location of the
# counterpart negative image decides whether the positive image is to
# the top or bottom.  The division between top and bottom is at the
# effective (displaced) centre.
                } else {
                   if ( ( ( $ypB > $ynB ) && $vnB ) ||
                        ( ( $ypB > $ynA ) && $vnA ) ) {
                      $y_lbnd = $ymidisp;
                      $y_ubnd = $y_lbnd + $height - 1;
                   } else {

                      $y_ubnd = $ymidisp;
                      $y_lbnd = $y_ubnd - $height + 1;
                   }
                }
             }

# Define an NDF section for the positive B beam.
             $sectionBp = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";
          }

# Create an NDF bounds string for the negative B beam.
# ----------------------------------------------------

# Only define bounds for a visible negative B-beam image of the
# source.
          if ( $vnB ) {
             $x_lbnd = int( $xnB - $halfx );
             $y_lbnd = int( $ynB - $halfy );
             $x_ubnd = int( $xnB + $halfx );
             $y_ubnd = int( $ynB + $halfy );

# Correct the default bounds for two sources.  First for 0-degree
# chop orientation.  The relative location of the counterpart positive
# image decides whether the negative image is to the left or right.  The
# division between left and right is at the effective (displaced) centre.
             if ( $nsource == 2 ) {
                if ( abs( $chopangle ) < 45 ) {
                   if ( ( ( $xnB > $xpB ) && $vpB ) ||
                        ( ( $xnB > $xpA ) && $vpA ) ) {
                      $x_lbnd = $xmidisp;
                      $x_ubnd = $x_lbnd + $width - 1;
                   } else {
                      $x_ubnd = $xmidisp;
                      $x_lbnd = $x_ubnd - $width + 1;
                   }

# For +/-90-degree chop orientation.  The relative location of the
# counterpart positive image decides whether the negative image is to
# the top or bottom.  The division between top and bottom is at the
# effective (displaced) centre.
                } else {
                   if ( ( ( $ynB > $ypB ) && $vpB ) ||
                        ( ( $ynB > $ypA ) && $vpA ) ) {
                      $y_lbnd = $ymidisp;
                      $y_ubnd = $y_lbnd + $height - 1;
                   } else {
                      $y_ubnd = $ymidisp;
                      $y_lbnd = $y_ubnd - $height + 1;
                   }
                }
             }

# Define an NDF section for the negative B beam.
             $sectionBn = "($x_lbnd:$x_ubnd,$y_lbnd:$y_ubnd)";
          }

# End of new $Frm context.
       }

# Restore the original telescope offsets for the mosaic.
       $mosFrm->uhdr( "ORAC_RA_TELESCOPE_OFFSET", $mos_raoff  );
       $mosFrm->uhdr( "ORAC_DEC_TELESCOPE_OFFSET", $mos_decoff );

# Remove column and row structure.
# ================================
       if ( $clean ) {
          my $Frm = $mosFrm;
          _REMOVE_COLUMN_ROW_STRUCTURE_
          $in = $Frm->file;
       }

# Extract the visible sections.
# =============================

# There is a problem in that the $Grp user headers contain updated end
# time, end airmass, and integrated exposure time.  If we update
# $Frm->file with $in---the group file---that gives the correct
# steering headers, but lacks the revised group headers.  On the other
# hand, using the $mosFrm gets the revised data but loses the steering
# headers.  The former while on the face of it is easier, it does have
# side effects, since the original mainline frame is lost (and is needed
# for things like tidying).  Choose the latter to preserve the steering
# operations.  Primitives requiring the combined frame should access it
# through the COMBINED_SOURCE_FRAME group user header, but steer using
# the mainline frame.

# Define the name for the positive A beam.  Create a new image
# which is the section approximately centred about that beam's
# nominal location.  Set the origin to 1,1 for the arithmetic
# later.
       my ( $param, $Ap_name, $An_name, $Bp_name, $Bn_name );
       if ( $vpA ) {
          $Ap_name = $in . "_Ap";
          $param = "in=$in$sectionAp out=$Ap_name";
          $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
          $param = "ndf=$Ap_name origin=[1,1]";
          $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
          orac_print "Positive A-beam image extracted in $Ap_name\n";
       }

# Repeat for the negative A beam.
       if ( $vnA ) {
          $An_name = $in . "_An";
          $param = "in=$in$sectionAn out=$An_name";
          $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
          $param = "ndf=$An_name origin=[1,1]";
          $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
          orac_print "Negative A-beam image extracted in $An_name\n";
       }

# Repeat for the negative A beam.
       if ( $vpB ) {
          $Bp_name = $in . "_Bp";
          $param = "in=$in$sectionBp out=$Bp_name";
          $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
          $param = "ndf=$Bp_name origin=[1,1]";
          $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
          orac_print "Positive B-beam image extracted in $Bp_name\n";
       }

# Repeat for the negative B beam.
       if ( $vnB ) {
          $Bn_name = $in . "_Bn";
          $param = "in=$in$sectionBn out=$Bn_name";
          $Mon{ "ndfpack_mon" }->obeyw( "ndfcopy", "$param" );
          $param = "ndf=$Bn_name origin=[1,1]";
          $Mon{ "ndfpack_mon" }->obeyw( "setorigin", "$param" );
          orac_print "Negative B-beam image extracted in $Bn_name\n";
       }

# Form quality map.
# =================

# Smooth the combined image.
# ==========================
       my $out;
       if ( $qmap ) {
          if ( $smoothbox > 1 ) {

# Block-averaged smooth using the supplied box size for each visible
# positive and negative section, and assign each new name to the
# corresponding original variable.
             if ( $vpA ) {
                $in = $Ap_name;
                $out = $in . "_sm";
                $param = "in=$in out=$out box=$smoothbox accept";
                $Mon{ "kappa_mon" }->obeyw( "block", "$param" );
                $Ap_name = $out;
             }

             if ( $vpB ) {
                $in = $Bp_name;
                $out = $in . "_sm";
                $param = "in=$in out=$out box=$smoothbox accept";
                $Mon{ "kappa_mon" }->obeyw( "block", "$param" );
                $Bp_name = $out;
             }

             if ( $vnA ) {
                $in = $An_name;
                $out = $in . "_sm";
                $param = "in=$in out=$out box=$smoothbox accept";
                $Mon{ "kappa_mon" }->obeyw( "block", "$param" );
                $An_name = $out;
             }

             if ( $vnB ) {
                $in = $Bn_name;
                $out = $in . "_sm";
                $param = "in=$in out=$out box=$smoothbox accept";
                $Mon{ "kappa_mon" }->obeyw( "block", "$param" );
                $Bn_name = $out;
             }
          }

# Generate name Quality of Combined A and B signals
          ( $in, $out ) = $mosFrm->inout( "_qcab" );
          my $expr = "exp='0";
          $expr .= "+IA/abs(IA)" if ( $vpA );
          $expr .= "+IB/abs(IB)" if ( $vpB );
          $expr .= "+IC/abs(IC)" if ( $vnA );
          $expr .= "+ID/abs(ID)" if ( $vnB );
          $expr .= "'";

          $param = "$expr out=$out ia=$Ap_name ib=$Bp_name ic=$An_name id=$Bn_name";
          $Mon{ "kappa_mon" }->obeyw( "maths", "$param" );
          orac_print "Source images combined to form quality map in $out\n";

# Display the quality map using a temporary frame.
          my $tmpFrm = $Frm->new;
          $tmpFrm->file( $out );
          $Display->display_data( $tmpFrm ) if ( defined $Display );
       }

# Combine the images.
# ===================

# At present there's no sub-pixel registration.
       ( $in, $out ) = $mosFrm->inout( "_cab" );

# Mean is easy.  Form image expression using visible source images
# and create a list of parameters for those images.  Normalise by
# the number of visible source images.
       if ( $method eq "mean" ) {
          my $expr = "exp='1.0/${nsource}*(";
          my $namepar = "";
          if ( $vpA ) {
             $expr .= "IA";
             $namepar .= "ia=$Ap_name "
          }
          if ( $vnA ) {
             $expr .= "-IB";
             $namepar .= "ib=$An_name "
          }
          if ( $vpB ) {
             $expr .= "+IC";
             $namepar .= "ic=$Bp_name "
          }
          if ( $vnB ) {
             $expr .= "-ID";
             $namepar .= "id=$Bn_name "
          }
          $expr .= ")'";

          $param = "$expr out=$out $namepar";
          $Mon{ "kappa_mon" }->obeyw( "maths", "$param" );
          orac_print "Source images combined and averaged in $out\n";

# Other methods are for MAKEMOS.
       } else {

# First need to make a temporary frame change the polarity of the
# each visible negative source.
          my ( $tempAfile, $tempApos, $tempBfile, $tempBpos );
          if ( $vnA ) {
             $tempAfile = new ORAC::TempFile;
             $tempApos = $tempAfile->file;
             $param = "in=$An_name out=$tempApos scalar=-1";
             $Mon{ "kappa_mon" }->obeyw( "cmult", "$param" );
          }

          if ( $vnB ) {
             $tempBfile = new ORAC::TempFile;
             $tempBpos = $tempBfile->file;
             $param = "in=$Bn_name out=$tempBpos scalar=-1";
             $Mon{ "kappa_mon" }->obeyw( "cmult", "$param" );
          }

# Create text files to hold the list of input and output files, one per
# line.  This is needed because expanded lists of files may make the
# command line too long for the ADAM message system.  Only include the
# visible images.
          unlink( "combine.list$$" );
          my @names = ();
          push( @names, $Ap_name ) if $vpA;
          push( @names, $tempApos ) if $vnA;
          push( @names, $Bp_name ) if $vpB;
          push( @names, $tempBpos ) if $vnB;

          open( my $fh_inlist, ">combine.list$$" ) ||
            orac_throw "Unable to open combine.list$$ to create a list of frames to combine.  Error: $!.\n";
          print $fh_inlist join( "\n", @names ), "\n";
          close( $fh_inlist );

# Combine the now all positive frames using the chosen method.
# Assign other parameters.
          my $param1 = "in='^combine.list$$' title=!";
          $param = "out=$out zero optov=$nsource method=$method";

# Make the mosaic correcting for differences in offset.
          $Mon{ "ccdpack_reg" }->obeyw( "makemos", "$param1 $param" );
          unlink( "combine.list$$" );

          orac_print "Source images combined using the $method method in $out\n";
       }

# Update the frame.
       $mosFrm->file( $out );

# Display the combined frame.
       $Display->display_data( $mosFrm ) if ( defined $Display );

# Smooth the combined image.
# ==========================
       if ( $smoothbox > 1 ) {

# At present there's no sub-pixel registration.
          ( $in, $out ) = $mosFrm->inout( "_scab" );

# Block-averaged smooth using the supplied box size.
          $param = "in=$in out=$out box=$smoothbox accept";
          $Mon{ "kappa_mon" }->obeyw( "block", "$param" );

          orac_print "Combined image ${smoothbox}-pixel block smoothed in $out\n\n";

# Update the frame.
          $mosFrm->file( $out );

# Display the combined frame.
          $Display->display_data( $mosFrm ) if ( defined $Display );
       }

# Store the frame for other primitives (e.g. photometry, polarimetry)
# requiring it.
       $Grp->uhdr( "COMBINED_SOURCE_FRAME", $mosFrm );

       orac_print "\n";
    }

# Podule
# ======

=head1 NAME

_COMBINE_CHOPPED_SOURCE_ -- Combines chopped and nodded images for NOD_CHOP recipes.

=head1 DESCRIPTION

This primitive forms a combined source file from the current group
file.  It expects the group file to be an integrated chopped and
nodded image, in which the source appears as two positive and two
negative images, or as a single positive and negative pair of
images.  The primitive optionally locates the centroid of each
each source, and extracts a symmetric region about each source.
These regions are combined (see argument METHOD) to create an
image of the source of twice (or root 2 for dual images) the
signal-to-noise of a single image, but normalised to yield the
average signal of a single image.  This maintains the scaling of
flux per unit exposure time.

The primitive also forms a quality map indicating the contributions
from each image of the source to help interpret the final combined
frame.

=head1 ARGUMENTS

=over 4

=item CENTROID = LOGICAL (Given)

If true (1), centroid on the source in each sub-frame before
combining.  If successful, the resultant combined file has the
source centred.  Centroiding is not suitable for objects near
the detection limit or amorphous extended source.  Setting
CENTROID to false (0), means the combined file is centred about
the expected position of the source.  [1]

=item CLEAN = LOGICAL (Given)

If true (1), column then row patterns, say due to pickup or
bias variations, are filtered out by subtracting the median
of each column or row from all the values in that column or
row.  It's useful to help see faint sources.  [0]

=item METHOD = CHARACTER (Given)

The method used to combine frames, once all have the same
polarity.  See parameter METHOD of CCDPACK/MAKEMOS (SUN/139) for
the options.  The main two in practice will be "Median" or
"Mean".  The former excludes outliers but has problems in good
seeing where the registration is poor, as it biases against the
peak values of the steepening profile near the core, and hence
underestimate the flux.  In this circumstance the mean blurs the
psf profile, making it more of a plateau than a sharp peak.
However, the mean preserves the flux, at the cost of the odd
rogue value affecting the result.  ["Mean"]

=item QMAP = LOGICAL (Given)

If true (1), a quality map is generated. [0]

=item SMOOTH = INTEGER (Given)

If greater than 1 apply block smoothing with a square block size
equal to SMOOTH to the combined image.  For all other values,
there is no smoothing. [0]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable for Michelle in imaging mode.

=item *

Processing only occurs for object frames, and when the steering header
MAKE_MOSAIC is true.

=item *

The file to be combined may be specified through group user header
MOSAIC_FRAME, if $Grp->file is not the file from which to combine
images.

=item *

The centroid is found by first setting the initial positions to
the telescope offset in Cartesian co-ordinates for each nod position
from the centre of the mosaic, and using a search window equal
to the larger absolute telescope offset.  The telescope offsets are
derived from the first and second frames in the current-cycle group.

=item *

The average offsets of the centroid positions from the nominal
source locations are found; the nearest-integer offsets are stored
in $Cal-E<gt>baseshift.  When argument CENTROID is false,
$Cal-E<gt>>baseshift is accessed, and if there is a valid shift vector,
the script offsets the nominal position of each region by this
vector.  This is to allow for misplaced instrument apertures
whenever the weak flux prevents centroiding.

=item *

The regions are made as large as possible such that there is no
duplication of pixels from the original group file.  In other words the
regions extend to the midpoints of the chop throw and nod offsets. User
header ORAC_CHOP_ANGLE is used to select one of two orientations (0 or
+/-90 degrees) to derive the x-y half-widths of the regions.  The
exception occurs when the nodding moves off the array, i.e. it results in
only two images.  Then the regions are the full width or height, depending
on the chop orientation.

=item *

Before addition, the origins of each identically sized frame
are set to 0,0.

=item *

It determines for the current recipe cycle the two nod positions
from the first two frames (nod to beam A then beam B) of the current
cycle.  Those coupled with the chop throw and angle, and the mosaic
centre specify the approximate locations of the sources for the
centroid locating.

=item *

The quality map is derived from the four sub-frames, with recommended
smoothing if argument SMOOTH>1.  It is the sum of the pixel values divided
by their absolute values, after changing sign for the negative sources.
In the map +4 indicates that a pixel had negative sources.  In the map +4
indicates that a pixel had positive contributions from the positive images
and negative signal from the negative images; the desired quality is +2
for double images.  Thus it helps to discriminate from sources that have
been chopped into view, for which there are no positive or negative
counterparts (values +/-2) or noise (0, +/-2) for four sources; or (0, -2)
for two sources.

=item *

The steering header CYCLE_NUMBER specifies the recipe cycle
number.

=item *

The smoothed and raw combined images, and the quality map may be
displayed.

=item *

The name of the combined frame is stored is the group user
header called COMBINED_SOURCE_FRAME.

=back

=head1 OUTPUT DATA

=over 4

=item *

Combined source frame inheriting the group file's name but with the
_cab suffix.  The smoothed version has a _scab suffix.

=item *

The quality map inheriting the group file's name but with the
_qcab suffix.

=item *

The extracted sections about image within the mosaic, inheriting
the group file's name but with the suffices _Ap, _An, _Bp, _Bn for
the positive (p) and negative (n) images in the A and B beams.

=back

=head1 TASKS

CCDPACK: MAKEMOS; KAPPA: BLOCK, MATHS, NDFCOPY, SETORIGIN.

=head1 DEFICIENCIES

=over 4

=item

Assumes an ABBA pattern comprising two positive and two negative
images.  If the nodding and jitter are in the same direction it
is possible to have a double positive image and two negatives.

=item *

The group and frame management is tricky.   In part it's having
access to both steering and mosaic headers.  The created _cab frame
needs to be accessed within primitives directly rather than using
the current frame.

=back

=head1 AUTHORS

MJC: Malcolm J. Currie (JAC)

=head1 COPYRIGHT

Copyright (C) 2001--2004 Particle Physics and Astronomy Research
Council.  All Rights Reserved.

=cut
