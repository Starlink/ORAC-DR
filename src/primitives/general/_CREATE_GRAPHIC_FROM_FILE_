# -*-cperl-*-

=head1 NAME

_CREATE_GRAPHIC_FROM_FILE_ - Create a PNG, GIF, or JPG graphic from a
given file.

=head1 DESCRIPTION

This primitive creates a PNG, GIF, or JPG graphic from the supplied
file. It currently only supports one- and two-dimenensional files.

=head1 ARGUMENTS

=over 4

=item ADDRES = LOGICAL (Given)

Whether or not to append the resolution to the filename. If true, the
output filename will have the form <file>_<xres>x<yres>.<type>, or if
the XRES and YRES parameters are equal, <file>_<xres>.<type>. [0]

=item FILE = CHARACTER (Given)

The name of the file to convert to the given graphic file. Must be
given.

=item OUTROOT = CHARACTER (Given)

The root output filename, if it needs to differ from FILE. [FILE]

=item PRODUCT = STRING (Given)

The product name used for writing a keyword in the PNGs.  The default is
the value of the PRODUCT keyword for the input file supplied by
argument FILE.  If that is absent it defaults to "reduced".  [].

=item PRODUCTID = STRING (Given)

The productID used for writing a keyword in the PNGs. No default
value. If not present the header will not be written. []

=item TYPE = CHARACTER (Given)

The type of graphic to create. Can be gif, jpg, or png. ['gif']

=item VECTOR_FILE = CHARACTER (Given)

A FITS file generated by POLPACK containing polarisation vectors to
plot over the image.  VECTOR_FILE is ignored if the file does not
exist or if FILE is one-dimensional.

=item EXTENTS = CHARACTER (Given)

A clump sdf file generated by cupid findclumps, containing clumps
to be contoured on top of the input file. (Only done if FILE is
a map). Each clump will be contoured in a separate .png file.

=item POINTCAT = CHARACTER (Given)

A FITS catalog of point sources, which will can be plotted with
listshow on top a map of the input FILE. (Only created if FILE is a map).
The catalogue is plotted in a separate .png file which can be combined
with the base map using e.g. image magick.

=item XRES = INTEGER (Given)

The number of pixels along the x-axis of the output graphic file.
This can be a comma-seapatated list to produce graphic files at a
series of sizes.   [64]

=item YRES = INTEGER (Given)

The number of pixels along the y-axis of the output graphic file.
This can be a comma-seapatated list to produce graphic files at a
series of sizes.  If it is undefined a square graphic is assumed
using XRES to set the size.  [undef]

=item SIGHIGH = FLOAT (Given)

The number of standard deviations above the mean to set scale high
to when plotting using display. Only used if SIGLOW is also given.
Display will usually use mode=faint otherwise.

=item SIGLOW = FLOAT (Given)

The number of standard deviations below the mean to set scale low
to when plotting using display. Only used if SIGLOW is also given.
Display will usually use mode=faint otherwise.

=item TEXT_OVERLAY = CHARACTER (Given)

Text to be overlaid. [undef]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable only for one-dimensional and two-dimensional input files.

=item *

Each graphic file will have the same root filename as the input file,
unless the OUTROOT argument is given, with the appropriate file extension.

A polarisation vector overlay graphic file has an additional "_vector"
between the root name and the number of pixels.

=item *

Various metadata are written to the graphics files.

=over 4

=item *

astro:RA  Centre right ascension

=item *

astro:Dec  Centre declination

=item *

astro:name  The object's name (taken from the OBJECT header)

=item *

jsa:product  The product type (derived from the input files PRODUCT header)

=item *

jsa:productID  The productID combining the product and subsystem information.

=item *

astro:orientation  Orientation in degrees

=item *

astro:pixelScale  Pixel size of the PNG in arcseconds

=back

=item *

The picture should be in greyscale if the MAKE_GREYSCALE_THUMBNAILS uhdr is
set to a true value.

=back

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>
Malcolm J. Currie E<lt>mjc@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2009,2014 Science and Technology Facilities Council.  All
Rights Reserved.

=cut

use ORAC::Bounds qw/ retrieve_bounds /;


# Arguments
# ==========

my $file = get_prim_arg( $_PRIM_ARGS_, 'FILE', undef );
if( ! defined( $file ) ) {
  orac_throw "Programming error: Must supply FILE parameter to _CREATE_GRAPHIC_FROM_FILE_.";
}

my $vector_file = get_prim_arg( $_PRIM_ARGS_, 'VECTOR_FILE', undef );

# Obtain the product name from the file's headers..
my $tmpFrm = new $Frm;
$tmpFrm->file( $file );
my $file_product = defined( $tmpFrm->hdr( "PRODUCT" ) ) ? $tmpFrm->hdr( "PRODUCT" ) : "reduced";

my $addres = get_prim_arg( $_PRIM_ARGS_, 'ADDRES', 0 );
my $product = get_prim_arg( $_PRIM_ARGS_, 'PRODUCT', $file_product );
my $productID = get_prim_arg( $_PRIM_ARGS_, 'PRODUCTID', undef );
my $type = uc( get_prim_arg( $_PRIM_ARGS_, 'TYPE', 'GIF' ) );
my $xres = get_prim_arg( $_PRIM_ARGS_, 'XRES', 64 );
my $yres = get_prim_arg( $_PRIM_ARGS_, 'YRES', undef );
$yres = $xres if ( !defined( $yres ) );
my $outroot = get_prim_arg( $_PRIM_ARGS_, 'OUTROOT', $file );

# Get catalogue files and overlay text.
my $extents = get_prim_arg( $_PRIM_ARGS_, 'EXTENTS', undef);
my $pointcat = get_prim_arg( $_PRIM_ARGS_, 'POINTCAT', undef);
my $text_overlay = get_prim_arg( $_PRIM_ARGS_, 'TEXT_OVERLAY', undef);

# Get plotting options
my $siglow = get_prim_arg( $_PRIM_ARGS_, 'SIGLOW', undef);
my $sighigh = get_prim_arg( $_PRIM_ARGS_, 'SIGHIGH', undef);

# Convert list of X resolutions an array.
if ( ref( $xres ) eq 'ARRAY' ) { $xres = join( ",", @{ $xres } ) }
my @resx = split( ',', $xres );
if ( ref( $yres ) eq 'ARRAY' ) { $yres = join( ",", @{ $yres } ) }
my @resy = split( ',', $yres );

my $nx = scalar( @resx );
my $ny = scalar( @resy );
if ( $nx > $ny ) {
   for ( my $i = $ny + 1; $i <= $nx; $i++ ) {
       $resx[ $i - 1 ] = $resy[ $i - 1 ];
   }
} elsif ( $ny > $nx ) {
   for ( my $i = $nx + 1; $i <= $ny; $i++ ) {
       $resy[ $i - 1 ] = $resx[ $i - 1 ];
   }
}


# Suggest possible locations for image magick convert?
my $IMCONVERT = "/usr/local/bin/convert";
unless (-e $IMCONVERT) {
  $IMCONVERT = "/usr/bin/convert";
  unless (-e $IMCONVERT) {
    $IMCONVERT = "";
  }
}
# Check for abnormal data
# =======================

# Use STATS to flag if this is not a frame with constant values.
# Set min and max to some range, since a 0-range stretch can
# crash the display routines.
my $zerorange = 0;
$Mon{kappa_mon}->obeyw( "stats", "ndf=$file" );
my ( $ORAC_STATUS, $sigma ) = $Mon{kappa_mon}->get( "stats", "sigma" );
( $ORAC_STATUS, my $max ) = $Mon{kappa_mon}->get( "stats", "maximum" );
( $ORAC_STATUS, my $min ) = $Mon{kappa_mon}->get( "stats", "minimum" );
( $ORAC_STATUS, my $mean ) = $Mon{kappa_mon}->get( "stats", "mean" );
if ( $sigma == 0 ) {
   $min += -1;
   $max +=  1;
   $zerorange = 1;
   orac_warn "...All pixels in ${file} have the same value.";
}

# Check to see if we're one-dimensional or two-dimensional.
_GET_DIMENSIONS_ FILE=$file
my $dims = $_GET_DIMENSIONS_{DIMS};
my @nondegen = grep { $_ != 1 } @$dims;

if ( $#nondegen > 1 ) {
   orac_warn "Programming error: cannot create graphic from file that's not one- or two-dimensional.\n";
   return ORAC__OK;
}

# Create the graphic
# ==================
my $exif = undef;
my $tempimg = 'temp_image_for_device';
for ( my $i = 0; $i < $nx; $i++ ) {
   my ( $outfile, $outvecfile, $outclumpfile, $outcatfile, $outtextfile, $params );
   my $xres = $resx[ $i ];
   my $yres = $resy[ $i ];

# Only do this processing if we have KAPPA v1.10 or greater.
   if ( starversion_gt( 'KAPPA', 'v1.10-0' ) ) {

      if ( $addres ) {
         if ( $xres == $yres ) {
            $outfile = "${outroot}_$xres." . lc( $type );
            $outvecfile = "${outroot}_vector_$xres." . lc( $type );
	    $outclumpfile = "${outroot}_clump_$xres." . lc( $type );
	    $outcatfile = "${outroot}_cat_$xres." . lc( $type );
	    $outtextfile = "${outroot}_text_$xres." . lc( $type );
         } else {
            $outfile = "${outroot}_${xres}x${yres}." . lc( $type );
            $outvecfile = "${outroot}_vector_${xres}x${yres}." . lc( $type );
	    $outclumpfile = "${outroot}_clump_${xres}x${yres}." . lc( $type );
	    $outcatfile = "${outroot}_cat_${xres}x${yres}." . lc( $type );
	    $outtextfile = "${outroot}_text_${xres}x${yres}." . lc( $type );
         }
      } else {
         $outfile = join ".", $outroot, lc( $type );
         $outvecfile = join ".", $outroot, "_vector", lc( $type );
	 $outclumpfile = join ".", $outroot, "_clump", lc( $type );
	 $outcatfile = join ".", $outroot, "_cat", lc( $type );
	 $outtextfile = join ".", $outroot, "_text", lc( $type );
      }


# Set the x- and y-resolution. This needs to be done via an
# environment variable, which has a different name depending on what
# type of file we're writing.
      my $xresenv = "PGPLOT_" . $type . "_WIDTH";
      my $yresenv = "PGPLOT_" . $type . "_HEIGHT";

      $Mon{'kapview_mon'}->control( "setenv", "$xresenv=$xres" );
      $Mon{'kapview_mon'}->control( "setenv", "$yresenv=$yres" );

# Set the background colour to a light gray, and the foreground colour
# to black.
      $Mon{'kapview_mon'}->control( "setenv", "PGPLOT_FOREGROUND=BLACK" );
      $Mon{'kapview_mon'}->control( "setenv", "PGPLOT_BACKGROUND=GRAY90" );
      if ( $#nondegen == 0 ) {

         my $minmax = "";
         $minmax = "ybot=${min} ytop=${max}" if ( $zerorange );
         my $margin=0;
         my $axes = "no";
         my $style = "'colour=1,drawdsb=0'";

         if ( $xres == 256   ||  $xres == 1024 ) {
           $margin = "[0.15,0.01,0.01,0.15]";
           $axes = "yes";
           $style = "'colour=1,drawdsb=0,drawtitle=0'";
         }
         if ( $xres == 256 ) {
           $style="'drawtitle=0,colour=1,drawdsb=0,size=1.3,textlabgap=0'";
         }
         $params = "ndf=$file device=\"$outfile/$type\" margin=$margin axes=$axes mode=histogram $minmax style=$style";

         $Mon{'kapview_mon'}->obeyw( "linplot", "$params" );

      } elsif ( $#nondegen == 1 ) {

	my $minmax = "faint";
	if ((defined $siglow) && (defined $sighigh)){
	  my $low = $mean - $siglow * $sigma;
	  my $high = $mean + $sighigh * $sigma;
	  $minmax = "scale low=$low high=$high";
	}

         $minmax = "scale low=${min} high=${max}" if ( $zerorange );

         my $lut = $Frm->uhdr('MAKE_GREYSCALE_THUMBNAILS') ? 'grey' : 'cubehelix0';
	 my $neg = $Frm->uhdr('INVERT_GREYSCALE_THUMBNAILS') ? 1 : 0;
	 # Set badcol to be background.
         my $badcol = 0;
	 if ($neg) {
	   $Mon->{'kapview_mon'}->obeyw("lutable", "device=\"$outfile/$type\" coltab=negative mapping=linear");
	   # If using a negative lut, set badcol to be 1
	   $badcol = 1;
	 }

         $params = "in=$file device=\"$outfile/$type\" margin=0 axes=no badcol=$badcol ";
         $params .= "mode=${minmax} ";
	 unless ($neg) {
	   $params .= "lut=$ENV{KAPPA_DIR}/${lut}_lut.sdf ";
	 }
	 $params .= "reset";
         $Mon{'kapview_mon'}->obeyw( "display", "$params" );


	 rename("pgplot.png", "$outfile.$type");

# Assume that if vectors are supplied that POLPACK monolith was used
# to create it and is active.
         if ( defined( $vector_file ) ) {
            $params = "cat=$vector_file device=\"vector_file" . "/$type\" noclear noaxes nokey";
            $Mon{'polpack_mon'}->control( 'setenv', "PGPLOT_${type}_WIDTH=$xres" );
            $Mon{'polpack_mon'}->control( 'setenv', "PGPLOT_${type}_HEIGHT=$yres" );
            $Mon{'polpack_mon'}->obeyw( "polplot", "$params" );
	  }

# If an extents file was given, contour the clumps now.
	 if ( defined( $extents)) {

# Find out how many clumps there are.
	   $Mon{'kappa_mon'}->obeyw("stats", "$extents");
	   (my $ORAC_STATUS, my $nclumps) = $Mon{kappa_mon}->get("stats", "maximum");

	   # Create a temp file to hold the clump mask with bad pixels
	   # set to 0 for contouring.
	   my $nomagic = new ORAC::TempFile;
	   $Mon{'kappa_mon'}->obeyw('nomagic', "in=$extents out=$nomagic repval=0");


           # Kappa will not let you produce more than 50 contours in one go, so
           # Will have to divide the contour numbers up into clumps of 50.
           use POSIX;
           my $nruns = ceil($nclumps / 50);
           my $ncont = 50; # KAPPA doesn't care if this larger than
                           # the number of contours.
           my $firstcnt;

           for (my $i=0; $i <=$nruns; $i++){
             $firstcnt = 0.5 + $i * 50;
             $params = "labpos=! mode=linear firstcnt=$firstcnt stepcnt=1 " .
	     "ncont=$ncont clear=no style='color=red' " .
	     "device=\"$outclumpfile/$type\" key=false";

             if ($IMCONVERT){
               $Mon{'kapview_mon'}->obeyw("contour", "ndf=$nomagic $params QUIET");
               system("$IMCONVERT $outclumpfile -transparent gray90 $outclumpfile");
               system("$IMCONVERT $outfile $outclumpfile -composite $outfile");
             }
           }
           if ($IMCONVERT){
             unlink $outclumpfile;
           }
         }





	# If a peaks catalogues was given, plot the peaks.
	 if ( defined( $pointcat) ) {
	   $Mon{'kappa_mon'}->control("setenv", "$xresenv=$xres" );
	   $Mon{'kappa_mon'}->control("setenv", "$yresenv=$yres" );

# Set the background colour to a light gray, and the foreground
# colour to black.
	   $Mon{'kappa_mon'}->control("setenv", "PGPLOT_FOREGROUND=BLACK");
	   $Mon{'kappa_mon'}->control("setenv","PGPLOT_BACKGROUND=GRAY90");

	   $params = "incat=$pointcat plot=mark marker=5 device=\"$outcatfile/$type\" style='size=3,color=red,width=3' frame=sky";

	   $Mon{'kappa_mon'}->obeyw("listshow", "$params");
	   # Overlay the peaks on the map
	   if ($IMCONVERT) {
	     system("$IMCONVERT $outcatfile -transparent gray90 $outcatfile");
             system("$IMCONVERT $outfile $outcatfile -composite $outfile");
             unlink $outcatfile;
	   }

	 }

         # If overlay text was specified, attempt to render it with
         # ImageMagick.
         if ((defined $text_overlay) and $IMCONVERT) {
            die "TEXT_OVERLAY contains unexpected/no characters"
                unless $text_overlay =~ /^([-_a-zA-Z0-9.!"\n ]+)$/;
            my $text = $1;
            my $size = int($xres / 10);
            my $outline = int($xres / 64);
            unless ($size < 12 ) {
                system("$IMCONVERT $outfile -gravity center " .
                    "-stroke '#FFF' -strokewidth $outline -pointsize $size -annotate 0 '$text' " .
                    "-stroke none -fill '#F00' -pointsize $size -annotate 0 '$text' ".
                    "$outtextfile");
            }
            else {
                # If the size is too small, draw crossed lines rather than text
                # (which is assumed to indicate a reason for failure).
                my $xmax = $xres - 1;
                my $ymax = $yres - 1;
                system($IMCONVERT, $outfile,
                    "-stroke", "#FFF", "-strokewidth", "3", "-draw", "line 0,0 $xmax,$ymax",
                    "-stroke", "#FFF", "-strokewidth", "3", "-draw", "line $xmax,0 0,$ymax",
                    "-stroke", "#F00", "-strokewidth", "1", "-draw", "line 0,0 $xmax,$ymax",
                    "-stroke", "#F00", "-strokewidth", "1", "-draw", "line $xmax,0 0,$ymax",
                    $outtextfile);
            }
            rename($outtextfile, $outfile);
         }
       }

      orac_say "$file to $outfile: Created graphic.";

# Assemble metadata to write to the graphic file
# ===============================================

# Since the metadata are the same for each graphic, only form the list
# of keywords once.
      if ( $i == 0 ) {

# Try to load the Image::ExifTool module to add a header.
         my $isok = eval "use Image::ExifTool qw/ :Public /; 1; ";

# Check that we have made a graphic.
         if ( ! $isok ) {
            orac_warn "Could not load Image::ExifTool: $@\n";

         } else {
            my @keywords;

# JSA metadata
# ------------

# Get the FITS header so we can add various JSA headers.
            my $hdr = new Astro::FITS::Header::NDF( File => $file );

# We will need some headers for JSA preview generation, so store them in
# the PNG file.
            for my $k (qw/ asn_type asn_id backend instrume obsid utdate project survey tilenum /) {
               my $value = $hdr->value( uc($k) );
               push( @keywords, "jsa:$k=$value" ) if defined $value;
            }

# Write keywords for other headers.
            if ( defined( $hdr->value( "OBJECT" ) ) ) {
               push @keywords, "astro:name=" . $hdr->value( "OBJECT" );
            }

            if ( defined( $product ) ) {
               push @keywords, "jsa:product=" . $product;
            }

            if ( defined( $productID ) && length( $productID ) ) {
                push @keywords, "jsa:productID=" . $productID;
            }

            if ( defined $Frm->uhdr( 'ISHYBRID' ) ) {
               push @keywords, 'jsa:isHybrid=' .
                               ( $Frm->uhdr( 'ISHYBRID' ) ? 'true' : 'false' );
            }

# WCS metadata
# ------------

# Get the RA/Dec.
            my $bounds = retrieve_bounds( $file );
            my ( $ra, $dec );
            if ( defined $bounds->{'centre'} ) {
               $ra = $bounds->{'centre'}->ra->degrees;
               $dec = $bounds->{'centre'}->dec->degrees;

               if ( defined $ra && defined $dec ) {
                  push @keywords, "astro:RA=$ra";
                  push@keywords, "astro:Dec=$dec";
               }
            }

# Retrieve the orientation.
            if ( $#nondegen == 1 && defined $dec ) {
               my $lbound = $_GET_DIMENSIONS_{LBOUND};
               my $ubound = $_GET_DIMENSIONS_{UBOUND};
               my $wcs = $Frm->read_wcs( $file );
               my $skytemplate = Starlink::AST::SkyFrame->new( "" );
               $skytemplate->Set( 'MaxAxes' => 3,
                                  'MinAxes' => 1 );
               my $skyframe = $wcs->FindFrame( $skytemplate, "" );
               $skyframe->Set( 'system' => 'ICRS' );

               my $cen_x = 0.5 + ( $lbound->[0] + $ubound->[0] ) / 2;
               my $cen_y = 0.5 + ( $lbound->[1] + $ubound->[1] ) / 2;

# Add an arcminute to the central Dec position, then find in which
# pixel that is located, then derive the angle.
               my $dec_new = $bounds->{'centre'}->dec->radians + 0.000290888209;
               my @new_pos = $skyframe->TranP( 0,
                                               [ $bounds->{'centre'}->ra->radians ],
                                               [ $dec_new ] );

# Calculate the angle.
               my $x = $new_pos[0]->[0] - $cen_x;
               my $y = $new_pos[1]->[0] - $cen_y;
               my $angle = atan2( $y, $x );
               my $angle_deg = $angle * 180 / ( atan2( 1, 1 ) * 4 );

# Handle the quadrant.
               if ( $x < 0 ) {
                  if ( $y < 0 ) {
                     $angle_deg = 90 - $angle_deg;
                  } else {
                     $angle_deg = 450 - $angle_deg;
                  }
               } else {
                  $angle_deg = 90 - $angle_deg;
               }
               push @keywords, "astro:orientation=$angle_deg";

# Find the pixel scale of the original NDF, then scale the pixel scale
# accordingly.
               $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$file" );
               my ( $ORAC_STATUS, @fpixscale ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "fpixscale" );
               my $pixscale_orig = sqrt( $fpixscale[0] * $fpixscale[0] +
                                         $fpixscale[1] * $fpixscale[1] );
               my $longest_file = ( $nondegen[0] > $nondegen[1] ? $nondegen[0] : $nondegen[1] );
               my $longest_img = ( $xres > $yres ? $xres : $yres );
               my $pixscale_new = $longest_file * $pixscale_orig / $longest_img;
               push @keywords, "astro:pixelScale=$pixscale_new";

            }

# Write the EXIF information.
            $exif = new Image::ExifTool;
            foreach my $keyword ( @keywords ) {
               $exif->SetNewValue( Keywords => $keyword );
            }
         }

      }

      if (defined $exif) {
         orac_say " Adding EXIF header to $outfile.";

         $exif->WriteInfo( $outfile );
         $exif->WriteInfo( $outvecfile ) if ( defined $vector_file )
                                              && -e $outvecfile;
      }
   }
}
