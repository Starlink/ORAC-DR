# -*-cperl-*-

=head1 NAME

_CREATE_GRAPHIC_FROM_FILE_ - Create a PNG, GIF, or JPG graphic from a
given file.

=head1 DESCRIPTION

This primitive creates a PNG, GIF, or JPG graphic from the supplied
file. It currently only supports one- and two-dimenensional files.

=head1 ARGUMENTS

=over 4

=item ADDRES = LOGICAL (Given)

Whether or not to append the resolution to the filename. If true, the
output filename will have the form <file>_<xres>x<yres>.<type>, or if
the XRES and YRES parameters are equal, <file>_<xres>.<type>. [0]

=item EXTENTS = CHARACTER (Given)

A clump sdf file generated by cupid findclumps, containing clumps
to be contoured on top of the input file. (Only done if FILE is
a map). Each clump will be contoured in a separate .png file.

=item FILE = CHARACTER (Given)

The name of the file to convert to the given graphic file.  This
must be given.

=item FIXEDHIGH = FLOAT (Given)

Fixed high value for plotting using display.  (This applies in the same way
as SIGHIGH but is not referenced to the mean and standard deviation.)

=item FIXEDLOW = FLOAT (Given)

Fixed low value for plotting using display.  (This applies in the same way
as SIGLOW but is not referenced to the mean and standard deviation.)

=item OUTROOT = CHARACTER (Given)

The root output filename, if it needs to differ from FILE. [FILE]

=item POINTCAT = CHARACTER (Given)

A FITS catalog of point sources, which will can be plotted with
listshow on top a map of the input FILE. (Only created if FILE is a map).
The catalogue is plotted in a separate .png file which can be combined
with the base map using e.g. ImageMagick.

=item PRODUCT = STRING (Given)

The product name used for writing a keyword in the PNGs.  The default is
the value of the PRODUCT keyword for the input file supplied by
argument FILE.  If that is absent, it defaults to "reduced".  [].

=item PRODUCTID = STRING (Given)

The productID used for writing a keyword in the PNGs. No default
value. If this argument is not present, the header will not be written. []

=item SIGHIGH = FLOAT (Given)

The number of standard deviations above the mean to set scale high
to when plotting using display.  It is only used if SIGLOW is also given.
KAPPA DISPLAY will usually use mode=faint otherwise.

=item SIGLOW = FLOAT (Given)

The number of standard deviations below the mean to set scale low
to when plotting using display. Only used if SIGLOW is also given.
KAPPA DISPLAY will usually use mode=faint otherwise.

=item TEXT_OVERLAY = CHARACTER (Given)

Text to be overlaid. [undef]

=item TRIES = INTEGER (Given)

Number of times to try to create each graphic file. [10]

=item TYPE = CHARACTER (Given)

The type of graphic to create. Can be gif, jpg, or png. ['gif']

=item VECTOR_FILE = CHARACTER (Given)

A FITS file generated by POLPACK containing polarisation vectors to
plot over the image.  VECTOR_FILE is ignored if the file does not
exist or if FILE is one-dimensional.

=item XRES = INTEGER (Given)

The number of pixels along the x-axis of the output graphic file.
This can be a comma-separated list to produce graphic files at a
series of sizes.   [64]

=item YRES = INTEGER (Given)

The number of pixels along the y-axis of the output graphic file.
This can be a comma-separated list to produce graphic files at a
series of sizes.  If it is undefined a square graphic is assumed
using XRES to set the size.  [undef]

=item WCSMETADATA = BOOLEAN (Given)

Whether or not to generate WCS metadata.  [true]

=back

=head1 NOTES

=over 4

=item *

This primitive is suitable only for one-dimensional and two-dimensional
input files.

=item *

Each graphic file will have the same root filename as the input file,
unless the OUTROOT argument is given, with the appropriate file extension.

A polarisation vector overlay graphic file has an additional "_vector"
between the root name and the number of pixels.

=item *

Various metadata are written to the graphics files.

=over 4

=item *

astro:RA  Centre right ascension

=item *

astro:Dec  Centre declination

=item *

astro:name  The object's name (taken from the OBJECT header) but with
an equals signs replaced by the string "equals" (this is to avoid a
clash with the equals separating keyword=value headers).

=item *

jsa:product  The product type (derived from the input files PRODUCT header)

=item *

jsa:productID  The productID combining the product and subsystem information.

=item *

astro:orientation  Orientation in degrees

=item *

astro:pixelScale  Pixel size of the PNG in arcseconds

=back

=item *

The X-axis annotations increase linearly left to right, independent of
the WCS, provided this feature is available (from KAPPA V2.6-5).

=item *

The picture should be in greyscale if the MAKE_GREYSCALE_THUMBNAILS uhdr is
set to a true value.

=back

=head1 TASKS

KAPPA: CONTOUR, DISPLAY, LINPLOT, LISTSHOW, LUTABLE, NDFTRACE, NOMAGIC, POLPLOT, STATS.

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>
Malcolm J. Currie E<lt>mjc@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2009,2014-2015, 2020 Science and Technology Facilities Council.
All Rights Reserved.

=cut

use ORAC::Bounds qw/ retrieve_bounds /;

# Try to load the Image::ExifTool module for adding headers.
my $have_exiftool = eval "use Image::ExifTool qw/ :Public /; 1; ";
orac_warn "Could not load Image::ExifTool: $@\n"
    unless $have_exiftool;

# Arguments
# ==========

my $file = get_prim_arg( $_PRIM_ARGS_, 'FILE', undef );
if ( ! defined( $file ) ) {
  orac_throw "Programming error: Must supply FILE parameter to _CREATE_GRAPHIC_FROM_FILE_.";
}

my $vector_file = get_prim_arg( $_PRIM_ARGS_, 'VECTOR_FILE', undef );

# Obtain the product name from the file's headers.
my $tmpFrm = new $Frm;
$tmpFrm->file( $file );
$tmpFrm->readhdr();
my $file_product = defined( $tmpFrm->hdr( "PRODUCT" ) ) ? $tmpFrm->hdr( "PRODUCT" ) : "reduced";

my $addres = get_prim_arg( $_PRIM_ARGS_, 'ADDRES', 0 );
my $product = get_prim_arg( $_PRIM_ARGS_, 'PRODUCT', $file_product );
my $productID = get_prim_arg( $_PRIM_ARGS_, 'PRODUCTID', undef );
my $tries = get_prim_arg( $_PRIM_ARGS_, 'TRIES', 10 );
my $type = uc( get_prim_arg( $_PRIM_ARGS_, 'TYPE', 'GIF' ) );
my $xres = get_prim_arg( $_PRIM_ARGS_, 'XRES', 64 );
my $yres = get_prim_arg( $_PRIM_ARGS_, 'YRES', undef );
$yres = $xres if ( !defined( $yres ) );
my $outroot = get_prim_arg( $_PRIM_ARGS_, 'OUTROOT', $file );
my $wcsmetadata = get_prim_arg( $_PRIM_ARGS_, 'WCSMETADATA', 1 );

# Get catalogue files and overlay text.
my $extents = get_prim_arg( $_PRIM_ARGS_, 'EXTENTS', undef );
my $pointcat = get_prim_arg( $_PRIM_ARGS_, 'POINTCAT', undef );
my $text_overlay = get_prim_arg( $_PRIM_ARGS_, 'TEXT_OVERLAY', undef );

# Get the plotting options.
my $siglow = get_prim_arg( $_PRIM_ARGS_, 'SIGLOW', undef );
my $sighigh = get_prim_arg( $_PRIM_ARGS_, 'SIGHIGH', undef );
my $fixedlow = get_prim_arg( $_PRIM_ARGS_, 'FIXEDLOW', undef );
my $fixedhigh = get_prim_arg( $_PRIM_ARGS_, 'FIXEDHIGH', undef );


# Convert list of X resolutions an array.
if ( ref( $xres ) eq 'ARRAY' ) { $xres = join( ",", @{ $xres } ) }
my @resx = split( ',', $xres );
if ( ref( $yres ) eq 'ARRAY' ) { $yres = join( ",", @{ $yres } ) }
my @resy = split( ',', $yres );

my $nx = scalar( @resx );
my $ny = scalar( @resy );
if ( $nx > $ny ) {
   for ( my $i = $ny + 1; $i <= $nx; $i++ ) {
       $resx[ $i - 1 ] = $resy[ $i - 1 ];
   }
} elsif ( $ny > $nx ) {
   for ( my $i = $nx + 1; $i <= $ny; $i++ ) {
       $resy[ $i - 1 ] = $resx[ $i - 1 ];
   }
}


# Suggest possible locations for the ImageMagick convert?
my $IMCONVERT = "/usr/local/bin/convert";
unless (-e $IMCONVERT) {
   $IMCONVERT = "/usr/bin/convert";
   unless (-e $IMCONVERT) {
      $IMCONVERT = "";
   }
}

# Check for abnormal data
# =======================

# Use STATS to flag if this is not a frame with constant values.
# Set min and max to some range, since a 0-range stretch can
# crash the display routines.
my $zerorange = 0;
$Mon{kappa_mon}->obeyw( "stats", "ndf=$file" );
my ( $ORAC_STATUS, $sigma ) = $Mon{kappa_mon}->get( "stats", "sigma" );
( $ORAC_STATUS, my $max ) = $Mon{kappa_mon}->get( "stats", "maximum" );
( $ORAC_STATUS, my $min ) = $Mon{kappa_mon}->get( "stats", "minimum" );
( $ORAC_STATUS, my $mean ) = $Mon{kappa_mon}->get( "stats", "mean" );
if ( $sigma == 0 ) {
   $min += -1;
   $max +=  1;
   $zerorange = 1;
   orac_warn "...All pixels in ${file} have the same value.";
}

# Some sparse arrays such as stares in HEALPix tiles only have a few
# good pixels, sometimes too few for the graphic.
( $ORAC_STATUS, my $numgood ) = $Mon{kappa_mon}->get( "stats", "numgood" );
( $ORAC_STATUS, my $numpix ) = $Mon{kappa_mon}->get( "stats", "numpix" );
my $goodfrac = $numgood / $numpix;

# Check to see if we're one-dimensional or two-dimensional.
_GET_DIMENSIONS_ FILE=$file
my $dims = $_GET_DIMENSIONS_{DIMS};
my @nondegen = grep { $_ != 1 } @$dims;

if ( $#nondegen > 1 ) {
   orac_warn "Programming error: cannot create graphic from file that's not one- or two-dimensional.\n";
   return ORAC__OK;
}

# Create the graphic
# ==================
my @keywords = ();
my $pixscale_orig = undef;
my $tempimg = 'temp_image_for_device';
for ( my $i = 0; $i < $nx; $i++ ) {
   my ( $outfile, $outvecfile, $outclumpfile, $outcatfile, $outtextfile, $params );
   my $xres = $resx[ $i ];
   my $yres = $resy[ $i ];

# Only do this processing if we have KAPPA v1.10 or greater.
   if ( starversion_gt( 'KAPPA', 'v1.10-0' ) ) {

      if ( $addres ) {
         if ( $xres == $yres ) {
            $outfile = "${outroot}_$xres." . lc( $type );
            $outvecfile = "${outroot}_vector_$xres." . lc( $type );
            $outclumpfile = "${outroot}_clump_$xres." . lc( $type );
            $outcatfile = "${outroot}_cat_$xres." . lc( $type );
            $outtextfile = "${outroot}_text_$xres." . lc( $type );
         } else {
            $outfile = "${outroot}_${xres}x${yres}." . lc( $type );
            $outvecfile = "${outroot}_vector_${xres}x${yres}." . lc( $type );
            $outclumpfile = "${outroot}_clump_${xres}x${yres}." . lc( $type );
            $outcatfile = "${outroot}_cat_${xres}x${yres}." . lc( $type );
            $outtextfile = "${outroot}_text_${xres}x${yres}." . lc( $type );
         }
      } else {
         $outfile = join ".", $outroot, lc( $type );
         $outvecfile = join ".", $outroot, "_vector", lc( $type );
         $outclumpfile = join ".", $outroot, "_clump", lc( $type );
         $outcatfile = join ".", $outroot, "_cat", lc( $type );
         $outtextfile = join ".", $outroot, "_text", lc( $type );
      }


# Set the x- and y-resolution.  This needs to be done via an
# environment variable, which has a different name depending on what
# type of file we're writing.
      my $xresenv = "PGPLOT_" . $type . "_WIDTH";
      my $yresenv = "PGPLOT_" . $type . "_HEIGHT";

      $Mon{'kapview_mon'}->control( "setenv", "$xresenv=$xres" );
      $Mon{'kapview_mon'}->control( "setenv", "$yresenv=$yres" );

# Set the background colour to a light gray, and the foreground colour
# to black.
      $Mon{'kapview_mon'}->control( "setenv", "PGPLOT_FOREGROUND=BLACK" );
      $Mon{'kapview_mon'}->control( "setenv", "PGPLOT_BACKGROUND=GRAY90" );

# File type is spectrum.
# ----------------------
      if ( $#nondegen == 0 ) {
         my $minmax = "";
         $minmax = "ybot=${min} ytop=${max}" if ( $zerorange );
         my $margin=0;
         my $axes = "no";
         my $style = "'colour=1,drawdsb=0'";

         if ( $xres == 256 || $xres == 1024 ) {
            $margin = "[0.15,0.01,0.01,0.15]";
            $axes = "yes";
            $style = "'colour=1,drawdsb=0,drawtitle=0'";
         }

         if ( $xres == 256 ) {
            $style="'drawtitle=0,colour=1,drawdsb=0,size=1.3,textlabgap=0'";
         }

         $params = "ndf=$file device=\"$outfile/$type\" margin=$margin ";
         $params .= "axes=$axes mode=gaphistogram $minmax style=$style";
         if ( starversion_gt( 'KAPPA', 'V2.6-4' ) ) {
            $params .= " xmap=LRlinear";
         }

         for (my $n_try = 0; $n_try < $tries; $n_try ++) {
            $Mon{'kapview_mon'}->obeyw( "linplot", "$params" );
            last if -e $outfile;
         }

# File type is image.
# -------------------
      } elsif ( $#nondegen == 1 ) {

         my $minmax = "faint";
         if ( ( defined $siglow ) && ( defined $sighigh ) ) {
            my $low = $mean - $siglow * $sigma;
            my $high = $mean + $sighigh * $sigma;
            $minmax = "scale low=$low high=$high";
         }
         elsif ( ( defined $fixedlow ) && ( defined $fixedhigh ) ) {
            $minmax = "scale low=$fixedlow high=$fixedhigh";
         }


# Adjust the scaling for pathological data.
         my $graphic_pixels = $xres * $yres * $goodfrac;
         if ( $zerorange || $graphic_pixels < 7 ) {
            $minmax = "scale low=${min} high=${max}";
         }

         my $lut = $Frm->uhdr( 'MAKE_GREYSCALE_THUMBNAILS' ) ? 'grey' : 'cubehelix0';
         my $neg = $Frm->uhdr( 'INVERT_GREYSCALE_THUMBNAILS' ) ? 1 : 0;

# Set badcol to be background.
         my $badcol = 0;
         if ( $neg ) {
            $params = "device=\"$outfile/$type\" coltab=negative mapping=linear";
            $Mon->{'kapview_mon'}->obeyw( "lutable", "$params" );

# If using a negative lut, set badcol to be 1.
            $badcol = 1;
         }

         $params = "in=$file device=\"$outfile/$type\" margin=0 axes=no badcol=$badcol ";
         $params .= "mode=${minmax} ";
         unless ( $neg ) {
            $params .= "lut=$ENV{KAPPA_DIR}/${lut}_lut.sdf ";
         }
         $params .= "reset";

         for (my $n_try = 0; $n_try < $tries; $n_try ++) {
            $Mon{'kapview_mon'}->obeyw( "display", "$params" );
            last if -e $outfile;
         }

# Assume that if vectors are supplied that POLPACK monolith was used
# to create it and is active.
         if ( defined( $vector_file ) ) {
            $params = "cat=$vector_file device=\"$outvecfile" . "/$type\" noclear noaxes nokey";
            $Mon{'polpack_mon'}->control( 'setenv', "PGPLOT_${type}_WIDTH=$xres" );
            $Mon{'polpack_mon'}->control( 'setenv', "PGPLOT_${type}_HEIGHT=$yres" );

            for (my $n_try = 0; $n_try < $tries; $n_try ++) {
               $Mon{'polpack_mon'}->obeyw( "polplot", "$params" );
               last if -e $outvecfile;
            }
         }

# If an extents file was given, contour the clumps now.
         if ( defined( $extents ) ) {

# Find out how many clumps there are.
            $Mon{'kappa_mon'}->obeyw("stats", "$extents");
            (my $ORAC_STATUS, my $nclumps) = $Mon{kappa_mon}->get("stats", "maximum");

# Create a temporary file to hold the clump mask with bad pixels set to
# 0 for contouring.
            my $nomagic = new ORAC::TempFile;
            $Mon{'kappa_mon'}->obeyw( 'nomagic', "in=$extents out=$nomagic repval=0" );

# KAPPA will not let you produce more than 50 contours in one go, so
# will have to divide the contour numbers up into clumps of 50.
            use POSIX;
            my $nruns = ceil( $nclumps / 50 );
            my $ncont = 50; # KAPPA doesn't care if this is larger than
                            # the number of contours.
            my $firstcnt;

            for ( my $i=0; $i <=$nruns; $i++ ){
               $firstcnt = 0.5 + $i * 50;
               $params = "labpos=! mode=linear firstcnt=$firstcnt stepcnt=1 " .
               "ncont=$ncont clear=no style='color=red' " .
               "device=\"$outclumpfile/$type\" key=false";

               if ( $IMCONVERT ) {
                  for (my $n_try = 0; $n_try < $tries; $n_try ++) {
                     $Mon{'kapview_mon'}->obeyw( "contour", "ndf=$nomagic $params QUIET" );
                     last if -e $outclumpfile;
                  }
                  system( "$IMCONVERT $outclumpfile -transparent gray90 $outclumpfile" );
                  system( "$IMCONVERT $outfile $outclumpfile -composite $outfile" );
               }
            }
            if ( $IMCONVERT ){
               unlink $outclumpfile;
            }
         }

# If a peaks catalogues was given, plot the peaks.
         if ( defined( $pointcat) ) {
            $Mon{'kappa_mon'}->control("setenv", "$xresenv=$xres" );
            $Mon{'kappa_mon'}->control("setenv", "$yresenv=$yres" );

# Set the background colour to a light grey, and the foreground colour to black.
            $Mon{'kappa_mon'}->control("setenv", "PGPLOT_FOREGROUND=BLACK");
            $Mon{'kappa_mon'}->control("setenv","PGPLOT_BACKGROUND=GRAY90");

            $params = "incat=$pointcat plot=mark marker=5 device=\"$outcatfile/$type\" ";
            $params .= "style='size=3,color=red,width=3' frame=sky";

            for (my $n_try = 0; $n_try < $tries; $n_try ++) {
               $Mon{'kappa_mon'}->obeyw( "listshow", "$params" );
               last if -e $outcatfile;
            }

# Overlay the peaks on the map.
            if ( $IMCONVERT ) {
               system( "$IMCONVERT $outcatfile -transparent gray90 $outcatfile" );
               system( "$IMCONVERT $outfile $outcatfile -composite $outfile" );
               unlink $outcatfile;
            }

         }

# If overlay text was specified, attempt to render it with ImageMagick.
         if ( ( defined $text_overlay ) and $IMCONVERT ) {
            die "TEXT_OVERLAY contains unexpected/no characters"
                unless $text_overlay =~ /^([-_a-zA-Z0-9.!"\n ]+)$/;
            my $text = $1;
            my $size = int( $xres / 10 );
            my $outline = int( $xres / 64 );
            unless ( $size < 12 ) {
                system("$IMCONVERT $outfile -gravity center " .
                    "-stroke '#FFF' -strokewidth $outline -pointsize $size -annotate 0 '$text' " .
                    "-stroke none -fill '#F00' -pointsize $size -annotate 0 '$text' ".
                    "$outtextfile");
            } else {

# If the size is too small, draw crossed lines rather than text (which
# is assumed to indicate a reason for failure).
               my $xmax = $xres - 1;
               my $ymax = $yres - 1;
               system( $IMCONVERT, $outfile,
                   "-stroke", "#FFF", "-strokewidth", "3", "-draw", "line 0,0 $xmax,$ymax",
                   "-stroke", "#FFF", "-strokewidth", "3", "-draw", "line $xmax,0 0,$ymax",
                   "-stroke", "#F00", "-strokewidth", "1", "-draw", "line 0,0 $xmax,$ymax",
                   "-stroke", "#F00", "-strokewidth", "1", "-draw", "line $xmax,0 0,$ymax",
                   $outtextfile );
            }
            rename( $outtextfile, $outfile );
         }
       }

       orac_say "$file to $outfile: Created graphic.";


# Set the background colour back to black, and the foreground colour
# to white.
      $Mon{'kapview_mon'}->control( "setenv", "PGPLOT_FOREGROUND=WHITE" );
      $Mon{'kapview_mon'}->control( "setenv", "PGPLOT_BACKGROUND=BLACK" );

# Assemble metadata to write to the graphic file
# ===============================================

# Since the metadata are the same for each graphic, only form the list
# of keywords once, except for those which change depending on the resolution.
      if ($have_exiftool) {
         if ( $i == 0 ) {

# JSA metadata
# ------------

# Get the FITS header so we can add various JSA headers.
            my $hdr = new Astro::FITS::Header::NDF( File => $file );

# We will need some headers for JSA preview generation, so store them in
# the PNG file.
            for my $k (qw/ asn_type asn_id backend instrume obsid utdate project survey tilenum date-obs date-end /) {
               my $value = $hdr->value( uc($k) );
               push( @keywords, "jsa:$k=$value" ) if defined $value;
            }

# Write keywords for other headers.
            if ( defined( $hdr->value( "OBJECT" ) ) ) {

# Names could have an equals sign, which will confuse the keyword=value
# delineation in JSA::Convert.
               my $cleaned_name = $hdr->value( "OBJECT" );
               $cleaned_name =~ s/=/equals/g;
               push @keywords, "astro:name=$cleaned_name";
            }

            if ( defined( $product ) ) {
               push @keywords, "jsa:product=" . $product;
            }

            if ( defined( $productID ) && length( $productID ) ) {
                push @keywords, "jsa:productID=" . $productID;
            }

            if ( defined $Frm->uhdr( 'ISHYBRID' ) ) {
               push @keywords, 'jsa:isHybrid=' .
                               ( $Frm->uhdr( 'ISHYBRID' ) ? 'true' : 'false' );
            }

# WCS metadata
# ------------

            if ($wcsmetadata) {

# Get the RA/Dec.
               my $bounds = retrieve_bounds( $file );
               my ( $ra, $dec );
               if ( defined $bounds->{'centre'} ) {
                  $ra = $bounds->{'centre'}->ra->degrees;
                  $dec = $bounds->{'centre'}->dec->degrees;

                  if ( defined $ra && defined $dec ) {
                     push @keywords, "astro:RA=$ra";
                     push@keywords, "astro:Dec=$dec";
                  }
               }

# Retrieve the orientation.
               if ( $#nondegen == 1 && defined $dec ) {
                  my $lbound = $_GET_DIMENSIONS_{LBOUND};
                  my $ubound = $_GET_DIMENSIONS_{UBOUND};
                  my $wcs = $Frm->read_wcs( $file );
                  my $skytemplate = Starlink::AST::SkyFrame->new( "" );
                  $skytemplate->Set( 'MaxAxes' => 3,
                                     'MinAxes' => 1 );
                  my $skyframe = $wcs->FindFrame( $skytemplate, "" );
                  $skyframe->Set( 'system' => 'ICRS' );

                  my $cen_x = 0.5 + ( $lbound->[0] + $ubound->[0] ) / 2;
                  my $cen_y = 0.5 + ( $lbound->[1] + $ubound->[1] ) / 2;

# Add an arcminute to the central Dec position, then find in which
# pixel that is located, then derive the angle.
                  my $dec_new = $bounds->{'centre'}->dec->radians + 0.000290888209;
                  my @new_pos = $skyframe->TranP( 0,
                                                  [ $bounds->{'centre'}->ra->radians ],
                                                  [ $dec_new ] );

# Calculate the angle.
                  my $x = $new_pos[0]->[0] - $cen_x;
                  my $y = $new_pos[1]->[0] - $cen_y;
                  my $angle = atan2( $y, $x );
                  my $angle_deg = $angle * 180 / ( atan2( 1, 1 ) * 4 );

# Handle the quadrant.
                  if ( $x < 0 ) {
                     if ( $y < 0 ) {
                        $angle_deg = 90 - $angle_deg;
                     } else {
                        $angle_deg = 450 - $angle_deg;
                     }
                  } else {
                     $angle_deg = 90 - $angle_deg;
                  }
                  push @keywords, "astro:orientation=$angle_deg";

# Find the pixel scale of the original NDF, then scale the pixel scale
# accordingly.
                  $Mon{'ndfpack_mon'}->obeyw( "ndftrace", "ndf=$file" );
                  my ( $ORAC_STATUS, @fpixscale ) = $Mon{'ndfpack_mon'}->get( "ndftrace", "fpixscale" );
                  $pixscale_orig = sqrt( $fpixscale[0] * $fpixscale[0] +
                                         $fpixscale[1] * $fpixscale[1] );
               }
            }
         }

         # Prepare resolution-specific keywords.
         my @keywords_extra = ();

         if (defined $pixscale_orig) {
            my $longest_file = ( $nondegen[0] > $nondegen[1] ? $nondegen[0] : $nondegen[1] );
            my $longest_img = ( $xres > $yres ? $xres : $yres );
            my $pixscale_new = $longest_file * $pixscale_orig / $longest_img;
            push @keywords_extra, "astro:pixelScale=$pixscale_new";
         }

         # Write the EXIF information.
         my $exif = new Image::ExifTool;
         $exif->SetNewValue( Keywords => [@keywords, @keywords_extra] );

         orac_say " Adding EXIF header to $outfile.";
         $exif->WriteInfo( $outfile )
            or orac_warn("Error adding EXIF header to $outfile: " .
                         $exif->GetValue("Error") . "\n");

         if (( defined $vector_file ) && -e $outvecfile ) {
            orac_say " Adding EXIF header to $outvecfile.";
            $exif->WriteInfo( $outvecfile )
               or orac_warn("Error adding EXIF header to $outvecfile: " .
                            $exif->GetValue("Error") . "\n");
         }
      }
   }
}
