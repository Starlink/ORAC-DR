# -*-perl-*-

=head1 NAME

_MAKE_MOSAIC_ - Main primitive for mosaicking images

=head1 SYNOPSIS

_MAKE_MOSAIC_ USEGRP=1 COADD_MODE=RUNNING

_MAKE_MOSAIC_ USEGRP=0 MAKEMOS=1

=head1 DESCRIPTION

This is the work-horse mosaicking primitive for SCUBA-2 data. It will
create a Frame or Group mosaic depending on the specified processing
flag. It is designed to be called from a wrapper primitive
specifically for processing either Frame or Group objects. 

The user has the choice of specifying the mosaicking application:
either MAKEMOS (CCDPACK) or WCSMOSAIC (KAPPA). Generally for quick
mosaics of similar data, the latter is used, while the former has more
advanced image combination features.

A check is made to see if the number of files to mosaic is greater
than the maximum allowed (a value which depends on the version of
CCDPACK or KAPPA installed), and if so the process is divided into
several steps to generate intermediate mosaicked files which are then
mosaicked at the end.

For producing a Group mosaic, the user has the option of creating a
running average or stacking all of the images in the Group object.

Other arguments control the method used to combine the images.

For mosaicking images in a SKY frame, a reference image must be
created. If a Group file exists, that will be taken as the
reference. If not, then the Calibration object is queried to return a
reference image. If there is no reference by this stage, then the
C<SKYREF> parameter is used to determine whether or not a new
sky-aligned reference image should be created.

=head1 ARGUMENTS

The following arguments are supported, some of which are specific to
Frame and Group processing respectively (as noted):

=over 4

=item B<COADD_MODE>

Group-processing parameter. Method for combining images into a group
mosaic. Valid options are C<RUNNING>, C<STACKALL> and
C<DESPIKE>. C<RUNNING> means the images in the current Frame will be
combined with the current Group mosaic. C<STACKALL> will combine all
of the images in all of the Frames within the Group object. If the
C<DESPIKE> option is given then the user must also specify the number
of images to combine in one step with the C<NMOS> parameter. The
default is C<RUNNING>, though if there is no Group image C<STACKALL>
is chosen.

=item B<GENVAR>

Flag to determine whether or not to generate variances when
mosaicking. Default is 1 (yes).

=item B<GROUP>

A Group object may be passed in and a mosaic formed from the members
within that, rather than using the global Grp. A warning is issued if
the parameter is not a member of ORAC::Group class. Optional
parameter: default is Grp.

=item B<MAKEMOS>

Flag to denote whether or not to use WCSALIGN+MAKEMOS or
WCSMOSAIC. Default is 0 (use WCSMOSAIC).

=item B<MAKEMOS_METHOD>

The method to be used by MAKEMOS to combine the images. May be any
value supported by MAKEMOS (see MAKEMOS documentation for further
details). Default is C<MEAN>. Only accessed if B<MAKEMOS> is true.

=item B<METHOD>

Image resampling method used by WCSALIGN or WCSMOSAIC. May be any
value supported by those tasks. Default is C<NEAREST>
(nearest-neighbour).

=item B<NMOS>

Group-processing parameter. The number of images to combine to create
the group mosaic. Default is 1, forcing the user to specify a suitable
value if the DESPIKE method is requested.

=item B<SIGMAS>

The number of standard deviations at which to clip the data before
combining for B<MAKEMOS_METHOD> = C<SIGMA>. Default is 4.

=item B<SKYREF>

Flag to indicate whether to align images in a SKY coordinate
frame. Default is 1 (yes). Only used if no reference image currently
exists. If set to 0 (no) then the images will be aligned to the first
image in the Frame, which may or may not be desireable.

=item B<USEGRP>

A flag to denote Group processing. Default is 0 (Frame processing).

=item B<VERBOSE>

Flag to denote whether to display extra information. Default is 0
(no).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

NDFCOPY, NDFTRACE, WCSMOSAIC

=item CCDPACK

MAKEMOS

=item ORAC-DR PRIMITIVES

_ADD_IMAGES_, _ALIGN_ARRAYS_, _GET_REFERENCE_IMAGE_

=back

=head1 NOTES

Getting valid variances in output images can only be achieved under
the right circumstances as it depends on the nature of the original
input data, the method used to combine these at the Frame level (set
primarily by the type of pipeline being run) and the chosen method for
combining Group level images. Furthermore, the user can choose one of
two mosaicking algorithms which have slightly different methods for
how variances are or are not calculated. See the respective
documentation for CCDPACK MAKEMOS and KAPPA WCSMOSAIC for full
details.

For Frame processing, the B<GENVAR> parameter should be set to false
in the QL pipeline, otherwise true. The input images have no intrinsic
variance component so the C<variance> (WCSMOSAIC) and C<usevar>
(MAKEMOS) arguments should be false. (Note that in practice,
Frame-level mosaicking is only relevant for DREAM/STARE processing.)

For Group processing, B<GENVAR> can only be true if the number of
input files is > 1 (ideally as many as necessary to get a valid
variance estimate).

If estimating variances is crucial then setting B<COADD_MODE> to
DESPIKE is recommended (which forces the use of MAKEMOS) and the
number of files to use to estimate a variance is set by the B<NMOS>
parameter.

See also the documentation for the
L<_MAKE_MOSAIC_FRAME_|_MAKE_MOSAIC_FRAME_> and
L<_MAKE_MOSAIC_GROUP_|_MAKE_MOSAIC_GROUP_> primitives.

=head1 OUTPUT DATA

On exit, the primitive hash C<%_MAKE_MOSAIC_> contains the key
NEWIMAGE which is either 1 or 0 depending on whether a new image was
created.

The Frame or Group is updated to contain the new image.

=head1 OUTPUT FILES

Creates a single output image with a suffix of C<_fmos> for Frame
mosaics, or C<_mos> for Group mosaics which is registered with the
appropriate object.

=head1 KNOWN ISSUES

The check for the maximum number of files that can be mosaicked
($maxmos) is done only once, which means this primitive will fail if
the number of intermediate mosaics also exceeds the maximum number of
files. Thus the effective limit to the number of files to mosaic is
$maxmos**2. For the most recent versions of MAKEMOS and WCSMOSAIC,
this amounts to 1 million files.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>,
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 2004-2007 Particle Physics and Astronomy Research
Council. Copyright (C) 2004-2008 University of British Columbia.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Define the maximum number of pixels in a tile
use constant MAXPIX => 60e6;

# Should I be verbose (default to no)
my $verbose = get_prim_arg( $_PRIM_ARGS_, "VERBOSE", 0);

# Are we processing Group data?
my $usegrp = get_prim_arg( $_PRIM_ARGS_, "USEGRP", 0);

# Do we want to take advantage of what makemos can do?
my $makemos = get_prim_arg( $_PRIM_ARGS_, "MAKEMOS", 0);

# Are we aligning images in a SKY frame?
my $skyalign = get_prim_arg( $_PRIM_ARGS_, "SKYREF", 1);

# Flag to determine whether or not to generate variances when
# mosaicking
my $genvar = get_prim_arg( $_PRIM_ARGS_, "GENVAR", 1);

# Check that the installed version of Kappa has WCSMOSAIC
unless ( $makemos ) {
  if (starversion_lt('kappa', 'V1.5')) {
    $makemos = 1;
    orac_warn "Installed Kappa version does not support WCSMOSAIC, using WCSALIGN + MAKEMOS\n";
  }
}

# Method for determining the output pixel values in WCSALIGN and WCSMOSAIC
my $method = lc(get_prim_arg( $_PRIM_ARGS_, "METHOD", "bilinear"));

# Method for combining images in MAKEMOS
my $makemos_method = lc(get_prim_arg($_PRIM_ARGS_, "MAKEMOS_METHOD", "mean"));

# Number of sigmas to use if makemos_method = sigma (sigma-clipped mean)
my $sigmas = get_prim_arg($_PRIM_ARGS_, "SIGMAS", 4.0);

# If we are using sigma clipping then add the sigmas parameter to the
# makemos_method
if ( $makemos_method eq "sigma" ) {
  $makemos_method .= " sigmas=$sigmas";
}

# Input/output files
my ($in, $out);

# Image bounds
my @bounds;

my $Grpobj = undef; # Group object if group processing
# Number of Frames to mosaic for good variance - initialize to 1
my $nmos = 1;
my $despike = 0; # Flag for Despike method of creating Group images
if ( $usegrp ) {
  # Determine which group object to use - fall back on Grp if not defined
  $Grpobj = get_prim_arg( $_PRIM_ARGS_, "GROUP", $Grp );

  # Check that the supplied GROUP object is indeed an ORAC-DR group object
  unless (UNIVERSAL::isa($Grpobj, "ORAC::Group") ) {
    orac_throw "Error: input GROUP is not an ORAC-DR Grp object\n";
  }
}

# Establish which Frame is being used
my $Frmobj = get_prim_arg( $_PRIM_ARGS_, "FRAME", $Frm );
# Check that the user has really passed in a Frm!
unless ( UNIVERSAL::isa($Frmobj, "ORAC::Frame") ) {
  orac_throw "Error: input FRAME is not an ORAC-DR Frm object\n";
}

# Define the reference image. Use default coordinate frame
_GET_REFERENCE_IMAGE_ SKYREF=$skyalign VERBOSE=$verbose GROUP=$Grpobj
my $refimage = $_GET_REFERENCE_IMAGE_{REFIMAGE};

# Flag for moving sources
my $moving = $Grp->uhdr("MOVING");

# Write text file with list of files to align and mosaic.
my $filelist = new ORAC::TempFile;
my $listhandle = $filelist->handle;
my $tmpout; # Output file
# Label to inform user of Frame/Group processing
my $grpfrm; 
# Number of files to mosaic
my $nfiles;
# Flag to indicate whether to go ahead with the mosaicking step
my $make_mosaic = 0;

my @mosfiles; # List of filenames to be mosaicked

##############################################
# First we obtain the list of files to mosaic
##############################################
if ( $usegrp ) {
  # #################
  # GROUP PROCESSING
  # #################
  $grpfrm = "Group";
  my $coadd_mode = uc(get_prim_arg($_PRIM_ARGS_, "COADD_MODE", "RUNNING"));

  # Set despike flag
  $despike = ( $coadd_mode eq 'DESPIKE' ) ? 1 : 0;

  # If we are in RUNNING mode, check that we have enough images to get
  # a variance and/or that the Group object file exists
  my $nimages = scalar($Frm->files);
  if ( ($coadd_mode eq 'RUNNING') && 
       (($nimages < 3) && $genvar || !$Grpobj->file_exists) ) {
    # If not, then we must use STACKALL
    $coadd_mode = 'STACKALL';
  }

  # #####################
  # COADD_MODE = RUNNING
  # #####################
  if ($coadd_mode eq 'RUNNING') {
    # Combine all the images in the current Frm with the Grp image
    orac_print "Collecting files to mosaic...\n";
    if ($Grpobj->file_exists) {
      $nfiles = 1;
      $in = $Grpobj->file;
      print {$listhandle} $Grpobj->file ."\n";
      push (@mosfiles, $Grpobj->file);

      for my $fname ($Frm->files) {
	# Write current filename to list file
	print {$listhandle} "$fname\n";
	$in = $fname;
	push (@mosfiles, $fname);
	$nfiles++;
      }
      # Everything's OK, we can make the mosaic
      $make_mosaic = 1;
    } else {
      orac_warn "Managed to get into RUNNING average without a group file";
    }
  } elsif ($coadd_mode eq 'STACKALL' || $despike ) {
    # #################################
    # COADD_MODE = STACKALL or DESPIKE
    # #################################
    # Retrieve the number of Frames in the Group object
    my @members = $Grpobj->members;
    my $nFrm = scalar(@members);
    # Obtain the number of Frames to mosaic for calculating a
    # statistically-valid variance - set a default of 1 so that the
    # user must specify NMOS for the DESPIKE method
    $nmos = get_prim_arg($_PRIM_ARGS_,"NMOS", 1);
    
    # If the OBSEND flag is set then make a group mosaic anyway even
    # if the number of files is less than NMOS
    my $lastfrm = $Grpobj->frame(-1);
    if ( $lastfrm->hdrval("OBSEND",-1) && ( $nFrm < $nmos ) ) {
      orac_print "End of observation reached: making group mosaic with $nFrm available files\n";
      $nmos = $nFrm;
    }

    # Now determine list of files
    if ( $nFrm % $nmos == 0 ) {
      # Combine all the frame images within the Group
      orac_print "Collecting files to mosaic...\n";

      # Set the starting index for array slice of Group members
      my $begfrm = 0;
      my $endfrm = $#members;

      # Initialize File counter
      $nfiles = 0;

      # If we are despiking, we will always use MAKEMOS and we must
      # use the sigma method for rejecting outliers.
      if ($despike) {
	$makemos = 1;
	$makemos_method = "sigma sigmas=$sigmas";
	$begfrm = -$nmos;
	$endfrm = -1;

	# Add Grp file to list if it exists
	if ( $Grp->file_exists ) {
	  print {$listhandle} $Grp->file."\n";
	  $in = $Grp->file;
	  push (@mosfiles, $Grp->file);
	  $nfiles++;
	}
      }

      # Loop over all Frame objects in the Group object
      for my $f ( @members[$begfrm..$endfrm] ) {
	# Now loop over all files in current Frame object
	for my $fname ($f->files) {
	  print {$listhandle} "$fname\n";
	  $in = $fname;
	  push (@mosfiles, $fname);
	  $nfiles++;
	}
      }
      $make_mosaic = 1;
    } else {
      # Not enough images to mosaic yet
      $make_mosaic = 0;
    }
  } else {
    # Oops?
    orac_err("Unrecognized COADD_MODE, $coadd_mode");
    my $ORAC_STATUS = ORAC__ERROR;
  }

  # If all is well and we're on the mosaicking path, provide feedback
  # and setup name of output Group object file
  if ( $make_mosaic ) {
    orac_print "GROUP mosaic: coadd_mode = $coadd_mode\n" 
      if $verbose;
    # Define output file for Group images HACK
    if ( $usegrp ) {
      $tmpout = new ORAC::TempFile(0);
      $out = $tmpout->file;
    }
  }
} else {
  # #################
  # FRAME PROCESSING
  # #################
  $grpfrm = "Frame";
  orac_print "Collecting files to mosaic...\n";

  # If we have only 1 subarray and 1 file this means we're in QL mode
  # so just align this image to the reference
  if ($Frmobj->numsubarrays == 1 && $Frmobj->nfiles == 1) {
    _ALIGN_ARRAYS_ METHOD=$method REFIMAGE=$refimage FRAME=$Frmobj REBIN=1 VERBOSE=1
    ($in, $out) = $Frmobj->inout('_fmos');
    # This should be 0 anyway, but absolutely insist on it here to make sure
    $makemos = 0;
    $nfiles = $Frmobj->nfiles;
  } else {
    # Align images in the current Frm to a reference image
    if ( $makemos ) {
      _ALIGN_ARRAYS_ METHOD=$method REFIMAGE=$refimage FRAME=$Frmobj REBIN=1
    }

    # Write names of all files to temp file
    $nfiles = 0;
    for my $fname ($Frmobj->files) {
      print {$listhandle} "$fname\n";
      $in = $fname;
      push (@mosfiles, $fname);
      $nfiles++;
    }
    # Create output filename, derived from first input file
    # since this is a many to one operation
    $out = $Frmobj->inout('_fmos');
  }

  $make_mosaic = 1;
}
$listhandle->close;

#####################################################################
# Done with image collation, now proceed with mosaicking the images,
# provided the make_mosaic flag is set
#####################################################################

if ( $make_mosaic ) {
  # First, some user feedback
  my $mostask = ( $makemos ) ? "MAKEMOS" : "WCSMOSAIC";
  orac_print "Mosaicking $grpfrm file with $mostask: "
    .( ($nfiles == 1) ? "using $nfiles file" : "combining $nfiles files")."...";

  my $args;
  # Retrieve name of file which will hold the list of images to mosaic
  if ( $makemos ) {
    # ########
    # MAKEMOS
    # ########

    # Now, since we are using makemos, we need to deal with the finite
    # number of images that can be mosaicked simultaneously, currently
    # 1000 but it was only 100 in older versions of CCDPACK.
    my $maxmosfiles = (starversion_lt('ccdpack', 'V4.0-17')) ? 100 : 1000;

    my $maxmossq = $maxmosfiles*$maxmosfiles;
    if ( $nfiles > $maxmossq ) {
      orac_err "Unable to mosaic images: number of input files, $nfiles, exceeds capacity, $maxmossq\n";
    }

    # Declare variable names for list of intermediate mosaics, array
    # of intermediate mosaics ORAC::TempFile objects and list of
    # filenames in current intermediate mosaic. This must be done here
    # because we need these variables to remain in scope outside the
    # block which creates the intermediate mosaics.
    my ($intermoslist, @intermosaics, @mosaiclist);

    # General arguments for makemos - adopt a conservative approach
    # and do not attempt to use variances which may or may not be
    # present in the data files
    if ( $usegrp ) {
      if ( $nfiles > 1 ) {
	$args = ($genvar) ? " genvar usevar" : "nogenvar nousevar";
      } else {
	# Check to see if variance is present. If there is only a
	# single file then it will be the Frame file
	my $file=$Frmobj->file;
	$Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$file");
	(my $ORAC_STATUS, my $isvarpresent) = $Mon{ndfpack_mon}->get("ndftrace","variance");
	if ( $isvarpresent ) {
	  $args = "genvar usevar";
	} else {
	  $args = "nogenvar nousevar";
	}
      }
    } else {
      # Frame processing: no internal variances will be present, so
      # set usevar to false if genvar is false.
      $args = ($genvar) ? " genvar usevar" : "nogenvar nousevar";
    }
    $args .= " method=$makemos_method logto=neither";

    # Check number of files and generate intermediate mosaics if necessary
    my $moslist = $filelist->file;
    if ( $nfiles > $maxmosfiles ) {
      use POSIX qw/ ceil /;
      my $nsteps = ceil($nfiles/$maxmosfiles);
      my $stepsize = ceil($nfiles/$nsteps);
      orac_print "\nCreating $nsteps intermediate mosaics, each of $stepsize images ...";

      # Create the temporary files to hold the intermediate mosaic file
      # lists: there are $nsteps of them
      for my $j (1 .. $nsteps) {
	my $mosfile = new ORAC::TempFile(0);
	push (@intermosaics, $mosfile);
      }

      # Read filenames from master file list - note filenames will
      # include a line terminator, but this is OK since they will need
      # those be written out as well.
      open my $listhandle, "< $moslist" or die "Unable to open file, $moslist : $!\n";
      my @allfiles = <$listhandle>;

      # Loop over number of steps, define start and end index into
      # array of all files and write only those to the intermediate
      # mosaic list file. There will be $stepsize number of images in
      # each of these files. Run makemos with this shorter list of
      # images.
      my $curmosfile;
      for my $i (1 .. $nsteps ) {
	# Retrieve name of current intermediate mosaic
	$curmosfile = $intermosaics[$i-1];
	
	# Define start and end indices of array of images to include
	my $start = ($i-1) * $nsteps;
	my $end = $start + $stepsize - 1;

	# Write out array slice to intermediate mosaic input file list
	my $tmplist = new ORAC::TempFile;
	print {$tmplist->handle} @allfiles[$start..$end];

	# Run makemos
	my $mosargs = "in=^".$tmplist->file." out=".$curmosfile->file."$args";
	$Mon{ccdpack_reg}->obeyw("makemos","$mosargs");
	push (@mosaiclist, $curmosfile->file);
      }

      # Reset the extra args to generate and use variances
      $args = " genvar usevar";

      # Create new list of input images to make the final mosaic
      $intermoslist = new ORAC::TempFile;
      print {$intermoslist->handle} join("\n",@mosaiclist[0..$#mosaiclist]);
      $moslist = $intermoslist->file;
    }

    # Create mosaic
    my $mosargs = "in=^".$moslist." method=$makemos_method ref=$refimage "
      ."nozero noscale out=$out title=".$Frmobj->hdr('OBJECT')." $args";

    $Mon{ccdpack_reg}->obeyw("makemos","$mosargs");
    # Retrieve the current Frame header and write it to the output file
    my $fitshdr = $Frmobj->fits;
    $fitshdr->writehdr( File => $out );
  } else {
    # ##########
    # WCSMOSAIC
    # ##########
    my $wlim = 0.2;
    # Now to get the variance scheme correct. 
    #
    # If there is only a single input image then set both GENVAR and
    # VARIANCE to false in order to do nothing except propagate a
    # variance if one exists. Except this doesn't work so we currently
    # do an ndfcopy.
    #
    # If there are multiple images then we have to be aware of the
    # origin of these images. 
    #
    # For processing FRAME mosaics, the input images will have no
    # variance so variance=f, but we still want an output variance
    # based on the spread of input values and thus genvar=t
    #
    # For processing GROUP images then we assume that the input images
    # have variance and that it should be used for weighting. This
    # means that genvar must be false (we want to use the variances
    # already present) and that variance must be true (we want to use
    # those variances for weighting the data).

    if ( $nfiles > 1 ) {
      my $moslist = $filelist->file;
      my $weighting = "genvar=f variance=f";
      $weighting = ( $usegrp ) ? "genvar=f variance=f" : "genvar=t variance=f";
      # If we are creating the group image, first check the bounds to
      # make sure the image will not exceed 2 GB on disk - this should
      # probably be a separate primitive
      my $bounds = "lbnd=! ubnd=!";
      if ( $usegrp ) {
	my $bndargs = "ref=$refimage method=$method wlim=$wlim lbnd=! ubnd=! "
	  ."out=! $weighting in=^$moslist";
	$Mon{kappa_mon}->obeyw("wcsmosaic","$bndargs");
	my ($ORAC_STATUS, @lbound) = $Mon{kappa_mon}->get("wcsmosaic","lbound");
	($ORAC_STATUS, my @ubound) = $Mon{kappa_mon}->get("wcsmosaic","ubound");

	my $xsize = $ubound[0] - $lbound[0] + 1;
	my $ysize = $ubound[1] - $lbound[1] + 1;
	my $numpix = $xsize*$ysize;
	# MAXPIX is derived from tests with MAKEMAP and represents the
	# largest number of pixels a map can have before the file size
	# exceeds 2 GB when listed with --si. This allows for the
	# presence of DATA and VARIANCE arrays along with EXP_TIME and
	# WEIGHTS components.
	if ( $numpix > MAXPIX ) {
	  my $scalefactor = sqrt(MAXPIX / $numpix);
	  my $newxsize = int($xsize * $scalefactor);
	  my $newysize = int($newxsize * $ysize / $xsize);
	  my $dx = int($xsize * ( 1.0 - $scalefactor ) / 2.0);
	  my $dy = int($ysize * ( 1.0 - $scalefactor ) / 2.0);
	  # Reduce the bounds equally. NOTE: exp_time handling will
	  # also have to take notice of this
	  $lbound[0] += $dx;
	  $ubound[0] -= $dx;
	  $lbound[1] += $dy;
	  $ubound[1] -= $dy;
	  $scalefactor = sprintf "%5.3f", $scalefactor;
	  orac_warn "Output image will exceed maximum size, scaling each axis by $scalefactor\n";
	  # Convert scalefactor to a percentage of original area
	  $scalefactor *= (100*$scalefactor);
	  $scalefactor = sprintf "%4.1f", $scalefactor;
	  orac_warn "Output image will only contain inner $scalefactor % of mapped area\n";
	  $bounds = "lbnd=[$lbound[0],$lbound[1]] ubnd=[$ubound[0],$ubound[1]]";
	  push (@bounds, @lbound);
	  push (@bounds, @ubound);
	}
      }
      my $args = "ref=$refimage method=$method wlim=$wlim ".
	"out=$out in=^".$moslist." $weighting $bounds";
      $Mon{kappa_mon}->obeyw("wcsmosaic","$args");
    } else {
      # Just do an ndfcopy of the input file to the output. Note that
      # if there is only one input file then $in will be it
      $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$in out=$out");
    }
  }
  # HACK for renaming group output
  if ( $usegrp ) {
    # Use the inout method to get filename. Note that it generates a
    # warning but it's harmless
    my $outname = $Grpobj->inout("_mos");

    my $bounds = ( scalar(@bounds) == 4 ) ? \@bounds : undef;
    # Add up the exp_time and weights components
    _ADD_IMAGES_ INLIST=\@mosfiles OUT=$out COMPS=EXP_TIME,WEIGHTS BOUNDS=$bounds

    rename $out.$Grpobj->filesuffix, $outname.$Grpobj->filesuffix
      or die "Error renaming temp file to output Group mosaic"; # horrible hack KLUGE

    # Register new output file with Grp
    $Grpobj->file( $outname );
    $Grpobj->readhdr;
  } else {
    # Add up the exp_time and weights components
    _ADD_IMAGES_ INLIST=\@mosfiles OUT=$out COMPS=EXP_TIME,WEIGHTS
    # Register new Frm file names
    $Frmobj->files( $out );
  }
  orac_print " done.\n"; # Making mosaic
  # Set NEWIMAGE flag
  $_MAKE_MOSAIC_{NEWIMAGE} = 1;
} else {
  $_MAKE_MOSAIC_{NEWIMAGE} = 0;
}

