# -*-perl-*-

=head1 NAME

_CREATE_FOCUS_CUBE_ - Create a cube suitable for analysis by the POINTING_FOCUS task

=head1 DESCRIPTION

This primitive create a 3-D data cube for analysis by the
POINTING_FOCUS task to determine the FOCUS offsets for the current SMU
axis. The primitive checks for the OBSEND flag in the FITS header and
only proceeds if true. The sub-group mosaics created for each focus
position (FOCPOSN) have a third axis added before they are combined
into a cube. A new WCS component is created based on the existing SKY
frame with the addition of a mapping from grid to mm offset for the
third axis.

Once the cube has been constructed, the primitive writes the name of
the file into a flag file which the POINTING_FOCUS task reads before
calculating the FOCUS offset.

=head1 ARGUMENTS

The following argument is supported:

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is 1 (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item ATOOLS

ASTGETMAPPING, ASTWINMAP, ASTCMPMAP, ASTFRAME, ASTGETFRAME,
ASTCMPFRAME, ASTADDFRAME, ASTFRAMESET

=item KAPPA

NDFCOPY, PASTE, SETBOUND, SETORIGIN

=item CCDPACK

MAKEMOS

=back

=head1 OUTPUT DATA

This primitive writes a .ok file in $ORAC_DATA_OUT for the JCMT
POINTING_FOCUS task to calculate the actual pointing offsets used by
the telescope.

=head1 FUTURE DEVELOPMENT

Things to add: 
i) Check the number of subgroups = NFOCSTEP; 
ii) Crop images around source

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2007-2008 the University of British Columbia. All Rights
Reserved.

=cut

# Should I be verbose? (Default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Flag to indicate if we have a FOCUS observation
my $focusobs = ( uc($Frm->uhdr('ORAC_OBSERVATION_TYPE')) eq "FOCUS" ) ? 1 : 0;

# Do we have a completed FOCUS observation, and does the cube already
# exist? Other checks: should be a standard source
if ( $focusobs && $Frm->uhdr("OBSEND") && !$Grp->uhdr("FOCUS_CUBE") ) {
  # Which axis are we dealing with?
  my $axis = $Frm->hdr("FOCAXIS");

  # Work out how many focus positions we have actually got
  my @focposns = $Grp->memberhdrvals( "FOCPOSN" );

  # Reminder to think about this
  if ( scalar(@focposns) ne $Frm->hdr("NFOCSTEP") ) {
    orac_warn "uh oh - number of focus positions found (".scalar(@focposns).") is not the same as the number of focus positions indicated in the header (".$Frm->hdr("NFOCSTEP").")";
  }

  # Store this list for subsequent use by _FIND_FOCUS_OFFSETS_
  $Grp->uhdr("FOCPOSNS",\@focposns);
  # Create lookup table for focus position and plane file extension
  my $nfoc = scalar( @focposns);
  my %focposidx;
  for my $i ( 0 .. $#focposns) {
    $focposidx{$focposns[$i]} = "_foc".($i+1);
  }

  # Create the cube:
  # 1) Retrieve SKY mapping/frame for later use
  # 2) Add a third axis to each plane image, shift the pixel origin of
  #    that axis to correspond to the file extension
  # 3) Define name (add _foc at end)
  # 4) Paste the individual images together to make the cube
  # 5) Create new 3-D WCS frameset for cube using stored SKY mapping &
  #    frame
  # 6) Write .ok file for the POINTING_FOCUS task to pick up

  # group all the frames by FOCPOSN (which is guaranteed to be distinct
  # in each Frm)
  my @unsortedsubgrps = $Grp->subgrps( "FOCPOSN" );

  # The subgrps array must be sorted by FOCPOSN
  my @subgrps;
  for my $i ( 0 .. $#focposns ) {
    foreach my $subgrp ( @unsortedsubgrps ) {
      push ( @subgrps, $subgrp)
	if ($subgrp->members->[0]->hdrval("FOCPOSN") == $focposns[$i]);
    }
  }

  # Loop over each Frame to create a Frame mosaic
  my @planes;
  my $args;
  my $i = 0;
  foreach my $subgrp ( @subgrps ) {
    $i++;
    my @focfiles = map { $_->files } $subgrp->members;
    my $focposn = $subgrp->members->[0]->hdrval("FOCPOSN");
    orac_print "Processing focus position $axis = $focposn mm (offset #$i)\n"
        if $verbose;

    # Define output file based on Group file name
    my $planeimage = $Grp->inout( $focposidx{$focposn} );
    # Set the NDF title string
    my $title = $focposidx{$focposn};
    $title =~ s/\_foc//;	# remove underscores
    $title = "'Focus".$title." $axis=$focposn mm'";

    # Create single image for the current focus plane
    if ( @focfiles > 1 ) {
      my $moslist = write_file_list( @focfiles );
      my $mosargs = "in=^".$moslist." out=$planeimage method=median ref=! logto=neither nousevar nogenvar title=$title";
      $Mon{ccdpack_reg}->obeyw("makemos","$mosargs");
    } else {
      my $cpargs = "in=".$focfiles[0]." out=$planeimage title=$title";
      $Mon{ndfpack_mon}->obeyw("ndfcopy","$cpargs");
    }
    # Store output file in Frm
    $subgrp->files( $planeimage );
    # Display this image
    $Display->display_data( $subgrp ) if (defined $Display);

    # Derive sky mapping and frame
    $args = "this=$planeimage iframe1=ast__base iframe2=ast__current result=skymap$$.ast";
    $Mon{atools_mon}->obeyw("astgetmapping","$args");
    $args = "this=$planeimage iframe=ast__current result=skyframe$$.ast";
    $Mon{atools_mon}->obeyw("astgetframe","$args");

    # Now add a 1-pixel-wide third axis
    $args = "ndf=$planeimage(,,1:1)";
    $Mon{ndfpack_mon}->obeyw("setbound","$args");
    # Set the origin accordingly
    $args = "ndf=$planeimage origin=[1,1,$i]";
    $Mon{ndfpack_mon}->obeyw("setorigin","$args");

    # Store image name in array for pasting into the cube
    push ( @planes, $planeimage );
  }

  # Check that we can make at least 3 planes on a cube to fit a quadratic
  orac_warn "Number of SMU positions is not sufficient to create a valid FOCUS cube\n"
    if ( $nfoc < 3 );
  
  # Define output cube name - replace _mos with _foc
  my $cubename = $Grp->inout("_foc");
  # Store complete filename for later use
  $Grp->uhdr("FOCUS_CUBE", $cubename.$Grp->filesuffix);

  # Combine individual FOCPOSN mosaics into a 3-D cube
  my $inlist = write_file_list( @planes );
  $args = "in=^".$inlist." p1=! out=$cubename title='FOCUS cube'";
  $Mon{kappa_mon}->obeyw("paste","$args");
  orac_print "Creating FOCUS cube..." if $verbose;
  undef $inlist;

  # Now create suitable 3-D frameset to ensure 3rd axis is
  # offset in millimetres. Method mirrors that in
  # _CREATE_CUBE_WCS_ First create a FRAME for the focus offsets
  $args = "naxes=1 result=focusframe$$.ast options='Title=SMU offset on $axis axis,Label=SMU offset,Unit=mm,Domain=SMU-POSN'";
  $Mon{atools_mon}->obeyw("astframe","$args");
  # Combine this FRAME with the above SKYFRAME to create a compound frame, CMPFRAME
  $args = "frame1=skyframe$$.ast frame2=focusframe$$.ast options=! result=cmpframe$$.ast";
  $Mon{atools_mon}->obeyw("astcmpframe","$args");
  # Define a WINMAP to describe the third axis
  my $focmin = $focposns[0];
  my $focmax = $focposns[-1];
  $args = "ncoord=1 ina=1 inb=$nfoc outa=$focmin outb=$focmax options=! result=focusmap$$.ast";
  $Mon{atools_mon}->obeyw("astwinmap","$args");
  # Combine this WINMAP with the above SKYMAP to create a compund mapping, CMPMAP
  $args = "map1=skymap$$.ast map2=focusmap$$.ast series=f options=! result=cmpmapping$$.ast";
  $Mon{atools_mon}->obeyw("astcmpmap","$args");
  # Create an empty 3-D GRID frame
  $args = "naxes=3 options='Domain=GRID' result=grid$$.ast";
  $Mon{atools_mon}->obeyw("astframe","$args");
  # Add it to a skeleton FRAMESET
  $args = "frame=grid$$.ast options=! result=newwcs$$.ast";
  $Mon{atools_mon}->obeyw("astframeset","$args");
  # Add the CMPFRAME to the FRAMESET using the CMPMAP to tie it
  # to the GRID frame. Store as WCS in the output cube.
  $args = "this=newwcs$$.ast iframe=ast__base map=cmpmapping$$.ast frame=cmpframe$$.ast result=$cubename";
  $Mon{atools_mon}->obeyw("astaddframe","$args");
  orac_print " adding WCS..." if $verbose;

  # Remove all of the .ast text files with the mapping/frame info
  unlink glob( "*$$.ast" );
    
  # OK a useable cube now exists - write the .ok file in output
  # directory Format obsnum
  my $obsnum = sprintf "%05d", $Frm->hdrval('OBSNUM');
  # Define filename
  my $okfilename = ".s".$Frm->hdrval('UTDATE')."_".$obsnum.".ok";

  # Open the file for writing
  my $okfile = new IO::File("> $okfilename");
  if ( defined $okfile ) {
    print $okfile $cubename . $Grp->filesuffix ."\n";
  } else {
    orac_warn "Unable to create .ok file, $okfilename: $!\n";
  }
  # Close the file: the POINTING_FOCUS task can now do its thang
  $okfile->close;

  # Store the cube name as the Grp file
  $Grp->file($cubename);

  orac_print (" done.\n");
  orac_print ("Cube created successfully and ready for processing.\n", 'green');
  $Grp->uhdr("FOCUS_CUBE",1);
} else {
  $Grp->uhdr("FOCUS_CUBE",0);
}
