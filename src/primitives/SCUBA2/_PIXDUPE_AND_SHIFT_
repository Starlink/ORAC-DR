#! -*-perl-*-

=head1 NAME

_PIXDUPE_AND_SHIFT_ - Regrid an image with a smaller pixel size

=head1 DESCRIPTION

This primitive regrids an image onto a grid with a smaller pixel scale
using the KAPPA C<pixdupe> command and then apply a fractional pixel
shift using AST. It is designed for use with SCUBA2 observing in STARE
mode to take account of the undersampling at 450 um.

The user supplies the image name (no default). Optional parameters are
the expansion factor by which the pixels are reduced and the (x,y)
pixel shift. The `extra' pixels generated by the duplication are
blanked to allow offset images to be mosaicked.

The default value for the expansion factor is 2, and the default shift
is (-0.5,-0.5) pixels. These probably should not be changed.

When pixdupe creates the new image, the centre coordinates of the
original pixel remains unachanged. However, for the SCUBA2 450-um
STARE data, we actually want to attach those coordinates to the bottom
single unblanked pixel; hence the need for the shift.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item FACTOR

The factor by which the pixel scale should be reduced. Default value is 2.

=item IMAGE

Name of the image to be regridded

=item SHIFT

A scalar or an array with the magnitude of the shift in pixels. A
negative shift indicates a shift to the East or South. If a single
value (scalar) is given then the shift is assumed to be the same in
both the X and Y directions.

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is true.

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

C<pixdupe>

=item ATOOLS

C<astshiftmap>, C<astremapframe>

=back

=head1 OUTPUT DATA

On completion the primitive hash C<%_PIXDUPE_AND_SHIFT_> contains the
following keys:

=over 4

=item  RESULTS

The name of the file which has been pixduped and shifted.

=head1 KNOWN ISSUES

...

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005 University of British Columbia. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# First check if we should be doing this
#return unless ($Frm->hdr->{SUBARRAY} =~ /s4/ && uc($Frm->hdr->{OBSMODE}) eq "STARE");

# Should I be verbose? (default to yes)
my $verbose = (exists $_PIXDUPE_AND_SHIFT_{VERBOSE} &&
               defined $_PIXDUPE_AND_SHIFT_{VERBOSE}) ?
               $_PIXDUPE_AND_SHIFT_{VERBOSE} : 1;

# Image name
my $infile = undef;
if (exists $_PIXDUPE_AND_SHIFT_{IMAGE} && defined $_PIXDUPE_AND_SHIFT_{IMAGE}) {
    $infile = $_PIXDUPE_AND_SHIFT_{IMAGE};
} else {
    # Exit with no file name
    orac_throw "Error: must supply filename to _PIXDUPE_AND_SHIFT_\n";
}

# Scale factor, default = 2
my $factor = (exists $_PIXDUPE_AND_SHIFT_{FACTOR} &&
               defined $_PIXDUPE_AND_SHIFT_{FACTOR}) ?
               $_PIXDUPE_AND_SHIFT_{FACTOR} : 2;

# Origin shift, read as a string, must convert into an array.
my $shiftref = (exists $_PIXDUPE_AND_SHIFT_{SHIFT} && 
		defined $_PIXDUPE_AND_SHIFT_{SHIFT}) ? 
                $_PIXDUPE_AND_SHIFT_{SHIFT} : [-0.5,-0.5];

# Set output file as input file but with _str suffix
#my $outfile = $Frm->inout("_str"); # STR = STare Regrid
my $outfile = $infile."_str"; # STR = STare Regrid ### KLUDGE ###

my $params = "in=$infile out=$outfile expand=$factor imask=\[1,1\]";

$Mon{kappa_mon}->obeyw("pixdupe", "$params");

#use Data::Dumper;
#print Dumper($shiftref);

# Check if only 1 value was given and if so set both shifts equal
#if (ref($shiftref) eq "SCALAR") {
#    $shiftref = [$$shiftref,$$shiftref];
#}
#$shiftref=[-0.5,-0.5];

# Temporary file for holding the ShiftMap
my $shiftmapfile = new ORAC::TempFile;

# Create the ShiftMap
my $shiftargs = "shift=\[$shiftref->[0],$shiftref->[1]\] ncoord=2 options=! result=".$shiftmapfile->file;
$Mon{atools_mon}->obeyw("astshiftmap","$shiftargs");

# Apply the ShiftMap to the input image
my $remapargs = "iframe=AST__BASE map=".$shiftmapfile->file." result=$outfile this=$outfile";
$Mon{atools_mon}->obeyw("astremapframe","$remapargs");

$_PIXDUPE_AND_SHIFT_{RESULTS} = $outfile;
