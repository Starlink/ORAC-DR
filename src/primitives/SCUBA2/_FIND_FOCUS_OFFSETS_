# -*-perl-*-

=head1 NAME

_FIND_FOCUS_OFFSETS_ - Calculate best-fit focus position

=head1 SYNOPSIS

_FIND_FOCUS_OFFSETS_

=head1 DESCRIPTION

This primitive takes the data cube formed by _CREATE_FOCUS_CUBE_ and
loops over each plane (SMU position) to fit the source with a PSF. The
amplitude is stored and used to create a 1-D NDF of amplitude as a
function of focus position. A quadratic is fitted to these data and
the best-fit focus position calculated. The result is written to a log
file if desired.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<VERBOSE>

Flag to indicate whether informational messages should be
given to the user. Default is 1 (true).

=item B<LOGFILE>

Flag to indicate whether to write results to a log file. Default is 1
(yes).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item FIGARO:

FITPOLY

=item KAPPA:

NDFTRACE, TRANDAT

=item ORAC-DR PRIMITIVES

_CENTROID_IMAGE, _FIT_PSF_, _GET_LOG_PARAMETERS_

=back

=head1 NOTES

The fit for focus position will only be carried out if a source could
be fitted in three or more planes of the cube.

=head1 OUTPUT FILES

The focus position derived by this primitive is stored in the log file
C<log.focus>.

=head1 LOGFILE FORMAT

The logfile has the following columns:

=over 4

=item UT

The UT date in C<YYYYMMDD.frac> format.

=item HST

The time of the observation in Hawaii.

=item Obs

The observation number.

=item Source

The source name.

=item Mode

The observing mode.

=item Filter

The specific filter associated with the FCF result.

=item Elevation

The elevation of the observation.

=item CSO

Equivalent CSO tau derived from the tau used to reduce
the observation.

=item Tau

The tau value used for the reduction.

=item Seeing

The seeing value as stored in the header.

=item Axis

The axis (X, Y, or Z) in which the SMU was moved.

=item Pos

Best-fit focus position in mm.

=back

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 the University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Should I be verbose? (Default to yes)
my $verbose = get_prim_arg( $_PRIM_ARGS_, "VERBOSE", 1);

# Do we want the results written to a log file? Default is Yes.
my $uselog = get_prim_arg( $_PRIM_ARGS_, "USELOG", 1);

# Check that we have a FOCUS observation
if ( uc($Frm->hdr('OBS_TYPE')) eq "FOCUS" ) {

  # Do we have a focus cube to examine?
  if ( $Grp->file_exists && $Grp->uhdr("FOCUS_CUBE") ) {

    # Obtain name of cube to analyze
    my $focuscube = $Grp->file;

    orac_print "Processing FOCUS cube... " if $verbose;

    # Get the relevant info from the cube
    $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$focuscube");
    my ($ORAC_STATUS, @vals) = $Mon{ndfpack_mon}->get("ndftrace","lbound");
    my $focsteplo = $vals[2];
    ($ORAC_STATUS, @vals) = $Mon{ndfpack_mon}->get("ndftrace","ubound");
    my $focstephi = $vals[2];

    my (@amps, @fwhms, @focposns, @fitted);
    # Retrieve list of focus positions
    if ( $Grp->uhdr("FOCPOSNS") ) {
      @focposns = @{ $Grp->uhdr("FOCPOSNS") };
    } else {
      orac_err "Error: no list of FOCUS positions in Group header. Did something go wrong?\n";
    }

    orac_print "Locating and fitting peak positions...\nPlane " if $verbose;
    for my $plane ($focsteplo..$focstephi) {
      orac_print "$plane..." if $verbose;
      # Retrieve filename to determine centroid
      my $focusfile = "$focuscube(,,$plane)";
      # Get estimate of source position for fitting in offset coords
      _CENTROID_IMAGE_ IMAGE=$focusfile VERBOSE=0
      my $results = $_CENTROID_IMAGE_{RESULTS};
      my ( $x, $y ) = (defined $results) ? @{ $results } : (undef, undef);
      if ( defined $x && defined $y ) {
	# Write position to ASCII file for reading into PSF
	my $cofile = new ORAC::TempFile;
	print {$cofile->handle} $x ." ".$y."\n";
	$cofile->handle->close;

	# Fit a PSF to image
	_FIT_PSF_ IMAGE=$focusfile COFILE=$cofile->file VERBOSE=0 GAUSSIAN=0
	# Store fit parameters
	my $amp = $_FIT_PSF_{AMPLITUDE};
	my $fwhm = $_FIT_PSF_{FWHM};
	my $axisr = $_FIT_PSF_{AXISR};
	if ( defined $amp && defined $fwhm ) {
	  # Calculate mean FWHM
	  $fwhm *= sqrt($axisr);
	  # Add the Amplitude and FWHM to the arrays if valid values were returned
	  push (@amps, $amp);
	  push (@fwhms, $fwhm);
	  push (@fitted, $plane-1);
	} else {
	  orac_warn " Unable to fit source for plane $plane in focus cube\n";
	}
      } else {
	orac_warn " Unable to locate centroid for plane $plane in focus cube\n";
      }
    }
    orac_print " done\n";

    # Warn user if too many fits failed: need 3 points to define a quadratic
    if ( scalar(@amps) < 3 || scalar(@fwhms) < 3 ) {
      orac_print "\n";
      orac_warn " insufficient number of fits - unable to determine focus offsets\n";
    } else {
      my $npts = scalar(@amps);
      orac_print "Calculating best-fit focus position with $npts measurements... "
	if $verbose;

      # Write out positions to tmp file, subtract half a pixel to
      # convert to pixel coordinates
      my $inresfile = new ORAC::TempFile;
      my $outresfile = new ORAC::TempFile;
      foreach my $i (0 .. $#amps) {
	print {$inresfile->handle} ($focposns[$fitted[$i]]-0.5)." ".$amps[$i]."\n";
      }
      $inresfile->handle->close;
      # Convert text array into a 1-D NDF with trandat
      my $args = "dtype='_DOUBLE' poscols=1 valcol=2 pscale=1 freename=".$inresfile->file." ndf=".$outresfile->file;
      $Mon{kappa_mon}->obeyw("trandat","$args");
      # Run FITPOLY to get fit
      $args = "device=! mask1=$focposns[$fitted[0]] order=2 mask2=$focposns[$fitted[-1]] dialog=f logfil=! comp=1 in=".$outresfile->file;
      $Mon{figaro4}->obeyw("fitpoly","$args");
      ($ORAC_STATUS, my @coeffs) = $Mon{figaro4}->get("fitpoly","fitcoeffs");
      # Now find best-fit position, trap cases when either coefficient is zero
      my $fmax = ( $coeffs[1] == 0 ) ? 0 :
	( ($coeffs[2] == 0 ) ? undef : -$coeffs[1]/(2.*$coeffs[2]) );
      orac_print ("done\n") if $verbose;
      # Tidy up
      undef $inresfile;
      undef $outresfile;

      # FOCAXIS is constant for an observation so can just use value in
      # current Frm
      my $focaxis = $Frm->hdr('FOCAXIS');
      # Print result for user to see
      if ( defined $fmax ) {
	$fmax = sprintf "%5.3f", $fmax;
	orac_print ("Best-fit focus position along $focaxis axis = $fmax mm (from $npts measurements)\n", "green");
      } else {
	orac_warn ("Unable to determine best-fit focus position along $focaxis axis\n");
      }

      # Write results to log file - if desired
      if ( $uselog && (defined $fmax) ) {
	# Force read of Group header for logging purposes
	$Grp->readhdr;
	my $time = gmtime();
	my $focuslog = new ORAC::LogFile("log.focus");
	$focuslog->header("#Focus log file - created on $time UT",
			  "#\n# UT                HST   Obs Source       Mode        Filter El CSO    Tau   Seeing Axis  Pos",
			  "#---------------------------------------------------------------------------------------------------"
	  );

	# Get basic logging parameters from Group file
	_GET_LOG_PARAMETERS_ GROUP=1
        my ( $uttime, $hst, $run, $src, $mode, $filter, $el, $cso, $tau, $see )
          = @{ $_GET_LOG_PARAMETERS_{PARAMS} };

	# Write the entry:
	$focuslog->addentry("$uttime $hst $run $src $mode   $filter  $el $cso $tau  $see   $focaxis    $fmax");
      }

    }
  }

} # FOCUS obs check
