# -*-cperl-*-

=head1 NAME

_MAKEMAP_FRAME_ - convert time-series data into an image

=head1 SYNOPSIS

  _MAKEMAP_FRAME_ PIXSIZE=7.5

  _MAKEMAP_FRAME_ MYCONFIG=1 NUMITER=10 BADFRAC=0.1

=head1 DESCRIPTION

This primitive takes time-series data for the current Frame and uses
SMURF MAKEMAP to construct an image. The user may specify either the
simple rebinning method or the full iterative solution.

For the iterative map-maker a configuration file must be specified. By
default, the system configuration file is used. However, the user may
override this behaviour by specifying an alternative configuration
file with the B<CONFIG> parameter. See
L<_GET_MAKEMAP_CONFIG_|_GET_MAKEMAP_CONFIG_> for further details.

The output file size is kept below 2 GB which in practice corresponds
to an image with about 60 million pixels (7745 pixels on a side, or
6.45 degrees on the sky for 3-arcsec pixels). Currently the primitive
creates a smaller image if the limit is exceeded. Each dimension is
reduced in proportion. The primitive aborts if the memory requirements
for processing the data exceeds that available.

This is a many to one operation, with only a single output file
created.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<CONFIG>

Name of config file to be used. Default is to use one based on the
value of C<MAKEMAP_CONFIG_TYPE> in the Frame uhdr.

=item B<INFILES>

A switch to determine how many files are given to makemap.  Valid
values are C<FRAME> (default) for all files in the current Frame
object, C<NEW> for all data taken since last map was made, C<OBS> for
all files which are part of the current observation, or C<ALL> for all
valid files for all Frames in the current Group object.

=item B<METHOD>

Image reconstruction method. May be C<REBIN> to use a simple rebinning
scheme or C<ITER> to use the iterative map-maker. The default is
C<ITER>.

=item B<PIXSIZE>

Size of the output map pixels in arcsec. The default is wavelength
dependent and is determined by C<MAKEMAP> (4 arcsec at 850 um, 2 arcsec
at 450 um).

=item B<SYSTEM>

Coordinate system for output image. May be any supported by
C<AST>. Default is C<TRACKING>.

=item B<SPREAD>

Desired pixel-spreading scheme for the rebin method. May be either
C<NEAREST> for nearest-neighbour resampling or C<LINEAR> for bi-linear
resampling.  Default is C<NEAREST>.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item SMURF

MAKEMAP

=item ORAC-DR PRIMITIVES

_GET_MAKEMAP_CONFIG_

=back

=head1 NOTES

The user should take care when calling with the B<INFILES> parameter
set to C<ALL> or C<OBS>. It is possible that makemap will be run
multiple times on almost the same set of data files. This is probably
not desireable. See L<_SUMMIT_STEER_|_SUMMIT_STEER_> and
L<_PROCESS_SCAN_DATA_|_PROCESS_SCAN_DATA_> for information on one way
to avoid this.

For B<INFILES>=C<FRAME> it is assumed that the data are not
flatfielded and thus dark frames need to be added to the list of input
files. Conversely, for C<ALL> it is assumed that the input data are
already flatfielded and thus there is no need for dark frames.

=head1 OUTPUT DATA

The Frame C<isgood> flag is set to false if MAKEMAP fails for any
reason.

The Frame uhdr entries C<EXP_TIME>, C<WEIGHTS>, C<SKY_SUBTRACTION> and
C<EXTINCTION> are set to 1 on success.

=head1 OUTPUT FILES

Creates a single output file with a C<_fmos> suffix.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2008-2010 University of British Columbia.
Copyright (C) 2008 the Particle Physics and Astronomy Research
Council. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Define the maximum number of pixels in a tile
use constant MAXPIX => 60e6;

if ($Frm->uhdr("DARKONLY")) {
  # OK this is a dark Frame so we don't want to mosaic it
  $Frm->isgood(0);
  $Grp->check_membership;
  $Frm->uhdr("NOCALIB",1);
  # Set a flag to indicate a map was not made
  $Frm->uhdr("NEWIMAGE",0);
} else {
  # Pixel size for output image
  my $pixsize = get_prim_arg( $_PRIM_ARGS_, "PIXSIZE", undef);

  # Output coordinate system - default is TRACKING
  my $system = get_prim_arg( $_PRIM_ARGS_, "SYSTEM", "TRACKING");

  # Pixel-spreading scheme
  my $spread = lc(get_prim_arg( $_PRIM_ARGS_, "SPREAD", "nearest"));

  # Reset to "nearest" if an unsupported scheme is given
  if ( ($spread ne "nearest") && ($spread ne "linear") ) {
    orac_warn "Unsupported pixel-spreading scheme, $spread: using NEAREST\n";
    $spread = "nearest";
  }

  # Method for reconstructing map
  my $method = lc(get_prim_arg( $_PRIM_ARGS_, "METHOD", "iter"));
  my $iterate = 0;
  # Minimum match on method
  if ( $method =~ /^iter/ ) {
    $method = "iterate";
    $iterate = 1;
  } elsif ( $method =~ /^reb/ ) {
    $method = "rebin";
  } else {
    orac_warn "Unrecognized MAKEMAP METHOD, $method: assuming REBIN\n";
    $method = "rebin";
  }

  my $obsnum = $Frm->hdr("OBSNUM");

  # How many files are we making a map with?
  my $infiles = get_prim_arg($_PRIM_ARGS_, "INFILES", "FRAME");

  my @infiles;
  if ( $infiles eq "FRAME" ) {
    # Use all files in current Frame
    @infiles = $Frm->files;
  } elsif ( $infiles eq "OBS" ) {
    # Create a sub-group for the current observation only
    my $subGrp = $Grp->subgrp(OBSNUM => $obsnum);
    foreach my $frmobj ( $subGrp->members ) {
      # Only add data from frames which do not contain images
      push (@infiles, $frmobj->files)
	if ($frmobj->isgood && !$frmobj->uhdr("NEWIMAGE"));
      # Don't need this frame any more so mark as bad
      $frmobj->isgood(0);
    }
  } elsif ( $infiles eq "NEW" ) {
    # Use all new data in current observation which was taken since
    # last map was made
    my $subGrp = $Grp->subgrp(OBSNUM => $obsnum);
    foreach my $frmobj ( $subGrp->members ) {
      # `New' data are marked with isgood = -1
      if ($frmobj->isgood == -1) {
        push (@infiles, $frmobj->files);
	# Don't need this frame any more so mark as bad
        $frmobj->isgood(0);
      }
    }
  } elsif ( $infiles eq "ALL" ) {
    # Use ALL data from all members of Group
    foreach my $frmobj ( $Grp->members ) {
      push (@infiles, $frmobj->files) if ($frmobj->isgood);
    }
  }

  # Quit processing if there is no data to make a map
  my $object = $Frm->hdr('OBJECT');
  orac_term "No good data for $object from obs $obsnum with which to make a map\n"
      unless (@infiles);

  # Write list of filenames to a temp file
  my $inlist = write_file_list( @infiles );

  # Set output filename
  my ($in, $out) = $Frm->inout('_fmos');
  $out = $Frm->rewrite_outfile_subarray( $out );

  # Set BBM parameter to null until we find BBMs are worth using
  my $bbm ="!";

  # This sets the upper limit on the output map size - MAXPIX should be
  # small enough to keep the map size below 2 GB
  my $tiledims = int(sqrt(MAXPIX));

  # Makemap argument list
  my $args = "in=^$inlist out=$out spread=$spread bbm=$bbm "
    ."system=$system method=$method tiledims=$tiledims";

  $args .= " pixsize=$pixsize" if (defined $pixsize);

  # Add CROTA=0 and ALIGNSYS=true for AzEl maps
  $args .= " crota=0 alignsys=true" if ( uc($system) eq "AZEL");

  my $config;
  if ( $iterate ) {
    # Get name of optional user-specified config file
    my $config = get_prim_arg( $_PRIM_ARGS_, "CONFIG", undef );

    _GET_MAKEMAP_CONFIG_ CONFIG=$config
    $args .= " config=^".$_GET_MAKEMAP_CONFIG_{CONFIGFILE};
  }

  # Call makemap - really must have some sort of feedback to user
  orac_print "Calling makemap using $method method\n";

  unless ( $Frm->uhdr("QUICKLOOK") ) {
    # First time round, determine number of pixels in the output map
    _CHECK_MAP_BOUNDS_ IN=$inlist TASK=MAKEMAP
    if ( $_CHECK_MAP_BOUNDS_{NEWBOUNDS} == 1 ) {
      my @lbound = @{ $_CHECK_MAP_BOUNDS_{LBOUND} };
      my @ubound = @{ $_CHECK_MAP_BOUNDS_{UBOUND} };
      # Append the new bounds to the list of arguments
      $args .= " lbnd=[".join(",",@lbound)."] ubnd=[".join(",",@ubound)."]";
    }
  }
  # Now create output map using the new bounds if necessary
  orac_print "Making map: this... may... take... a... while...\n";
  my $SMURF_STATUS = $Mon{smurf_mon}->obeyw("makemap","$args");

  my $fault_msg = "If this failure is not associated with a bad observation please file a fault\n";

  # Check for SMF__NOMEM return status
  if ( $SMURF_STATUS == 235176770 ) {
    # Since makemap failed mark this frame as BAD so it's not included
    # in further processing. Throw an error to skip the rest of the recipe.
    $Frm->isgood(0);
    orac_throw "Output image will exceed maximum size 2 GB - will not continue\n";
  } elsif ( $SMURF_STATUS == ORAC__OK ) {

    # Check that an output file was actually created - in some
    # instances bad data can be dealt with by makemap which then exits
    # with good status and no output file.
    my $fullout = File::Spec->catfile($ENV{ORAC_DATA_OUT}, $out);
    $fullout .= ".sdf" unless ($fullout =~ /.sdf$/);# hack...
    if ( -e $fullout ) {
      # Now, is there any analysis of the model component files that could
      # be useful?

      # Register the new file name
      $Frm->files( $out );

      # Set the title to include the source name and observation number
      my $title = "'$object / obs $obsnum'";
      $Mon{ndfpack_mon}->obeyw("settitle","ndf=$out title=$title");

      # Set Frame EXP_TIME and WEIGHTS flags
      $Frm->uhdr("EXP_TIME",1);
      $Frm->uhdr("WEIGHTS",1);
      # And of course sky subtraction and extinction correction have been
      # applied, though there really isn't much point to setting these
      # other than a desire for consistency.
      $Frm->uhdr("SKY_SUBTRACTION",1);
      $Frm->uhdr("EXTINCTION",1);

      # Set a flag to indicate a new map was made
      $Frm->uhdr("NEWIMAGE",1);

      # Mark current frame as good now that we have a map
      $Frm->isgood(1);

      orac_print "Thank you for waiting; image $out created\n";
    } else {
      # Mark this frame as BAD and throw an error to skip the rest of
      # the recipe. The only reason we would be here is that the data
      # are bad/corrupt.
      $Frm->isgood(0);
      orac_term "Makemap failed to create an output file (corrupt data): data from this Frame will be ignored.\n\n$fault_msg";
      # Set a flag to indicate a map was not made
      $Frm->uhdr("NEWIMAGE",0);
    }
  } else {
    # Set a flag to indicate a map was not made
    $Frm->uhdr("NEWIMAGE",0);
    # If makemap failed for any other reason, mark this frame as
    # BAD. Throw an error to skip the rest of the recipe.
    $Frm->isgood(0);
    orac_term "Makemap failed: data from this Frame will be ignored\n$fault_msg";
  }

}
