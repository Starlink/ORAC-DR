# -*-perl-*-

=head1 NAME

_MAKEMAP_FRAME_ - convert time-series data into an image

=head1 SYNOPSIS

  _MAKEMAP_FRAME_ PIXSIZE=7.5

  _MAKEMAP_FRAME_ MYCONFIG=1 NUMITER=10 BADFRAC=0.1

=head1 DESCRIPTION

This primitive takes time-series data for the current frame and uses
SMURF MAKEMAP to construct an image. The user may specify either the
simple rebinning method or the full iterative solution.

For the iterative map-maker a configuration file must be specified. By
default, the system configuration file is used. However, the user may
override any parameter by specifying the B<MYCONFIG> option and
listing the name and new value of the parameter.

This is a many to one operation, with only a single output file
created.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<METHOD>

Image reconstruction method. May be C<REBIN> to use a simple rebinning
scheme or C<ITER> to use the iterative map-maker. The default is
C<REBIN>.

=item B<MYCONFIG>

A flag to denote that the a user-defined config file is to be
used. Default is 0 (use system config file).

=item B<PIXSIZE>

Size of the output map pixels in arcsec. The default is wavelength
dependent (6 arcsec at 850 um, 3 arcsec at 450 um).

=item B<SYSTEM>

Coordinate system for output image. May be any supported by
C<AST>. Default is C<TRACKING>.

=item B<SPREAD>

Desired pixel-spreading scheme for the rebin method. May be either
C<NEAREST> for nearest-neighbour resampling or C<LINEAR> for bi-linear
resampling.  Default is C<NEAREST>.

=back

In addition, configuration parameters for B<MAKEMAP> may be specified,
provided the B<MYCONFIG> argument is true. See the B<MAKEMAP>
documentation for supported parameters.

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item SMURF

MAKEMAP

=item ORAC-DR PRIMITIVES

_GET_MAKEMAP_CONFIG_

=back

=head1 OUTPUT DATA

The Frame C<isgood> flag is set to false if MAKEMAP fails for any
reason.

The Frame uhdr entries C<EXP_TIME>, C<WEIGHTS>, C<SKY_SUBTRACTION> and
C<EXTINCTION> are set to 1 on success.

=head1 OUTPUT FILES

Creates a single output file with a C<_fmos> suffix.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2008-2009 University of British Columbia and the
Particle Physics and Astronomy Research Council. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Define the maximum number of pixels in a tile
use constant MAXPIX => 60e6;

# Pixel size for output image
my $pixsize = get_prim_arg( $_PRIM_ARGS_, "PIXSIZE", $Cal->pixelscale);

# Output coordinate system - default is TRACKING
my $system = get_prim_arg( $_PRIM_ARGS_, "SYSTEM", "TRACKING");

# Pixel-spreading scheme
my $spread = lc(get_prim_arg( $_PRIM_ARGS_, "SPREAD", "nearest"));

# Reset to "nearest" if an unsupported scheme is given
if ( ($spread ne "nearest") && ($spread ne "linear") ) {
  orac_warn "Unsupported pixel-spreading scheme, $spread: using NEAREST\n";
  $spread = "nearest";
}

# Method for reconstructing map
my $method = lc(get_prim_arg( $_PRIM_ARGS_, "METHOD", "rebin"));
my $iterate = 0;
# Minimum match on method
if ( $method =~ /^iter/ ) {
  $method = "iterate";
  $iterate = 1;
} elsif ( $method =~ /^reb/ ) {
  $method = "rebin";
} else {
  orac_warn "Unrecognized MAKEMAP METHOD, $method: assuming REBIN\n";
  $method = "rebin";
}

# If there are no darks, as will be the case for the online pipeline,
# look for a suitable dark frame in the calibration system. Look for
# SHUTTER subheaders and if there are none, select a dark frame.
my @files = $Frm->files;
if ( defined $Frm->hdr("SUBHEADERS")) {
  my %subheaders = %{ $Frm->hdr->{SUBHEADERS}->[0] };
  # Subheaders should always be defined in offline mode
  unless ( defined $subheaders{"SHUTTER"} ) {
    if ( $Cal->dark ) {
      push (@files, $Cal->dark);
    } else {
      orac_warn "No suitable dark frame found for current observation\n";
    }
  }
}

# Write list of filenames to a temp file
my $inlist = write_file_list( @files );

# Set output filename
my ($in, $out) = $Frm->inout('_fmos');
$out = $Frm->rewrite_outfile_subarray( $out );

# Maximum map-size - set to 2 GB as a default, increase later if the
# iterative map-maker is being used and processing is done in memory.
# Makemap uses maxmem to denote the maximum amount of memory available
# to process the data, not necessarily the size of the output
# map. This primitive uses it to limit the output file size. The
# difference between the two usages amounts to about a factor of 2.
my $maxmem = 4096;

my $tiledims = int(sqrt(MAXPIX));

# Makemap argument list
my $args = "in=^$inlist out=$out pixsize=$pixsize spread=$spread "
          ."system=$system method=$method maxmem=$maxmem tiledims=$tiledims";

my $config;
if ( $iterate ) {
  # Obtain a suitable config file
  my $myconfig = get_prim_arg( $_PRIM_ARGS_, "MYCONFIG",  0 );
  # A new config file might not always be necessary, but should
  # internal consistency checks fail, a modified version will have to
  # be written even if MYCONFIG is 0. Therefore pass in a suitable
  # ORAC::TempFile object.
  $config = new ORAC::TempFile;

  _GET_MAKEMAP_CONFIG_ ARGS=$_PRIM_ARGS_ CONFIG=$config
  $args .= " config=^".$_GET_MAKEMAP_CONFIG_{CONFIG};
}

# Call makemap - really must have some sort of feedback to user
orac_print "Calling makemap using $method method\n";
# First time round, determine number of pixels in the output map by
# setting out=! Use method=rebin to avoid needing to specify any
# further unecessary parameters.
orac_print "Checking output map size... ";
my $mapszargs = "in=^$inlist out=! pixsize=$pixsize method=rebin maxmem=$maxmem";
$Mon{smurf_mon}->obeyw("makemap","$mapszargs");
my ($ORAC_STATUS, @lbound) = $Mon{smurf_mon}->get("makemap","lbound");
($ORAC_STATUS, my @ubound) = $Mon{smurf_mon}->get("makemap","ubound");

my $xsize = $ubound[0] - $lbound[0] + 1;
my $ysize = $ubound[1] - $lbound[1] + 1;
my $outpix = $xsize*$ysize;
if ( $outpix > MAXPIX ) {
  orac_print "Old image dimensions are $xsize x $ysize\n";
  my $scalefactor = sqrt( MAXPIX/$outpix );
  my $newxsize = int($xsize * $scalefactor);
  my $newysize = int($newxsize * $ysize / $xsize);
  my $dx = int($xsize * ( 1.0 - $scalefactor ) / 2.0);
  my $dy = int($ysize * ( 1.0 - $scalefactor ) / 2.0);
  # Reduce the bounds equally.
  $lbound[0] += $dx;
  $ubound[0] -= $dx;
  $lbound[1] += $dy;
  $ubound[1] -= $dy;
  $scalefactor = sprintf "%5.3f", $scalefactor;
  $scalefactor *= (100*$scalefactor);
  orac_print "\n";
  orac_warn "Size will exceed 2 GB, reducing to include central $scalefactor % of mapped area\n";
  orac_print "New image dimensions are $newxsize x $newysize\n";
  # Append the new bounds to the list of arguments
  $args .= " lbnd=[$lbound[0],$lbound[1]] ubnd=[$ubound[0],$ubound[1]]";
} else {
  orac_print "Size within limits, no need to tile.\n";
}
# Now create output map using the new bounds if necessary
orac_print "Making map: this... may... take... a... while...\n";
my $SMURF_STATUS = $Mon{smurf_mon}->obeyw("makemap","$args");
# Check for SMF__NOMEM return status
if ( $SMURF_STATUS == 235176770 ) {
  # Since makemap failed mark this frame as BAD so it's not included
  # in further processing. Throw an error to skip the rest of the recipe.
  $Frm->isgood(0);
  orac_throw "Output image will exceed maximum size $maxmem MB - will not continue\n";
} elsif ( $SMURF_STATUS == ORAC__OK ) {

  # Now, is there any analysis of the model component files that could
  # be useful?

  # Register the new file name
  $Frm->files( $out );

  # Set Frame EXP_TIME and WEIGHTS flags
  $Frm->uhdr("EXP_TIME",1);
  $Frm->uhdr("WEIGHTS",1);
  # And of course sky subtraction and extinction correction have been
  # applied, though there really isn't much point to setting these
  # other than a desire for consistency.
  $Frm->uhdr("SKY_SUBTRACTION",1);
  $Frm->uhdr("EXTINCTION",1);

  orac_print "Thank you for waiting; image $out created\n";
} else {
  # If makemap failed for any other reason, mark this frame as
  # BAD. Throw an error to skip the rest of the recipe.
  $Frm->isgood(0);
  orac_throw "Makemap failed: data from this Frame will be ignored\n";
}

# Delete temporary config file generated by this primitive if present
undef $config if ($config);
