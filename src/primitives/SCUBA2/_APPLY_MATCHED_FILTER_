# -*-cperl-*-

=head1 NAME

_APPLY_MATCHED_FILTER_ - apply a simple matched filter to detect point sources

=head1 SYNOPSIS

 _APPLY_MATCHED_FILTER_

=head1 DESCRIPTION

This primitive applies a matched filter to the supplied input NDF by
smoothing it using either a supplied PSF image or an automatically
generated Gaussian PSF. Each output pixel value is given by:

                      sum( (psf_i/input_variance_i)*input_data_i )
      output_data  =  ---------------------------------------
                      sum( psf_i**2/input_variance_i )

where the sum is over all input pixels that contribute to the output
pixel. The variances stored with the resulting image are given by:

                                     1.0
      output_variance = --------------------------------
                        sum( psf_i**2/input_variance_i )


The input file must contain a variance, though no check is made for
its existence.

If the user does not specify a PSF image then a image containing a
unit-height Gaussian PSF with a FWHM equal to the Airy disk radius is
created. This file has suffix C<_psf> and will be left on disk on
completion of the primitive.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<GROUP>

Flag to denote whether to use the current Group or Frame file. Default
is 0 (use the current Frame).

=item B<IN>

Name of input image. Use file determined by the B<GROUP> parameter
above if not specified.

=item B<PSF>

Name of file containing the PSF to use. May also be specified using
the C<PSF_MATCHFILTER> recipe parameter. If not specified by either
method, a PSF image will be created.

=item B<NORM>

Type of normalization to carry out on the PSF. If C<peak> then PSF is
normalized to a peak of 1; if C<sum> the PSF is normalized to a sum of
1. Default is C<peak>. Only accessed when creating a PSF image.

=item B<OUT>

Name of output image. Default is to use the C<inout> method to create
an output file with the suffix C<_mf>.

=item B<SMOOTH>

A flag to denote whether or not to smooth the image with a larger
gaussian (whose FWHM is given by B<SMOOTH_FWHM>). The smoothed version
is subtracted from the unsmoothed version and the difference is
used in applying the matched filter. Default is 1 (yes).

=item B<SMOOTH_FWHM>

Full-width at half-maximum in arcsec of Gaussian used to smooth input
image and PSF. Default is 30 arcsec at 850 um, 20 arcsec at 450 um.

=item B<STORE>

A flag to denote whether or not the output image is to be stored in
the current Frame or Group. Default is 0 (no).

=item B<VERBOSE>

Flag to denote whether to display extra information. Default is 1 (yes).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

CDIV, CHPIX, CMULT, CONVOLVE, CREFRAME, DIV, GAUSMOOTH, MATHS, MULT,
SETVAR

=back

=head1 OUTPUT DATA

None.

=head1 OUTPUT FILES

If left to use defaults, creates a file with the suffix C<_mf> and
C<_psf>. Otherwise creates the output file specified by the B<OUT>
parameter.

=head1 NOTES

The user-supplied PSF image must satisfy the following criteria:

=over 4

=item *

The centre of the supplied PSF is assumed to be at pixel (0,0).

=item *

The PSF must not contain any bad values.

=item *

The PSF should be normalised to a peak value of unity.

=item *

The PSF must contain floating point values.

=back

Implementation based on the SMURF C<matched-filter> C-shell script by
David Berry E<lt>d.berry@jach.hawaii.edu<gt>.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2010 University of British Columbia. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Is the input file from the current Frame or Group?
my $group = get_prim_arg($_PRIM_ARGS_, "GROUP", 0);
my $Obj;
if ($group) {
  return ORAC__OK unless $Grp->lastmember($Frm);
  $Obj = $Grp;
} else {
  $Obj = $Frm;
 }
# Is the output file to be stored in the current object?
my $store = get_prim_arg($_PRIM_ARGS_, "STORE", 0);

# Obtain input image - default to current file in given object
my $in = get_prim_arg($_PRIM_ARGS_, "IN", $Obj->file);

# Obtain output image - use object inout method if not specified
my $out = get_prim_arg($_PRIM_ARGS_, "OUT", undef);
if (!$out) {
  $out = $Obj->inout("_mf");
  # Store name of output file for retrieval
  $_PRIM_ARGS_->{OUT} = $out;
}

# Obtain optional PSF image
my $psf = get_prim_arg($_PRIM_ARGS_, "PSF", undef);

# The input image and PSF may be smoothed by a gaussian with given
# FWHM and subtracted from each. The default size is 30" at 850 uma,
# 20" at 450 um.
my $smooth = get_prim_arg($_PRIM_ARGS_, "SMOOTH", 1);
$smooth = $Frm->uhdr("RECPAR_SMOOTH_DATA")
  if (defined $Frm->uhdr("RECPAR_SMOOTH_DATA"));
my $long = ( $Frm->hdr("FILTER") =~ /850/ ) ? 1 : 0;
my $smooth_fwhm = get_prim_arg($_PRIM_ARGS_, "SMOOTH_FWHM",
			       ($long) ? 30.0 : 20.0);
# Override with recipe parameter
$smooth_fwhm = $Frm->uhdr("RECPAR_SMOOTH_FWHM")
  if (defined $Frm->uhdr("RECPAR_SMOOTH_FWHM"));

# Verbose flag
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Create some re-useable temporary files
my $temp1 = new ORAC::TempFile;
my $tempfile1 = $temp1->file;
my $temp2 = new ORAC::TempFile;
my $tempfile2 = $temp2->file;
my $temp3 = new ORAC::TempFile;
my $tempfile3 = $temp3->file;
my $temp4 = new ORAC::TempFile;
my $tempfile4 = $temp4->file;
# Non-reuseable temporary files
my $temp_in = new ORAC::TempFile;
my $tempfile_in = $temp_in->file;
my $tempa = new ORAC::TempFile;
my $tempfilea = $tempa->file;
my $tempb = new ORAC::TempFile;
my $tempfileb = $tempb->file;

# Retrieve the pixel scale for later use
_GET_PIXEL_SCALE_ IMAGE=$in VERBOSE=0
my $pixscale = $_GET_PIXEL_SCALE_{PIXSCALE};

# If no psf has been specified, check recipe parameter for name of
# suitable image in current working dir otherwise generate a PSF image
if (!$psf) {
  # Has the user specified a recipe parameter with the name of the PSF
  # image?
  if (defined $Frm->uhdr("RECPAR_PSF_MATCHFILTER")) {
    my $psfname = $Frm->uhdr("RECPAR_PSF_MATCHFILTER");
    use File::Spec;
    my $cwd = $ENV{ORAC_DATA_OUT};
    my $psffile = File::Spec->catfile($cwd, $psfname);
    if ( -e $psffile ) {
      # Check that the pixel scales are consistent?
      $psf = $psffile;
    } else {
      orac_warn "Given PSF file, $psffile, does not exist: creating one\n";
    }
  }

  # If no PSF file exists by this point, create one ourselves
  if (!$psf) {
    # Obtain normalization option to obtain a PSF normalized to unit
    # peak or unit sum. Default to peak (if not recognized).
    my $norm = get_prim_arg($_PRIM_ARGS_, "NORM", "peak");
    $norm = "peak" unless ($norm eq "peak" || $norm eq "sum");

    # Use inout method to define a suitable PSF file name
    $psf = $Obj->inout("_psf");
    _CREATE_PSF_IMAGE_ PSF=$psf PIXSIZE=$pixscale NORM=$norm SMOOTH=$smooth SMOOTH_FWHM=$smooth_fwhm VERBOSE=$verbose

    # Abort with an error if no psf image could be created
      if ($psf) {
	# Store the PSF image in the intermediates array so it can be deleted
	# at the end of the recipe
	$Obj->push_intermediates($psf);
      } else {
	orac_term "Unable to create a PSF image";
      }
  }
}

orac_print "Applying matched filter to $in..." if ($verbose);

# If desired, smooth input image by gaussian with given FWHM and
# subtract from original.
if ($smooth) {
  orac_print " smoothing and subtracting from original..." if ($verbose);
  my $smooth_pix = $smooth_fwhm / $pixscale;
  $Mon{kappa_mon}->obeyw("gausmooth","in=$in out=$tempfile1 fwhm=$smooth_pix");
  $Mon{kappa_mon}->obeyw("sub","in1=$in in2=$tempfile1 out=$tempfile_in");
  # Redefine the input filename for subsequent use
  $in = $tempfile_in;
}

# Create image A = numerator in expression in POD. First step -
# calculate ratio of data to variance for the input image.
my $args = "exp=ia/va ia=$in out=$tempfile1";
$Mon{kappa_mon}->obeyw("maths","$args");

# Smooth this using the supplied psf - do not normalize
$args = "in=$tempfile1 out=$tempfilea psf=$psf xcentre=0 ycentre=0 norm=0";
$Mon{kappa_mon}->obeyw("convolve","$args");

# Now go on to create image B, the denominator. Get the reciprocal of
# the variances from the input image.
$args = "exp=1/va va=$in out=$tempfile1";
$Mon{kappa_mon}->obeyw("maths","$args");

# Get the square of the PSF
$Mon{kappa_mon}->obeyw("mult","in1=$psf in2=$psf out=$tempfile3");

# Smooth the reciprocal of the variances using the squared psf
$args = "in=$tempfile1 out=$tempfileb psf=$tempfile3 xcentre=0 ycentre=0 norm=0";
$Mon{kappa_mon}->obeyw("convolve","$args");

# The output image is the ratio of A and B
$Mon{kappa_mon}->obeyw("div","in1=$tempfilea in2=$tempfileb out=$out");

# The variance in the output image is the reciprocal of B.
$args = "exp=1/ia ia=$tempfileb out=$tempfile1";
$Mon{kappa_mon}->obeyw("maths","$args");
$Mon{ndfpack_mon}->obeyw("setvar","ndf=$out from=$tempfile1 comp=data");

# The output file has no units so set them to the original input
# units, retrieved from input file
$Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
my ($ORAC_STATUS, $units) = $Mon{ndfpack_mon}->get("ndftrace","units");
$Mon{ndfpack_mon}->obeyw("setunits","ndf=$out units=$units");

orac_print " done\n" if ($verbose);

# Store the output file if requested
$Obj->files($out) if ($store);
