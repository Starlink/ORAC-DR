#! -*-perl-*-

=head1 NAME

_CALIBRATE_DATA_ - Multiply data by the flux conversion factor

=head1 SYNOPSIS

  _CALIBRATE_DATA_ UNITS=BEAM
  _CALIBRATE_DATA_ UNITS=ARCSEC

=head1 DESCRIPTION

Multiply SCUBA-2 data by the flux conversion factor (FCF). The value
for the FCF depends on the filter and the type of calibration
required. The calibration units are specified by an argument.

This is a Frame operation and should be used before group operations.

In SCUBA-2 terms, the FCF is simply a scaling from pW to Jy (or
Jy/beam).

=head1 ARGUMENTS

=over 4

=item UNITS

Controls the units of the FCF. The options are BEAM for Jy/beam,
ARCSEC for Jy/arcsec**2 and PIXEL for Jy (equivalent to
Jy/pixel). PIXEL is the default.

=back

=head1 External Tasks

The following external tasks are used:

=over 4

=item KAPPA

CMULT

=back

=head1 FILES

Creates an output file with a C<_cal> extension.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005 Particle Physics and Astronomy Research Council and
University of British Columbia. All Rights Reserved.

=cut

# PI - must be able to get from somewhere else?
my $pi = 3.141592654;

# Bandwidth of filter in GHz, frequency dependent.
# Should be able to retrieve from header or somewhere else?
my $bandGHz = 35; # 850 um

# Telescope aperture area in m**2
my $Atel = $pi * 7.5 * 7.5;

# Units
my $units =  (exists $_CALIBRATE_DATA_{UNITS} &&
	      defined $_CALIBRATE_DATA_{UNITS}) ?
              lc($_CALIBRATE_DATA_{UNITS}) : "pixel";

my $unitstr;   # Units string
my $gainunits; # Gain modifier determined by Units
# May need to know beam size and/or pixel area
if ($units eq "beam") {
  $unitstr = "Jy/beam";
  $gainunits = 1;
} elsif ($units eq "arcsec") {
  $unitstr = "Jy/arcsec**2";
  $gainunits = 1;
} elsif ($units eq "pixel") {
  $unitstr = "Jy/pixel";
  $gainunits = 1;
}

# Convert pW to Jy:
# 1.0e5 factor = 1e26/(1e12*1e9)
# 1e26 from 1 Jy = 1e-26 W/m**2/Hz
# 1e12 from 1 pW = 1e-12 W
# 1e9 from 1 GHz = 1e9 Hz
my $gain = $gainunits * 1.0e5/ ( $Atel * $bandGHz );

# Loop over sub-instruments
for my $i (1..$Frm->nfiles) {

  # retrieve input and output names
  my ($in, $out) = $Frm->inout("_cal", $i);
  my $args = "scalar=$gain";

  # Multiply by the gain
  $Mon{kappa_mon}->obeyw("cmult","in=$in out=$out $args");

  orac_print "Multiplying $in by $gain \n";

  # Change the units
  $Mon{ndfpack_mon}->obeyw("setunits","ndf=$out units=$unitstr");

  # Update file
  $Frm->file($i, $out);

}

orac_print "ORAC says: Data calibrated in $unitstr\n";
