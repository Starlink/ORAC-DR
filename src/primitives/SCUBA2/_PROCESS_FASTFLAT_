# -*-cperl-*-

=head1 NAME

_PROCESS_FASTFLAT_ - Calculate and analyze fast-ramp flatfield measurements

=head1 SYNOPSIS

_PROCESS_FASTFLAT_

=head1 DESCRIPTION

Calculate and analyze a flatfield solution from fast-ramp flatfield
data. The fast-ramp data are stored in a new Group (which temporarily
overrides the global $Grp variable) and processed as a normal
flatfield observation. The results are compared with the current
(dedicated) flatfield solution for the first ramp, while the last ramp
is then compared with the first.

This primitive is essentially a self-contained version of the
REDUCE_FLATFIELD recipe designed to deal with fast-ramp flatfield
measurements.

=head1 ARGUMENTS

This primitive has no arguments.

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item ORAC-DR PRIMITIVES

_ANALYZE_FLATFIELD, _CALCULATE_FLATFIELD_, _COPY_RAW_DATA_,
_DELETE_TEMP_FILES_, _DISPLAY_FASTFLAT_

=back

=head1 NOTES

Assumes that there are only two fastflat measurements during an
observation, one near the beginning and one at the end.

=head1 OUTPUT DATA

If flatfield solutions were calculated, the primitive hash
%_PROCESS_FASTFLAT_ contains an entry with the key C<FLATS> which is a
reference to an array of the raw files containing fast-ramp data.

The Group contains a new uhdr entry called C<FASTFLATSOL>, a hash
reference with the fast-ramp flatfield solutions indexed by subarray.

=head1 OUTPUT FILES

On completion of the observation, the results of the final fast-ramp
are left on disk, stored in files with suffix C<_flat>, one for each
subarray.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2010-2011 University of British Columbia.  All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my @flats;

# Have to treat FOCUS observations a little differently because each
# Frame corresponds to a separate SMU position.
if ($Frm->uhdr("ORAC_OBSERVATION_TYPE") =~ /focus/i) {
  # Retrieve existing files marked as fast ramps if appropriate
  if ($Grp->lastmember($Frm)) {
    @flats = @{$Grp->uhdr("FASTRAMPFLATS")}
      if (defined $Grp->uhdr("FASTRAMPFLATS"));
  } else {
    # Otherwise copy the data so it persists, retrieve any fast ramps
    # from the current Frame (storing their names in the Grp uhdr),
    # and terminating the recipe immediately. This block should never
    # be reached in the QL pipeline because each new file becomes a
    # new Group and thus the Frame is always the last member.
    _COPY_RAW_DATA_ SUFFIX=_rawflat
    my @newflats = $Frm->get_fastramp_flats;
    $Grp->uhdr("FASTRAMPFLATS", \@newflats);
    return ORAC__TERM;
  }
}
# Retrieve and store the fast ramp files
my @newflats = $Frm->get_fastramp_flats;
push(@flats, @newflats) if @newflats;

# Retrieve OBSEND from the hdr
my $obsend_on_entry = $Frm->hdrval("OBSEND",-1);

# Hash for fastflat files to be stored, indexed by subarray
my (%store, @rawfastflats, @flatfiles);

# Now process those files identified
if (@flats) {
  # Retrieve previous solutions if they exist - this must be done
  # first as the method relies on fiddling the hdr of the global Frame
  # object
  _RETRIEVE_FASTFLATS_ TYPE=SOL
  my $previous = $_RETRIEVE_FASTFLATS_{FASTFLATS_SUB};

  # Create a temporary override of Frm to allow primitives to work.
  # Retrieve the name of a resistor config file if given, and store in
  # the new localized Frm.
  my $resist = $Frm->uhdr("RECPAR_RESIST_CFG");
  my $Frm = $Frm->new(\@flats);
  $Frm->uhdr("RECPAR_RESIST_CFG", $resist) if (defined $resist);

  # Calculate the number of files per subarray in the Frame: batch
  # mode processing will have multiple files, QL only 1 - unless the
  # obs was terminated immediately following the fastramp
  # measurement...
  my $nfilespersub = $Frm->nfiles / $Frm->numsubarrays;
  my $batch = ($nfilespersub > 1) ? 1 : 0;

  # The QL pipeline will only have 1 file per subarray, as will
  # observations which failed in some way (so that the trailing
  # fastramp was not carried out). How can the two cases be
  # distinguished so QL processing goes ahead while bad observations
  # are omitted?

  # If the number of subarrays equals the number of fastramp files
  # then there are not enough fastramp files to compare so terminate
  # the recipe
  if ($batch && @flats == $Frm->numsubarrays) {
    orac_warn "Observation ".($Frm->uhdr("ORAC_OBSERVATION_NUMBER"))
      ." likely bad (only 1 fastflat file)\n";
    return ORAC__TERM;
  }

  # Hmmm the processing also assumes that there are the same number of
  # fastramps per subarray - what if 1 subarray has only 1?

  # Copy the raw files so they persist during successive passes
  # through the recipe - only done for the QL pipeline as fastflat
  # processing batch doesn't care about processing the science data
  if (!$batch) {
    _COPY_RAW_DATA_ SUFFIX=_rawflat
  }

  my @Frms;
  if ($batch) {
    # Multiple files per subarray = batch mode
    # so split Frm into Frms with all the same subscan number

    # This method *assumes* that the files are ordered by subarray in
    # the Frame: ie file1 = sub1_file1, file2 = sub1_file2 etc.
    for my $i (1 .. $nfilespersub) {
      my @files = map { $Frm->file($i + ($_ - 1)*$nfilespersub) } (1..$Frm->numsubarrays);

      my $newFrm = $Frm->new( \@files );
      push(@Frms, $newFrm);
    }
  }
  # Use the last Frame as the current Frm if there are multiple Frames
  $Frm = $Frms[-1] if (@Frms > 1);

  # Retrieve current Group uhdr
  my $uhdr = $Grp->uhdr;
  # Create a temporary override for Grp
  my $Grp = $Grp->new("fastflat");
  $Grp->allmembers($Frm);
  $Grp->uhdr(%{$uhdr});

  # Set a FASTFLAT header for subsequent primitives to use
  $Grp->uhdr("FASTFLAT",1);
  # Set the Frame uhdr obsend flag to force flatfield analysis
  $Frm->uhdr("OBSEND",1);
  # Set PROCESS_FASTFLAT to true because if we're here then we're, uh,
  # processing fastflats
  $Frm->uhdr("PROCESS_FASTFLAT", 1);
  push(@rawfastflats, $Frm->files);

  if ( @Frms > 1 ) {
    # Store a Grp flag that can be used downstream
    $Grp->uhdr("BATCH_FLAT", 1);
    # If batch, process the first fast-ramp file to create a
    # `previous' file
    { # Localize Grp here (again!) just to get the flatfield calculation -
      # alternative is to patch _CALCULATE_FLATFIELD_ to take a group
      # object
      my $Grp = $Grp->new("fastflat_previous");
      $Grp->allmembers($Frms[0]);
      $Grp->uhdr(%{$uhdr});

      # Calculate the flatfield solution
      orac_print "\nCalculating the first flatfield solution...\n";
      _CALCULATE_FLATFIELD_
      # Store the results in the $previous hash reference
      $previous = {map { $_->hdr("SUBARRAY") => $_->file } $Grp->members};
    }
    orac_print "\nCalculating the second flatfield solution...\n";
  }
  # Store the fastflats for retrieval by _ANALYZE_FLATFIELD_ below
  $Grp->uhdr("FASTFLATS",$previous) if ($previous);
  # Calculate the flatfield solution
  _CALCULATE_FLATFIELD_

  # Determine which files to keep on completion - always keep the
  # flatfield solutions on disk
  my $keep = "_flat";
  if ( !$obsend_on_entry ) {
    # First time processing fast-ramps so keep the raw data too
    $keep .= ",_rawflat";
  }

  if ($batch) {
    # Hard wire some desired percentiles
    _ANALYZE_FLATFIELD_ PERCENTILES=16,84 RESPRATIO=1 LOGPAR=ABS
  } else {
    # Analyze and display the results immediately in QL/summit mode
    _ANALYZE_FLATFIELD_ OBSEND=0
  }

  # Display results
  _DISPLAY_FASTFLAT_

  # Tidy up
  _DELETE_TEMP_FILES_ KEEP=$keep
  _DELETE_TEMP_FILES_GROUP_ KEEP=$keep

  # Store the flatfield solutions
  @flatfiles = map { $_->file } $Grp->members;
  # $Frm and $Grp go out of scope here, return to original
}

# Store raw fastflats in Calibration system, but only if they will be
# needed in successive recipe calls by the pipeline
if (@rawfastflats && !$Frm->uhdr("OBSEND")) {
  my $Frmobj = $Frm->new;
  $Frmobj->files(@rawfastflats);
  my %rawfiles = $Frmobj->get_files_by_subarray;
  foreach my $subarray (sort keys %rawfiles) {
    $Frmobj->files( @{$rawfiles{$subarray}} );
    $Frmobj->hdr("SUBARRAY" => $subarray);
    $Cal->fastflatindex->add( $Frmobj->file, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );
  }
}

# Store the _flat files in the global Frame
if (@flatfiles) {
  $Frm->files(@flatfiles);
  $Frm->isgood(-1);
}
