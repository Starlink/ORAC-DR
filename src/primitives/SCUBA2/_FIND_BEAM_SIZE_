#! -*-perl-*-

=head1 NAME

_FIND_BEAM_SIZE_ - Calculate the beam size from a calibrator

=head1 DESCRIPTION

This primitive carries out a fit to a calibrator to determine the beam
size and position angle. An error is generated if the source is not a
calibrator. The reported values are the full-width-at-half-maximum
(FWHM) along the major and minor axes, and the beam position angle on
the sky at the time of obseration. The fit is performed in the SKY
domain so the FWHM is returned in arcsec.

The default is to allow the current fitting routine to determine the
shape of the beam. A flag may be specified to force the return of the
equivalent gaussian beam parameters.

The fit is carried out on the current Grp image or the current
co-added Frame and will fail if there is more than one file in the
Frame.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<METHOD>

Method for deriving the beam parameters. Valid options are BEAMFIT to
use C<beamfit>, or PSF to use C<psf>. Default is BEAMFIT. (In
practice, anything other than PSF will cause C<beamfit> to be used.)

=item B<SYSTEM>

Coordinate system in which to perform beam fit. If not set, the
default is AZEL. May be AZEL, RADEC or GALACTIC. Minimum match is
supported.

=item B<OFFSET>

A flag to denote whether to return the centroid in offset
coordinates. A value of 1 will force the primitive to set the SkyRefIs
attribute to C<Origin> if it has not already been set. Default is 0
(false) which will use the current value.

=item B<GAUSSIAN>

A flag to indicate whether the fit is forced to be gaussian. The
default is no. Only accessed if method=PSF.

=item B<GROUP>

Flag to indicate whether the primitive is to process the Group
image. Default is 0 (false), which will use the current stacked Frame
image.

=item B<LOGFILE>

A flag to indicate whether a pipeline log file should be written
containing the results of the fit. Default is true.

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is verbose (true).

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

WCSFRAME, WCSATTRIB, BEAMFIT

=item Other SCUBA-2 primitives

_FIT_PSF_, _FIND_INTEGRATED_INTENSITY_, CENTROID_IMAGE_

=back

=head1 OUTPUT FILES

The following files are created (if necessary):

=over 4

=item C<log.beam>

Log of beam sizes.

=back

=head1 KNOWN ISSUES

Since the fit is currently carried out in the SKY domain, the reported
beam PA will rotate with the sky during the course of a single
night. The solution is to report the beam in the FPLANE coordinate
frame - the closest approximation is the PIXEL domain.

This method also only fits a single component to the beam. This is not
enough at 450 microns, but currently the beam is not sufficiently
well-known to do much more.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005-2007 the University of British Columbia.  All
Rights Reserved.

=head1 TODO

=over 4

=item - Check source is a calibrator?

=item - Estimating contribution from error beam (Make sure UNITS for
  calc and integrated intensity measurement are the same!!)

=item - Retrieve CSO tau from Cal object?

=item - Error in errfrac?

=item - Correct log entries for Group file

=back

=cut

use constant RAD2ASEC => 206265.0;

# Are we looking at the group image?
my $group = defined( $_FIND_BEAM_SIZE_{GROUP} ) ? $_FIND_BEAM_SIZE_{GROUP} : 0;
my $in;
if ( $group ) {
  $in = $Grp->file;
} else {
  # Check that we only have one file in the Frame
  unless ($Frm->nfiles == 1) {
    orac_throw "Error: _FIND_BEAM_SIZE_ must be run after frames have been combined\n";
  } else {
    $in = $Frm->file;
  }
}

# Should I be verbose? (Default to yes)
my $verbose = (exists $_FIND_BEAM_SIZE_{VERBOSE} && 
	       defined $_FIND_BEAM_SIZE_{VERBOSE}) ?
               $_FIND_BEAM_SIZE_{VERBOSE} : 1;

# Are we writing an entry to a log file? Default Yes
my $uselog = ( exists $_FIND_BEAM_SIZE_{LOGFILE} && 
	       defined $_FIND_BEAM_SIZE_{LOGFILE}) ?
               $_FIND_BEAM_SIZE_{LOGFILE} : 1;

# Do we want to use BEAMFIT or PSF? Default BEAMFIT
my $method = ( exists $_FIND_BEAM_SIZE_{METHOD} && 
	       defined $_FIND_BEAM_SIZE_{METHOD}) ?
               $_FIND_BEAM_SIZE_{METHOD} : "BEAMFIT";

# Set usepsf flag
my $usepsf = ( $method eq "PSF" ) ? 1 : 0;

# Are we working in an offset coordinate system? Default to yes.
my ($ORAC_STATUS, $skyrefis);
my $offset = ($_FIND_BEAM_SIZE_{OFFSET} || 1);
if ( $offset ) {
  # Check if we need to set it first
  $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=skyrefis");
  ($ORAC_STATUS, $skyrefis) = $Mon{ndfpack_mon}->get("wcsattrib","value");
  if ( lc($skyrefis) eq "ignored" ) {
    $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=set name=skyrefis newval=origin");
  }
  orac_print "Fit to beam will be carried out in offset coordinates\n" if ($verbose);
}

# Do we have a calibrator?
my $calib = $Cal->iscalsource($Frm->hdr('OBJECT')) ;
#orac_throw "Error: source is not a known calibrator \n" 
#  unless ($calib);

if ($calib) {

# Retrieve and store current domain and system so they can be reset on
# exit
my $incosys;
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in name=system mode=get");
( $ORAC_STATUS, $incosys ) = $Mon{ndfpack_mon}->get("wcsattrib", "value");

# Determine whether the the fit coordinate system was supplied as an
# argument, else set it to AzEl.
my $fitcosys = (exists $_FIND_BEAM_SIZE_{SYSTEM} && 
		defined $_FIND_BEAM_SIZE_{SYSTEM} ) ? 
                uc($_FIND_BEAM_SIZE_{SYSTEM}) : "AZEL";

# Kappa must be at least V0.15 to use PSF
if (starversion_lt('kappa','V0.15-0')) {
  orac_throw "Installed version of KAPPA is too old to run _FIND_BEAM_SIZE_\n";
}

# See if KAPPA has beamfit
if ( !$usepsf && starversion_lt('kappa','V1.7')) {
  orac_warn "Installed version of KAPPA is too old to use beamfit method, switching to PSF instead\n";
  $usepsf = 1;
}

# Set the coordinate system for the fit
if ( $fitcosys =~ /AZ/ ) {
  $fitcosys = "AZEL";
} elsif ( $fitcosys =~ /RA|FK|ICRS/ ) {
  $fitcosys = "ICRS";
} elsif ( $fitcosys =~ /GAP/ ) {
  $fitcosys = "GAPPT";
} elsif ( $fitcosys =~ /GAL/ ) {
  $fitcosys = "GALACTIC";
} else {
  orac_warn "Unknown coordinate system, $fitcosys - will use input as is\n";
  $fitcosys = $incosys;
}

# Set coord system for fit if necessary
if ( $fitcosys ne $incosys ) {
  $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in name=system mode=set newval=$fitcosys");
}

# Find the centroid of the source
_CENTROID_IMAGE_ IMAGE=$in OFFSET=$offset SYSTEM=$fitcosys
my @xy = @{ $_CENTROID_IMAGE_{RESULTS} };
# If a source could be located then proceed with fit
if ( defined $xy[0] && defined $xy[1] ) {

  orac_print "Deriving the beam in the $fitcosys coordinate system using $method\n";

  my (@amp, @majfwhm, @minfwhm, $axisr, @orient, %badbeam);
  # Now fit the source using PSF or BEAMFIT
  if ( $usepsf ) {
    orac_warn "Note that PSF does not return uncertainties - check results carefully\n";
    # Are we forcing a gaussian fit?
    my $gaussian = (exists $_FIND_BEAM_SIZE_{GAUSSIAN} &&
		    defined $_FIND_BEAM_SIZE_{GAUSSIAN}) ?
		    $_FIND_BEAM_SIZE_{GAUSSIAN} : 0;

    # Create temporary file to write source position(s) in
    my $cofile = new ORAC::TempFile;
    print { $cofile->handle } $xy[0]." ".$xy[1]. "\n";
    $cofile->handle->close;

    # Fit the source with a PSF
    _FIT_PSF_ IMAGE=$in USELOG=1 COFILE=$cofile->file GAUSSIAN=$gaussian
    # Retrieve parameters
    $amp[0] = $_FIT_PSF_{AMPLITUDE};
    $minfwhm[0] = $_FIT_PSF_{FWHM};
    $axisr = $_FIT_PSF_{AXISR};
    $orient[0] = $_FIT_PSF_{ORIENT};

    # Calculate FWHM for major axis
    $majfwhm[0] = $minfwhm[0] * $axisr;

    # Set unused `error' array elements to 0
    $amp[1] = 0.0;
    $majfwhm[1] = 0.0;
    $minfwhm[1] = 0.0;
    $orient[1] = 0.0;

    # Check that the fit gave sensible results
    unless ( defined $minfwhm[0] && defined $axisr && defined $amp[0] ) {
      $badbeam{MAJFWHM} = 1;
      $badbeam{MINFWHM} = 1;
      $badbeam{AMP} = 1;
    }

    # Warn user if the fit looks bad. Of course, this shouldn't happen
    # since we have already selected sources which satisfy this
    # criterion.
    if ($axisr > 1.3333 || $axisr < 0.75) {
      orac_warn "PSF fit appears to be poor or beam highly elongated \n";
      $badbeam{ELONG} = 1;
    }

  } else {
    # Set up args to beamfit
    my $pos = '"'.$xy[0].", ".$xy[1].'"';
    # Use a 15x15 pixel area - should this be an input variable?
    my $fitarea = 15;

    # Check we have a valid variance component
#    $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
#    ($ORAC_STATUS, my $var) = $Mon{ndfpack_mon}->get("ndftrace","variance");
#    if ( lc($var) eq "false" ) {
#      orac_warn "No VARIANCE in input file: will not use variance weighting\n" 
#	if $verbose;
#    } else {
#      # OK we have variance but check we have enough good values to
#      # use variance weighting
#      ($ORAC_STATUS, my $numgood) = $Mon{kappa_mon}->get("stats","numgood");
#      $var = ( $numgood > $fitarea*$fitarea ) ? "true" : "false";
#    }

    # Define args to beamfit
    my $var = "false";
    my $args = "mode=interface pos=".$pos." variance=$var fitarea=$fitarea";
    # Call beamfit
    $Mon{kappa_mon}->obeyw("beamfit","ndf=$in $args");

    # Retrieve parameters
    ($ORAC_STATUS, @majfwhm) = $Mon{kappa_mon}->get("beamfit","majfwhm");
    ($ORAC_STATUS, @minfwhm) = $Mon{kappa_mon}->get("beamfit","minfwhm");
    ($ORAC_STATUS, @orient)  = $Mon{kappa_mon}->get("beamfit","orient");
    ($ORAC_STATUS, @amp)     = $Mon{kappa_mon}->get("beamfit","amp");

    # FWHM are returned in radians: convert to arcsec
    for my $i (0..1) {
      $majfwhm[$i] *= RAD2ASEC;
      $minfwhm[$i] *= RAD2ASEC;
    }

    # Now assess the fit. Check for highly elongated beam, for
    # magnitude of uncertainty in major/minor axis FWHM and amplitude.
    # Warn user if any parts of the fit look bad.
    $axisr = $majfwhm[0] / $minfwhm[0];
    if ($axisr > 1.3333 || $axisr < 0.75) {
      orac_warn "Beam fit appears to be poor or beam highly elongated \n";
      $badbeam{ELONG} = 1;
    }
    if ( $majfwhm[1] > $majfwhm[0] ) {
      orac_warn "Large uncertainty in FWHM for major axis\n" if $verbose;
      $badbeam{MAJFWHM} = 1;
    }
    if ( $minfwhm[1] > $minfwhm[0] ) {
      orac_warn "Large uncertainty in FWHM for minor axis\n" if $verbose;
      $badbeam{MINFWHM} = 1;
    }
    if ( $minfwhm[1] > $minfwhm[0] ) {
      orac_warn "Large uncertainty in fitted amplitude\n" if $verbose;
      $badbeam{AMP} = 1;
    }
  }

  # Check on status of fit
  if ( defined $badbeam{ELONG} && defined $badbeam{MAJFWHM} && 
       defined $badbeam{MINFWHM} && defined $badbeam{AMP} ) {
    orac_warn "Beam fit looks poor - ignoring, fit will not be logged\n";
    $badbeam{BEAM} = 1;
  }

  my ($beama, $beamb, $pa);
  # If the fit is bad then don't log it to the file
  if ( defined $badbeam{BEAM} ) {
    $uselog = 0;
  } else {

    # Calculate total power in main beam. Note if PSF was used, the
    # amplitude will be that of the first useable source in the
    # image. In practice, there is likely to be only one source in the
    # image so this will be the amplitude we want.
    my $Pmain = 1.133 * $amp[0] * $majfwhm[0] * $minfwhm[0];

    # Error in total power - assume errors add in quadrature
    my $dPmain = $Pmain * sqrt( $amp[1]*$amp[1]/($amp[0]*$amp[0]) +
				$majfwhm[1]*$majfwhm[1]/($majfwhm[0]*$majfwhm[0]) +
				$minfwhm[1]*$minfwhm[1]/($minfwhm[0]*$minfwhm[0]) );

    # Now do aperture photometry on source to measure total power in
    # image A 2 arcmin-diameter aperture should be big enough Future:
    # Iterative method to increase aperture from FWHM to image size
    my $radius = 60.0; 

    _FIND_INTEGRATED_INTENSITY_ RADIUS=$radius IMAGE=$in XYPOS=\@xy
    my $Pint = $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX};
    # Error in $Pint = sigma * sqrt(n_pixels_used)
    my $dPint = $_FIND_INTEGRATED_INTENSITY_{SIGMA} *
                sqrt($_FIND_INTEGRATED_INTENSITY_{NUMGOOD});

    # Calculate fraction of power in error beam as a percentage
    my $errfrac;
    if ( $Pint > $Pmain ) {
      $errfrac = 100.0 * (1.0 - ($Pmain / $Pint) );
    } else {
      my $pmain = sprintf "%5.3f", $Pmain;
      my $pint = sprintf "%5.3f", $Pint;
      orac_warn "Total integrated power ($pint) is less than that in the main beam ($pmain)\n";
      $errfrac = 0.0;
    }

    # Store beam parameters
    $Cal->beampar( majfwhm => \@majfwhm, minfwhm => \@minfwhm, 
		   orient => \@orient, errfrac => $errfrac );

    # Reformat for pretty reporting
    $errfrac = sprintf "%3d", $errfrac;
    $beama = sprintf "%5.2f", $majfwhm[0];
    $beamb = sprintf "%5.2f", $minfwhm[0];
    $pa = sprintf "%5.2f", $orient[0];
  }

  # Write a log file if required
  my $filt= sprintf "%4s", $Frm->hdr('FILTER');
  if ($uselog) {
    my $time = gmtime();
    my $beamlog = new ORAC::LogFile("log.beam");
    $beamlog->header("#Beam log file - created on $time\n",
		     "#\n# #   Time       Filter    A     dA     B     dB    PA    dPA    Seeing  El   Tau225",
		     "#-------------------------------------------------------------------------------------"
      );
    my $num = sprintf "%05d", $Frm->hdr('OBSNUM');
    $time= sprintf "%12.3f", $Frm->hdrval('ORACTIME',0);

    # Get TAU from the header - should get from $Cal object?
    my $cso = sprintf "%5.3f", 0.5*($Frm->hdrval('WVMTAUST', 0) + 
				    $Frm->hdrval('WVMTAUEN',-1));
    # Elevation
    my $el = int ( 0.5 * ($Frm->hdrval('ELSTART',0) + $Frm->hdrval('ELEND',-1) ) );
    # Seeing
    my $see = sprintf "%5.3f", ( 0.5 * ($Frm->hdrval('SEEINGST', 0) + 
					$Frm->hdrval('SEEINGEN',-1)) );
    # Reformat uncertainties in beam parameters for printing
    my $da = sprintf "%5.2f",  $majfwhm[1];
    my $db = sprintf "%5.2f", $minfwhm[1];
    my $dpa = sprintf "%5.2f", $orient[1];

    # Write to logfile
    $beamlog->addentry("$num  $time  $filt    $beama   $da   $beamb   $db   $pa   $dpa $see   $el  $cso");

  }
  orac_print "Beam size for $filt: $beama x $beamb arcsec^2 at a PA of $pa deg E of N\n" if ($verbose && !($badbeam{BEAM}));

} else {
  orac_warn "Unable to locate source to determine beam size\n";
}

# Return SYSTEM to original value if necessary
if ( $fitcosys ne $incosys ) {
  $Mon{ndfpack_mon}->obeyw("wcsattrib", "ndf=$in mode=set name=system newval=$incosys");
}
# Reset the SkyRefIs parameter if necessary
if ( $offset ) {
  if ( lc($skyrefis) eq "ignored" ) {
    $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=set name=skyrefis newval=$skyrefis");
  }
}

}
