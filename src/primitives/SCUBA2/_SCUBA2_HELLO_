# -*-cperl-*-

=head1 NAME

_SCUBA2_HELLO_ - Mandatory introductory primitive

=head1 SYNOPSIS

 _SCUBA2_HELLO_

=head1 DESCRIPTION

This primitive should be called at the start of all SCUBA-2 DR
recipes. Its primary purpose is to provide some introductory messages
and to check and set a handful of uhdr entries. Dark frames are
removed from the input if necessary (for DREAM/STARE data).

=head1 ARGUMENTS

None.

=head1 EXTERNAL TASKS

None.

=head1 OUTPUT DATA

The Frame uhdr entry OBSEND is set to 1 if the Frame contains the last
data file in the observation, or if the observation is a SCAN pointing.

The Frame uhdr entry PERCENT_CMP is retrieved from the last value in
the state structure.

=head1 OUTPUT FILES

None.

=head1 NOTES

Probably not required for offline instances of the pipeline.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>,
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005 Particle Physics and Astronomy Research Council.
Copyright (C) 2009 University of British Columbia. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# duration in seconds
my $duration = $Frm->duration_science;
my $duration_minutes = sprintf("%.1f",$duration/60);

# Do we have just darks? These checks are only really relevant for the
# QL and SUMMIT pipelines. First check that there are no SHUTTER
# subheaders which would indicate a mix of open/closed shutter data in
# the Frame. If the shutter is closed (0.0) then mark as dark only,
# and mark the Frame as bad for all observations except flatfield and
# noise.
if ((defined $Frm->hdr("SHUTTER")) && ($Frm->hdr("SHUTTER") == 0.0)) {
  $Frm->uhdr("DARKONLY",1);

  # Mark as bad for all observations where the shutter will be open at
  # some point because we don't want to try and mosaic darks with
  # images. Noise and Flatfields must allow dark frames through.
  unless ( $Frm->uhdr("ORAC_OBSERVATION_MODE") =~ /flatfield/i ||
       $Frm->uhdr("ORAC_OBSERVATION_MODE") =~ /noise/i ) {
    $Frm->isgood(0);
  }

  # If the object for this dark frame is SKY then we have a noise-sky
  # observation, so drop these data on the floor
  $Frm->isgood(0) if ($Frm->uhdr("ORAC_OBJECT") =~ /^SKY/ &&
		      $Frm->uhdr("ORAC_OBSERVATION_MODE") =~ /noise/i);

} elsif ( defined $Frm->hdr("SEQ_TYPE")
          && lc($Frm->hdr("SEQ_TYPE")) ne lc($Frm->hdr("OBS_TYPE")) ) {
  # This check is to catch `dark' data taken when the shutter is open
  # throughout the observation. The first sequence is labelled `noise'
  # or `fastflat' so if that's all we have and this is not a noise or
  # flatfield observation then mark the data as dark only to hide it
  # from further processing.

  $Frm->uhdr("DARKONLY", 1);
  $Frm->isgood(0);
}

# Print welcome message
orac_print "Obs #".$Frm->uhdr("ORAC_OBSERVATION_NUMBER").
    " Observing mode: ". $Frm->uhdr("ORAC_OBSERVATION_MODE").
    ( $Frm->hdr("STANDARD") ? " / standard":  "" ) .
  " / Observation duration: $duration_minutes min\n";

if ($Frm->uhdr("ORAC_OBSERVATION_TYPE") eq "focus") {
  orac_print "Focus axis ". $Frm->hdrval("FOCAXIS").
    " and focus position ". $Frm->hdr("FOCPOSN") ." mm\n"
    unless ( $Frm->uhdr("DARKONLY") );
}

my $extra = ($Frm->uhdr("DARKONLY")) ? " (dark frame only - ignoring)" : "";
orac_print "This is an observation of ".$Frm->uhdr("ORAC_OBJECT")."$extra\n"
  if ( defined $Frm->uhdr("ORAC_OBJECT") ) ;

# Obtain the percent_complete value from the state structure
$Frm->uhdr("PERCENT_CMP", $Frm->jcmtstate("TCS_PERCENT_CMP", "end") );

# See if the OBSEND flag is set
my $obsend = ( $Frm->hdrval("OBSEND",-1) ) ? 1 : 0;

# Pass this value on to the current Frame
$Frm->uhdr("OBSEND", $obsend);

# Filter out dark frames from science observations if necessary
# (applies to DREAM/STARE mode only)
#$Frm->filter_darks;

if ($Frm->hdr("SIMULATE")) {
  orac_warn(" *** This observation is simulated data! ***\n");
}

# And if we set the frame bad by this point we simply terminate
if ( ! $Frm->isgood && ! $Frm->uhdr("OBSEND") ) {
  orac_print("Frame not useful so terminating recipe\n");
  return ORAC__TERM;
}

# Define the default makemap config file
# Blank field processing will get an override from the recipe layer
my $conftype = "normal";

# Use the bright_compact config file for calibrators or pointings
# Use veryshort for very short observations regardless
if ($duration < 15) {
  if ($Cal->isplanet( $Frm->hdr("OBJECT") )) {
    $conftype = "veryshort_planet";
  } elsif ( lc($Frm->hdr("OBS_TYPE")) eq 'pointing') {
    $conftype = "bright_compact_veryshort";
  } elsif ( $Cal->iscalsource( $Frm->hdr("OBJECT") ) &&
            lc($Frm->hdr("OBS_TYPE")) eq 'science') {
    $conftype = "bright_compact_veryshort";
  } else {
    $conftype = "veryshort";
  }
} elsif ( lc($Frm->hdr("OBS_TYPE")) eq "science" ) {
  $conftype = "bright_compact"
    if ( $Cal->iscalsource( $Frm->hdr("OBJECT") ) );
} elsif ( lc($Frm->hdr("OBS_TYPE")) eq "pointing" ) {
  # For some reason we have OMC1 as a pointing source
  if ( $Frm->hdr("OBJECT") eq 'OMC1' ) {
    $conftype = "pointing_extended";
  } else {
    $conftype = "pointing";
  }
}
$Frm->uhdr("MAKEMAP_CONFIG_TYPE", $conftype) if defined $conftype;
