#! -*-perl-*-

=head1 NAME

_FIND_SKY_STATS_ - determine the statistics of blank (sky) regions

=head1 SYNOPSIS

 _FIND_SKY_STATS_

 _FIND_SKY_STATS_ CLIP=2,2

=head1 DESCRIPTION

This primitive calculates the statistics of regions within a given
image. It is expected that this primitive will usually be called from
another which removes the sky contribution, and thus will pass it the
IMAGE argument.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item IMAGE

Input image. No default, and an error will be given if no image is
supplied.

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is true.

=item CLIP

A comma-separated list of up to 5 numbers specifying the clip levels
at which to evaluate the statistics. See the documentation for KAPPA
C<stats> for further details. Default is blank (no clipping).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

C<stats>, C<histogram>

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIND_SKY_STATS_>
contains the following keys:

=over 4

=item RESULTS

An array reference containing the mean sky level, the standard
deviation and the modal sky value in the image.

=back

The frame object is not updated.

=head1 KNOWN ISSUES

Only takes the average of the entire image assuming that the sky
dominates the emission. A more sophisticated routine is needed for the
pathological cases when there is a lot of extended (source) emission
which lies at the several sigma level. Masking of known sources should
take place before calling this primitive.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005-2007 University of British Columbia.  All Rights
Reserved.

=cut

# Set input file
my $in = (exists $_FIND_SKY_STATS_{IMAGE} && 
	  defined $_FIND_SKY_STATS_{IMAGE}) ?
          $_FIND_SKY_STATS_{IMAGE} : "";

if ( $in eq "" ) {
  orac_throw "Error: no input image given to _FIND_SKY_STATS_\n";
}

# Should I be verbose (default to yes)
my $verbose = (exists $_FIND_SKY_STATS_{VERBOSE} && 
	       defined $_FIND_SKY_STATS_{VERBOSE}) ?
               $_FIND_SKY_STATS_{VERBOSE} : 1;

# Optional CLIP argument, default to blank (no clipping)
my $clip = (exists $_FIND_SKY_STATS_{CLIP} && 
	    defined $_FIND_SKY_STATS_{CLIP}) ?
            $_FIND_SKY_STATS_{CLIP} : "";

# Initialise the results array
$_FIND_SKY_STATS_{RESULTS} = [];

# Now calculate stats of the masked file to get the mean and the
# standard deviation
my $args = ($clip ne "") ? "clip=[$clip]" : "" ;
$Mon{kappa_mon}->obeyw("stats","ndf=$in $args");

# Retrieve the values
my $ORAC_STATUS;
($ORAC_STATUS, my $avg) = $Mon{kappa_mon}->get("stats","mean");
($ORAC_STATUS, my $stdv) = $Mon{kappa_mon}->get("stats","sigma");
($ORAC_STATUS, my $ngood) = $Mon{kappa_mon}->get("stats","numgood");
($ORAC_STATUS, my $ntotal) = $Mon{kappa_mon}->get("stats","numpix");
($ORAC_STATUS, my $nbad) = $Mon{kappa_mon}->get("stats","numbad");
($ORAC_STATUS, my $min) = $Mon{kappa_mon}->get("stats","minimum");
($ORAC_STATUS, my $max) = $Mon{kappa_mon}->get("stats","maximum");

# KAPPA stats returns sigma = 0 if anything went wrong

orac_warn "All pixels in region are bad!\n" if $ngood == 0;
my $fracgood = $ngood/$ntotal;

# Now use KAPPA histogram and write results to a file
# Determine numbin: calculated from min and max to make sure that
# the increment is more or less the same for all images
my $delta = 1.0e-5;
my $numbinmax = 10000;
my $numbin = int( ($max - $min)/$delta );
$numbin = $numbinmax if ($numbin > $numbinmax);

# ORAC::TempFile can't be used to create a file to pass to histogram
# but it *can* be used to generate a unique name for histogram so
# ensure there won't be any name clashes.
my $histfile = new ORAC::TempFile(0);
my $histname = $histfile->file;
undef $histfile;
my $args = "numbin=$numbin range=! device=! logfile=".$histname;
$Mon{kappa_mon}->obeyw("histogram","in=$in $args");

# Now analyze results - first open log file with hist results
open my $HISTFH, "< $histname"
  or die "Unable to open file, $histname: $!\n";
my (@lines, @values);
# Read all the relevant lines, delete file when done
while (<$HISTFH>){
  chomp;
  push (@lines, $_) if ($_ =~ /pixels/); # We only want lines with the word pixels in it
}
close $HISTFH;
unlink $histname;

# Split line on spaces and store the bounds of and the number of
# samples in the current bin
foreach my $line (@lines) {
  my @tmpline = split(/\s+/,$line,6);
  my $lineref = [ $tmpline[1], $tmpline[3], $tmpline[4] ];
  push (@values, $lineref);
}
# Now find the maximum value - this is the MODE
my $maxpix = 0;
my $maxval = -1.0e9;
foreach my $lineref (@values) {
  if ($lineref->[2] > $maxpix){
    $maxpix = $lineref->[2];
    $maxval = 0.5*($lineref->[0] + $lineref->[1]) ;
  }
}
my $mode = $maxval;

# Store mean DC level, standard deviation and mode in the hash
$_FIND_SKY_STATS_{RESULTS} = [ $avg, $stdv, $mode ];

orac_print "Calculated sky statistics\n" if $verbose;
