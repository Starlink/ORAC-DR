#! -*-perl-*-

=head1 NAME

_FIND_SKY_STATS_ - determine the statistics of blank (sky) regions

=head1 SYNOPSIS

 _FIND_SKY_STATS_

 _FIND_SKY_STATS_  LOGFILE=0

=head1 DESCRIPTION

This primitive calculates the statistics of regions within an image

This primitive is Frame based (C<$Frm>) and either acts on each image
in the frame or only on the one selected by the FRAME argument. It is
expected that this primitive will usually be called from another which
removes the sky contribution, and thus will pass it the FRAME argument.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item LOGFILE

A flag to indicate whether a log file should be written containing the
results of the integrated intensity calculation. Default is true.

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is true.

=item FRAME

An integer which specifies which file in the current frame to perform
the calculation on. Default is 0 which means to use all files in
current frame.

=item CLIP

A comma-separated list of up to 5 numbers specifying the clip levels
at which to evaluate the statistics. See the documentation for KAPPA
C<stats> for further details. Default is blank (no clipping).

=item MODE

A string to set the type of data to be used in determining the sky
statistics depending on whether the pipeline is operating in online
or offline mode. Valid values are online or offline. Default
is online.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

C<stats>

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIND_SKY_STATS_>
contains the following keys:

=over 4

=item RESULTS

An array reference containing the DC sky level and the standard
deviation of values in the image.

=back

=head1 OUTPUT FILES

The following files are created:

=over 4

=item C<log.sky>

A log file containing an estimate of the DC sky level removed

=back

The frame object is not updated.

=head1 KNOWN ISSUES

Only takes the average of the entire image assuming that the sky
dominates the emission. A more sophisticated routine is needed for the
pathological cases when there is a lot of extended (source) emission
which lies at the several sigma level.

Currently only supports the online pipeline mode operating on
images only rather than directly on the timestream data.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005 University of British Columbia.  All Rights
Reserved.

=cut

use NDF;
# Write logfile (default to true)
my $uselog = (exists $_FIND_SKY_STATS_{LOGFILE} && 
	      defined $_FIND_SKY_STATS_{LOGFILE}) ?
  $_FIND_SKY_STATS_{LOGFILE} : 1;

# Should I be verbose (default to yes)
my $verbose = (exists $_FIND_SKY_STATS_{VERBOSE} && 
	       defined $_FIND_SKY_STATS_{VERBOSE}) ?
  $_FIND_SKY_STATS_{VERBOSE} : 1;

# Check if FRAME argument is present
my $myframe = 0;
if ($_FIND_SKY_STATS_{FRAME}) {
  $myframe = $_FIND_SKY_STATS_{FRAME};
}

# Optional CLIP argument
my $clip = (exists $_FIND_SKY_STATS_{CLIP} && 
	    defined $_FIND_SKY_STATS_{CLIP}) ?
  $_FIND_SKY_STATS_{CLIP} : "";

# Pipeline mode (default to online)
my $pipemode = (exists $_FIND_SKY_STATS_{MODE} && 
		defined $_FIND_SKY_STATS_{MODE}) ?
               lc($_FIND_SKY_STATS_{MODE}) : "online";

if ($pipemode =~ /on/) {
  orac_print "ONLINE pipeline mode specified \n" if $verbose;
} elsif ($pipemode =~ /off/) {
  orac_print "OFFLINE pipeline mode specified \n" if $verbose;
} else {
  orac_warn "Warning: Unsupported mode, reverting to online \n";
  $pipemode = "online";
}

# Change $pipemode to an integer
$pipemode = ($pipemode =~ /on/) ? 1 : 0;

orac_warn "Warning: only ONLINE pipeline currently supported, reverting to online \n" 
  unless $pipemode;

# Initialise the results array
$_FIND_SKY_STATS_{RESULTS} = [];

# Create logfile
my $log;
if ($uselog) {
  $log = new ORAC::LogFile("log.sky");
  my $time = gmtime();
  $log->header("Sky statistics log file - created on $time",
	       "\n#     Time        Filter    Offset      RMS  Npix  rms/pix  CSO  El   Object",
	       "----------------------------------------------------------------------------------"
	       );
}

# Now Loop over frames
my $in;
my $delta = 1.0e-5;
for my $i (1.. $Frm->nfiles ) {

  # Find the input file
  if ($myframe) { # If running with a single input file...
    if ($i == $myframe) {
      $in = $Frm->file($i);
    } else {
      next;
    }
  } else { # Running as normal
    $in = $Frm->file($i);
  }

  # Now calculate stats of the masked file to get the mean and the
  # standard deviation
  my $args = ($clip ne "") ? "clip=[$clip]" : "" ;
  $Mon{kappa_mon}->obeyw("stats","ndf=$in $args");

  # Retrieve the values
  my $ORAC_STATUS;
  ($ORAC_STATUS, my $avg) = $Mon{kappa_mon}->get("stats","mean");
  ($ORAC_STATUS, my $stdv) = $Mon{kappa_mon}->get("stats","sigma");
  ($ORAC_STATUS, my $ngood) = $Mon{kappa_mon}->get("stats","numgood");
  ($ORAC_STATUS, my $ntotal) = $Mon{kappa_mon}->get("stats","numpix");
  ($ORAC_STATUS, my $nbad) = $Mon{kappa_mon}->get("stats","numbad");
  ($ORAC_STATUS, my $min) = $Mon{kappa_mon}->get("stats","minimum");
  ($ORAC_STATUS, my $max) = $Mon{kappa_mon}->get("stats","maximum");

  my $fracgood = $ngood/$ntotal;

  # Store them if sigma is greater than 0
#  if ($stdv > 0.0 && $fracgood > 0.5) {
  if ($stdv > 0.0) {
#    push(@avg_stdv, [ $avg, $stdv] );
    orac_print "MEAN/SIGMA : $avg/$stdv\n", 'red'
      if $verbose;
  } else {
    $avg = 0;
    $stdv = 0;
    orac_warn "Negative std deviation - setting mean and sigma to 0 \n" if $verbose;
  }

  # Calculate error on the sum (done the simple way)
  my $err = sqrt($ngood) * $stdv;
  orac_warn "All pixels in aperture are bad!\n"
    if $ngood == 0;
  
  # Signal-to-noise
  my $s2n;
  if (abs($err) <= 1.0e-30) {
    # protect division by zero and assume that very small
    # error really means an error in the calculation
    $s2n = 0.0;
  } else {
    # signal-to-noise is positive
    $s2n = abs($avg / $err);
  }

  # Now use the histogram method - write results to a logfile
  # Determine numbin: calculated from min and max to make sure that
  # the increment is more or less the same for all images
  my $numbin = int( ($max - $min)/$delta );
  my $logfile = "histogram_".$i.".dat";
  my $args = "numbin=$numbin range=! device=! logfile=$logfile";
  $Mon{kappa_mon}->obeyw("histogram","in=$in $args");
  # Now analyze results
  # ##############
  # KLUDGE - this MUST be moved into a subroutine
  # Open log file with hist results
  open my $HISTFH, "< $logfile "
    or die "Unable to open file, $logfile: $!";    
  my (@lines, @values);
  # Fill the @lines array
  while (<$HISTFH>){
    chomp;
    push (@lines, $_) if ($_ =~ /pixels/);
  }
  close $HISTFH;
  unlink $logfile;
  # Now fiddle with the @lines array
  # Get an array of array refs, each containing
  foreach my $line (@lines) {
    my @tmpline = split(/\s+/,$line,6);
    my $lineref = [ $tmpline[1], $tmpline[3], $tmpline[4] ];
    push (@values, $lineref);
  }
  # Now find max value
  my $maxpix = 0;
  my $maxval = -1.0e6;
  foreach my $lineref (@values) {
    if ($lineref->[2] > $maxpix){
      $maxpix = $lineref->[2];
      $maxval = 0.5*($lineref->[0] + $lineref->[1]) ;
    }
  }
  my $mode = $maxval;
  # NEEDS TO BE TESTED ON FIELD OF POINT SOURCES
  # ##############
    
  # Store mean DC level in the hash
  $_FIND_SKY_STATS_{RESULTS} = [ $avg, $stdv, $mode ];

  my $num = sprintf "%-4d", $Frm->number;
#  my $time= sprintf "%12.3f", $Frm->hdr('ORACTIME');
  my $time= "0.0000";
  my $filt= sprintf "%4s",   "850";
  $s2n = sprintf "%5.2f", $s2n;
  $stdv = sprintf "%8.3e", $stdv;
  $err = sprintf "%8.3e", $err;
  $avg = sprintf "%8.5f", $avg;

  # Get the tau
  # TAU from calibration object
#    my $tau = sprintf "%5.2f", $Cal->tau($filters[$i-1]);

  # Use that tau to calculate CSO
#    my ($cso, $status) = JCMT::Tau::get_tau('CSO',$filters[$i-1], $tau);
#    if ($status != 0) {
#      $cso = "*****";
#    } else {
#      $cso = sprintf "%5.2f", $cso;
#    }
  my $cso = sprintf "%5.2f", "1.0";

  # elevation
#  my $el = int (($Frm->hdr('STRT_ELD') + $Frm->hdr('END_ELD') ) /2.0 );
  my $el = 45;

#  $log->addentry("$num $time  $filt   $avg   $err  $ngood  $stdv  $cso $el ". $Frm->hdr("OBJECT"))
  my $object = "TEST";
  $log->addentry("$num $time  $filt   $avg   $err  $ngood  $stdv  $cso $el $object")
    if $uselog;

  last if ($myframe);
}

orac_print "Calculated sky statistics\n" if $verbose;
