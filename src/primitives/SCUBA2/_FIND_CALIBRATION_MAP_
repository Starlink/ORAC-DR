# -*-cperl-*-

=head1 NAME

_FIND_CALIBRATION_MAP_ - determine the map flux conversion factor

=head1 SYNOPSIS

 _FIND_CALIBRATION_MAP_

=head1 DESCRIPTION

For calibrators, derive three Flux Conversion Factors (FCFs) which
convert bolometer power in pW to Jy/beam or Jy/arcsec**2.

The C<ARCSEC> and C<BEAMEQUIV> methods calculated the total integrated
intensity within an aperture of diameter 1-arcmin using
L<_FIND_INTEGRATED_INTENSITY_|_FIND_INTEGRATED_INTENSITY_> and
calculate a flux conversion factor from the known flux of the
calibrator (in Jy):

  FCF(ARCSEC) = P_sum / S_tot  (Jy/arcsec**2/pW)

  FCF(BEAMEQUIV) = P_sum * beam_volume / S_tot  (Jy/beam/pW)

The C<BEAMEQUIV> FCF uses the peak signal of an equivalent Gaussian
beam with the same total signal as the sum within the specified
aperture.

The peak response (C<BEAM> FCF)is calculated by finding the peak flux
and the fitted peak signal (derived from a 2-D Gaussian fit).

  FCF(BEAM) = P_peak / S_peak  (Jy/beam/pW)

These values are stored in the index file C<index.gains>.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<GROUP>

True if the Group image should be used. Otherwise the current Frame is
used.

=item B<STORE>

Flag to denote whether to store the results in the Calibration
system. Default us 1 (yes).

=item B<VERBOSE>

Flag to denote whether to print additional messages to screen. Default
is 0 (no).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

NDFTRACE

=item ORAC-DR PRIMITIVES

_ADD_FCF_LOG_ENTRY_, _FIND_INTEGRATED_INTENSITY_, _FIND_MAP_PEAK_

=back

=head1 NOTES

This primitive is frame based (C<$Frm>), though with care it may also
be used on Groups.

=head1 OUTPUT DATA

The FCF is stored in the calibration system in the file C<index.gains>.

If the FCF calculations were successful, the primitive hash
C<%_FIND_CALIBRATION_MAP_> contains a single key called C<FCF> which
contains a hash reference with the following keys:

=over 4

=item * ARCSEC

FCF per square arcsec

=item * BEAM

FCF per nominal beam size

=item * BEAMEQUIV

FCF per fitted or nominal beam size

=back

=head1 OUTPUT FILES

Entry in C<log.fcf> log file if the frame is a calibrator.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1  COPYRIGHT

Copyright (C) 2009-2010 University of British Columbia.
Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 0);

my $group = get_prim_arg($_PRIM_ARGS_, "GROUP", 0);

# Flag to denote whether to store the result in the Calibration system
my $store = get_prim_arg($_PRIM_ARGS_, "STORE", 1);

my $Obj = ( $group ? $Grp : $Frm );

# For Frame objects, the decision of whether to proceed with an FCF
# calculation depends on the pipeline flavour. For Group objects, it
# should be safe to proceed if a Group image exists. Otherwise default
# to a no-op.
my $proceed = ($group && $Grp->file_exists) ? 1 : 0;

# The following checks are only done for Frame objects
unless ( $group ) {
  # Retrieve the obsend parameter - normally this primitive only
  # proceeds at the end of an observation, or at the very least once a
  # single image has been created
  $proceed = $Obj->uhdr("OBSEND");

  # Always estimate an FCF in the QL pipeline
  $proceed = 1 if ( defined $Obj->uhdr("QUICKLOOK") );

  # Do nothing if the Frame contains multiple files and this is the
  # SUMMIT pipeline - this means the Frame contains raw data which
  # should not be used for calibration. Otherwise continue with FCF
  # estimate.
  $proceed = ($Obj->uhdr("SUMMIT") && ($Obj->nfiles > 1)) ? 0 : 1;

  # Do nothing if there is no data to analyze
  $proceed = 0 if $Obj->uhdr("DARKONLY");

  $proceed = 0 unless $Obj->uhdr("NEWIMAGE");
}

# Retrieve source name and filter
my $src = $Obj->uhdr("ORAC_OBJECT");
my $filter = $Obj->uhdr("ORAC_FILTER");

# If the source is not a calibrator, look for an appropriate flux
# specified in recipe parameters. The flux will be calculated later
# for known calibrator sources.
my $sourceflux;
if (!$Cal->iscalsource($src)) {
  if ( $filter =~ /850/ ) {
    $sourceflux = $Frm->uhdr("RECPAR_FLUX_850");
  } else {
    $sourceflux = $Frm->uhdr("RECPAR_FLUX_450");
  }
  if ( defined $sourceflux ) {
    $proceed = 1;
  } else {
    orac_warn "Unable to calculate a FCF for non-calibrator source, $src: no flux specified for filter $filter\n" if ($verbose);
    $proceed = 0;
  }
}

# Proceed with FCF calculation if it's OK to do so
if ( $proceed ) {
  orac_print "Calculating FCFs for $src -";

  # File to work on
  my $in = $Obj->file;

  # Get the current units so we quote the calibration factor
  $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
  my ($ORAC_STATUS, $dataunits) = $Mon{ndfpack_mon}->get("ndftrace","units");

  # For deriving FCFs we should be able to use the SkyRef attribute as
  # an initial guess
  $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=skyrefis");
  ($ORAC_STATUS, my $offset) = $Mon{ndfpack_mon}->get("wcsattrib","value");
  my $initpos;
  if ( lc($offset) eq "origin") {
    $initpos = [0.0, 0.0];
  } else {
    $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=skyref");
    ($ORAC_STATUS, my $skyref) = $Mon{ndfpack_mon}->get("wcsattrib","value");
    my @pos = split(/\, /,$skyref,2);
    $initpos = \@pos;
  }

  # Find the peak signal in the image
  _FIND_MAP_PEAK_ GROUP=$group FITPEAK=1 INITPOS=$initpos

  # Retrieve the position - if successful, proceed with deriving an FCF
  my $posn = $_FIND_MAP_PEAK_{POSITION};
  if (@$posn) {
    # Set the aperture radius using a recipe parameter, otherwise
    # default to twice the FWHM.
    my $radius = (defined $Frm->uhdr("RECPAR_APERTURE_RADIUS")) ?
      $Frm->uhdr("RECPAR_APERTURE_RADIUS") : 2.0*$Cal->fwhm;

    # Find the integrated intensity within a 1-arcmin diameter
    # aperture. Note that the image should have had some sort of
    # background removal done, though any remaining DC offset will be
    # removed in this calculation.
    _FIND_INTEGRATED_INTENSITY_ VERBOSE=0 IMAGE=$in XYPOS=$posn RADIUS=$radius

    # Beam conversion factor for BEAMEQUIV calibration
    my $fwhm = $Cal->fwhm;
    my $beamconv = 1.133 * $fwhm * $fwhm;

    # Retrieve the results
    my %results = ( BEAM => $_FIND_MAP_PEAK_{PEAK},
		    ARCSEC => $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX},
		    BEAMEQUIV => $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX} / $beamconv
		  );
    my %results_err = ( BEAM_ERR => $_FIND_MAP_PEAK_{PEAKERR},
			ARCSEC_ERR => $_FIND_INTEGRATED_INTENSITY_{SIGMATOTAL},
			BEAMEQUIV_ERR => $_FIND_INTEGRATED_INTENSITY_{SIGMATOTAL} / $beamconv
		      );

    my %fcf;

    # Temporary code to allow easy comparison of original calculations
    # with autophotom
    if ( $Frm->uhdr("RECPAR_AUTOPHOTOM") ) {
      orac_print " *** Deriving AP FCFs using autophotom ***\n";
      _APERTURE_PHOTOMETRY_ IMAGE=$in RADIUS=$radius
      $results{ARCSEC_AP} = $_APERTURE_PHOTOMETRY_{TOTALFLUX};
      $results{BEAMEQUIV_AP} = $_APERTURE_PHOTOMETRY_{TOTALFLUX} / $beamconv;
    }

    # Now run the matched-filter on the calibrator and fit the peak position
    _APPLY_MATCHED_FILTER_ IN=$in GROUP=$group VERBOSE=0
    _FIND_MAP_PEAK_ IMAGE=$_APPLY_MATCHED_FILTER_{OUT} VERBOSE=0 GROUP=$group GAUSSIAN=0
    my $matched_peak = $_FIND_MAP_PEAK_{PEAK};
    if ($matched_peak) {
      $results{BEAMMATCH} = $matched_peak;
      $results_err{BEAMMATCH_ERR} = $_FIND_MAP_PEAK_{PEAKERR};
      # Store the _mf file on the intermediates array so it can be
      # deleted later
      $Obj->push_intermediates($_APPLY_MATCHED_FILTER_{OUT});
    } else {
      orac_err "Unable to determine a FCF of type BEAMMATCH for this observation\n";
    }

    my $bad_results = 0;
    # Loop over the different type of results
    foreach my $type (sort keys %results) {
      my $errtype = $type . "_ERR";

      # Type specific configurations
      my ($ismap, $units);
      if ($type eq 'ARCSEC') {
	$ismap = 1;  # Need full integrated flux
	$units = "Jy/arcsec**2/$dataunits";
      } else {
	$units = "Jy/beam/$dataunits";
	if ($type eq 'BEAMEQUIV') {
	  # Need integrated flux for BEAMEQUIV calibration
	  $ismap = 1;
	} else {
	  $ismap = 0;
	}
      }

      orac_print "Determining calibration of type $type";
      unless (defined $results{$type}) {
	orac_print " - Failed!\n", "red";
	orac_err "Calibration did not return a result\n";
	orac_err "Unable to determine a FCF of type $type for this observation\n";
	$bad_results++;
	next;
      }
      # Trap zero when things have gone very badly wrong
      if ( $results{$type} <= 0) {
	$bad_results++;
	# This is obviously a Bad Thing (TM)
	orac_print " - Failed!\n", "red";
	my $garbage = ($results{$type} == 0) ? "zero"
	  : "a negative flux measurement";
	orac_err "Calibration returned $garbage\n";
	orac_err "Unable to determine a FCF of type $type for this observation\n";
	next;
      } else {
	orac_print "\n";
      }

      # Now get the flux for this filter
      my $flux = (defined $sourceflux) ? $sourceflux
	: $Cal->fluxcal($src, $filter, $ismap);

      # If we have a flux, store the FCF in the calibration system
      if (defined $flux) {
	orac_print "Flux ($type) = $flux; Data = ". $results{$type}. "\n";

	# Calculate the new gain
	my $fcf = $flux / $results{$type};
	my $dfcf = (defined $results_err{$errtype})
	  ? $fcf * ($results_err{$errtype} / $results{$type}) : 0.0;

	# Store the result in the calibration system
	my $pfcf = sprintf "%.4f", $fcf;
	my $pdfcf = sprintf "%.4f", $dfcf;
	if ( $store ) {
	  # Announce the new gain
	  orac_print("Storing new gain for $filter: $pfcf +/- $pdfcf $units\n",'yellow');

	  # Set the current gain - add to index file
	  # This means that we have to create a hash with the
	  # new keyword GAIN and the selected filter FILTER
	  $Obj->uhdr("GAIN", $fcf);
	  $Obj->uhdr("UNITS", $type);
	  $Obj->uhdr("FWHM", $fwhm);

	  # Need to append type to file name so that the keys are unique
	  $Cal->gainsindex->add($Obj->file() ."_$type",
				{ %{$Obj->hdr}, %{$Obj->uhdr}});
	} else {
	  orac_print ("Derived FCF for $filter: $pfcf +/- $pdfcf $units\n", "yellow");
	}
	$fcf{$type} = $fcf;

	# Additionally it seems that a user-friendly logfile is
	# a requirement
	my $logtype = "fcf";
	my @names = ("FCF", "FCFerr", "FCF_units", "FWHM");
	my @values = ($fcf, $dfcf, $type, $fwhm);
	_ADD_LOG_ENTRY_ LOGFILE=$logtype ENTRIES=\@values PARAMS=\@names GROUP=$group
      } else {
	orac_warn "Unable to calculate a flux for source $src\n";
      }

    }
    # Check if all the FCFs were bad in some way
    if ($bad_results >= scalar(keys %results)) {
      $Obj->isgood(0);
      orac_err "No FCFs could be determined for this observation: marking as bad\n";
    } else {
      # Store results in primitive hash
      $_FIND_CALIBRATION_MAP_{FCF} = \%fcf;
    }
  } else {
    if ( !$group ) {
      # If this is a Frame object and no FCF could be determined then
      # check if the image has enough s/n to detect it
      my $text = "";
      # Find the peak in a 30x30 pixel square box
      my $image = $Frm->file . "(~30,~30)";
      _FIND_IMAGE_STATISTICS_ IMAGE=$image VERBOSE=0
      _CALC_IMAGE_NOISE_ VERBOSE=0 LOGFILE=0
      my $snr = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MAX} / $_CALC_IMAGE_NOISE_{SIGMA};

      # Set minimum S/N of 10
      my $SNR_MIN = 10.0;
      $snr = sprintf "%.1f", $snr;
      if ( $snr < $SNR_MIN ) {
	$text = ": source too weak to locate (S/N = $snr)\n";
      } else {
	$text = ": bad data? (S/N = $snr)";
	$Obj->isgood(0);
	# Check Grp membership unless it's the last one so subsequent
	# calls to lastmember will still work as expected
	$Grp->check_membership unless ( $Grp->lastmember($Frm) );
      }
      orac_err "Unable to determine a FCF for this observation$text\n";
    } else {
      # Just issue a warning otherwise
      orac_warn "Unable to determine a FCF for this observation\n";
    }
  }

}
