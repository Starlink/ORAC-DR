#! -*-perl-*-

=head1 NAME

_CALC_SKY_NOISE_ - Determine background sky noise

=head1 DESCRIPTION

This primitive is the top-level method for calculating the sky
noise. Three methods are available which are described below.

The sky noise can be estimated using one of three available methods:

=over 4

=item MASK

Mask out all sources detected in the image and calculate the
statistics of the remaining valid pixels.

=item MINimum aperture

Systematically places a series of apertures on the image and
calculates the image statistics within that aperture. The minimum
value is the sky noise.

=item VARiance

Calls the _FIND_VARIANCE_ primitive to return the standard deviation
of the stacked image via the VARIANCE component of the input file.

=back

=head1 ARGUMENTS

The following arguments are supported:

=item B<SKYMETHOD>

Method by which the sky noise is determined. Valid values are
`minimum', `mask' and 'variance'. Default is variance. Minimum
matching is supported.

=item B<RADIUS>

Radius of apertures to use for aperture photometry (if USEPSF is 0)
and/or noise estimates. Default is 20 arcsec. A special value of -1
may be specified in which case the aperture is set by the major and
minor axes of the object.

=item B<LOGFILE>

A flag to indicate whether log files should be written containing the
results of the flux and noise calculations. Default is true.

=item B<GROUP>

If true, use the current Group file as input, otherwise use the
current Frame. Default is 0 (false: use current Frame).

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is true.

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

ARDMASK, STATS

=item Other SCUBA-2 primitives

_GET_PIXEL_SCALE_, _FIND_INTEGRATED_INTENSITY_, _FIND_VARIANCE_

=back

=head1 OUTPUT DATA

The following entry in the primitive hash is returned:

=over 4

=item SIGMA

Sky noise

=back

The frame object is not updated.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2007-2008 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# Write logfiles (default to true)
my $uselog = (exists $_CALC_SKY_NOISE_{LOGFILE} &&
	      defined $_CALC_SKY_NOISE_{LOGFILE}) ?
              $_CALC_SKY_NOISE_{LOGFILE} : 1;

# Should I be verbose? (Default to no)
my $verbose = (exists $_CALC_SKY_NOISE_{VERBOSE} && 
	       defined $_CALC_SKY_NOISE_{VERBOSE}) ?
               $_CALC_SKY_NOISE_{VERBOSE} : 0;

# Set aperture radius - default is 20 arcsec
my $radius = ( exists $_CALC_SKY_NOISE_{RADIUS} && 
	       defined $_CALC_SKY_NOISE_{RADIUS} ) ?
               $_CALC_SKY_NOISE_{RADIUS} : 20;

# Determine method for calculating noise
my $skymethod = ( exists ($_CALC_SKY_NOISE_{SKYMETHOD}) && 
		  defined ($_CALC_SKY_NOISE_{SKYMETHOD}) ) ? 
		  lc($_CALC_SKY_NOISE_{SKYMETHOD}): "var";

# See if an input file has been specified
my $in = (exists $_CALC_SKY_NOISE_{IMAGE} &&
	  defined $_CALC_SKY_NOISE_{IMAGE}) ?
          $_CALC_SKY_NOISE_{IMAGE} : "";

# Initialize the log files if necessary
my $noiselog;
if ($uselog) {
  my $time = gmtime();
  # Sky noise
  $noiselog = new ORAC::LogFile("log.noise");
  $noiselog->header("#Noise log file - created on $time",
		    "#\n#  Time       Filter  El     Noise     Sky     Seeing   CSO",
		    "#---------------------------------------------------------------"
		    );
}

# Determine if the user wants to use the current stacked Grp or Frm image
my $Obj;
# Flag to denote whether this primitive can be executed
my $calcnoise = 0;
my $group = defined( $_CALC_SKY_NOISE_{GROUP} ) ? 
  $_CALC_SKY_NOISE_{GROUP} : 0;
if ( $in eq "" ) {
  if( $group ) {
    $Obj = $Grp;
  } else {
    $Obj = $Frm;
  }
  if ( $Obj->nfiles == 1 ) {
    $in = $Obj->file;
    # Set calcnoise if the requested file exists
    if ( $Obj->file_exists ) {
      # Check if NEWIMAGE flag is set for Group image
      if ( $group ) {
	$calcnoise = ( $Grp->uhdr("NEWIMAGE") ) ? 1 : 0;
      } else {
	$calcnoise = 1;
      }
    } else {
      orac_warn "File $in does not exist: skipping this primitive\n" if $verbose;
    }
  } else {
    orac_throw "Error: _CALC_SKY_NOISE_ must be run after images have been combined\n";
  }
} else {
  # Unset uselog if an input file has been specified
  $uselog = 0;
}

# Proceed if all's well
if ( $calcnoise ) {
  my ($maskbright, $minap, $var);
  my $catalogue;
  if ( $skymethod =~ /^ma/ ) {
    # Find all of the sources in the current frame
    _FIND_SOURCES_ IMAGE=$in
    # Retrieve catalogue
    $catalogue = $_FIND_SOURCES_{CATALOGUE};
    if ( $catalogue->sizeof == 0 ) {
      orac_warn "Unable to use chosen MASK method for sky noise estimation - no sources in catalogue\nFalling back on default method `variance'\n";
      $maskbright = 0;
      $var = 1;
    } else {
      $maskbright = 1;
    }
  } elsif ( $skymethod =~ /^mi/ ) {
    $minap = 1;
  } elsif ( $skymethod =~ /^var/ ) {
    $var = 1;
  } else{
    orac_warn "Unknown choice for parameter SKYMETHOD, $skymethod - falling back on default value of `variance'\n";
    $maskbright = 0;
    $var = 1;
    $minap = 0;
  }
  my $sigma = undef;
  my $ORAC_STATUS;
  # 1) Mask out bright sources
  if ( $maskbright ) {
    # Create ARD file
    my $ard = new ORAC::TempFile;
    if (starversion_gt('kappa','V0.18-0')) {
      print {$ard->handle} "COFRAME(SKY,System=FK5)\n";
    }
    # Loop over all sources in image
    print {$ard->handle} "(\n";
    my $imax = $catalogue->sizeof;
    for my $i ( 1 .. $imax ) {
      my $source = $catalogue->starbyindex( $i - 1 );
      # Retrieve Astro::Coords object associated with current source
      my $coords = $source->coords;
      my $ra = $coords->ra;
      my $dec = $coords->dec;
      # Now retrieve morphology
      my $morph = $source->morphology;
      # Position angle
      my $pa = $morph->position_angle_world;
      # Major/minor axes - make 50% larger
      my $a = 7200.0 * $morph->major_axis_world;
      my $b = 7200.0 * $morph->minor_axis_world;
      # Elliptical aperture
      print {$ard->handle} "ELLIPSE($ra, $dec, 00:00:$a, 00:00:$b, $pa )\n";
    }
    print {$ard->handle} ")\n";
    $ard->handle->close;
    # Create temporary output file for ardmask
    my $outobj = new ORAC::TempFile;
    my $out = $outobj->file;
    # Name of ARD file
    my $ardin = $ard->file;
    my $ardargs;
    if (starversion_lt('kappa','V0.18-0')) {
      $ardargs = " cosys=data ";
    } else {
      $ardargs = " "; # in the ard file
    }
    # Mask out the bright sources
    $Mon{kappa_mon}->obeyw("ardmask", "in=$in out=$out ardfile=$ardin $ardargs");
    # Calculate statistics for the rest of the image
    $Mon{kappa_mon}->obeyw("stats","ndf=$out");
    ($ORAC_STATUS, $sigma) = $Mon{kappa_mon}->get("stats","sigma");
  } elsif ( $minap ) {
    # 2) Systematically plonk down an aperture across the image
    # Calc stats within each aperture: lowest std dev = sky noise
    _GET_PIXEL_SCALE_ IMAGE=$in VERBOSE=1 UNITS=arcsec WANTMAP=1

    # Retrieve bounds in pixel coords - note the implicit assumption
    # that the NDF has 2 dimensions.
    $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
    ($ORAC_STATUS, my $xmin, my $ymin) = $Mon{ndfpack_mon}->get("ndftrace","lbound");
    ($ORAC_STATUS, my $xmax, my $ymax) = $Mon{ndfpack_mon}->get("ndftrace","ubound");

    # Calculate size of image and determine number of apertures to use
    my $xsize = ($xmax - $xmin)*$_GET_PIXEL_SCALE_{RESULTS}->[0];
    my $ysize = ($ymax - $ymin)*$_GET_PIXEL_SCALE_{RESULTS}->[1];
    my $numxap = int($xsize / (2*$radius));
    my $numyap = int($ysize / (2*$radius));

    my $dx = int(($xmax - $xmin)/$numxap);
    my $dy = int(($ymax - $ymin)/$numyap);

    # Pixel to SKY mapping
    my $pixtosky = $_GET_PIXEL_SCALE_{MAPPING};

    # Should we set an upper limit on the number of apertures, say, 100?
    my (@xpixels, @ypixels);
    for my $i (1..$numxap) {
      for my $j (1..$numyap) {
	push ( @xpixels, $xmin + $i*$dx );
	push ( @ypixels, $ymin + $j*$dy );
      }
    }
    # Convert pixel positions to sky positions in one call
    (my $xsky, my $ysky) = $pixtosky->Tran2( \@xpixels, \@ypixels, 1);

    # Initialize the minimum sky level to something large
    my $minsky = 1.0e9;

    # Calculate number of pixels within an aperture
    my $npix = 3.1415926535 * $radius*$radius / 
      ($_GET_PIXEL_SCALE_{RESULTS}->[0] * $_GET_PIXEL_SCALE_{RESULTS}->[1]);

    # Now loop over number of apertures
    use Astro::Coords;
    for my $i (1..$numxap*$numyap) {
      # Convert X, Y positions to sexagesimal string via an Astro::Coords object
      my $coords = new Astro::Coords( ra => $xsky->[$i-1], dec => $ysky->[$i-1], 
				      units => 'radians', type => 'J2000' );
      my @xy = ( $coords->ra(format=>'s'), $coords->dec(format=>'s') );
#    my @xy = ($xsky->[$i-1], $ysky->[$i-1]);
      _FIND_INTEGRATED_INTENSITY_ RADIUS=$radius IMAGE=$in XYPOS=\@xy VERBOSE=0
	my $skynoise = $_FIND_INTEGRATED_INTENSITY_{SIGMA};
      my $ngood = $_FIND_INTEGRATED_INTENSITY_{NUMGOOD};
      $minsky = $skynoise if ( ($skynoise < $minsky) && ($ngood/$npix > 0.5) );
    }

    $sigma = $minsky;

  } elsif ( $var ) {
    # 3) Use the Variance component within the NDF as a measure of the noise
    _FIND_VARIANCE_ IMAGE=$in COMP=err
    $sigma = $_FIND_VARIANCE_{RESULT};
    # Check if sigma is a BAD value
    if ( $sigma == &NDF::VAL__BADD() ) {
      undef $sigma;
    }
  }

  if ( $sigma ) {
    orac_print "Sigma = $sigma \n";

    # Write info to log file if requested
    if ( $uselog ) {
      # UT string
      my $time= sprintf "%12.7f", $Frm->hdrval('ORACTIME',0);
      # Filter
      my $filt= sprintf "%4s", $Frm->hdr('FILTER');
      
      # Get TAU from the header - should get from $Cal object?
      my $cso = sprintf "%5.3f", 0.5*($Frm->hdrval('WVMTAUST', 0) + 
				      $Frm->hdrval('WVMTAUEN',-1));
      # Elevation
      my $el = int ( 0.5 * ($Frm->hdrval('ELSTART',0) + 
			    $Frm->hdrval('ELEND',-1) ) );
      # Seeing
      my $see = sprintf "%5.3f", ( 0.5 * ($Frm->hdrval('SEEINGST', 0) + 
					  $Frm->hdrval('SEEINGEN',-1)) );
      # Observation number
      my $obsnum = sprintf "%05d", $Frm->hdr('OBSNUM');
      # Noise
      my $skynoise = sprintf "%10.9f", $sigma;
      my $skylevel = 1.00;	# Placeholder

      # Write the entry:
      # UT, filter, El, Sky noise, Seeing, Sky level, tau225
      $noiselog->addentry("$time  $filt    $el   $skynoise   $skylevel     $see   $cso");
    }
  } else {
    orac_warn "No valid standard deviation found\n";
  }

  # If we are not logging these data to a file, store the noise in the
  # primitive hash
  unless ($uselog) {
    $_CALC_SKY_NOISE_{SIGMA} = $sigma;
  }
}
