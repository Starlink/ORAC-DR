#! -*-perl-*-

=head1 NAME

_CALC_NOISE_ - Determine noise in an image

=head1 DESCRIPTION

This primitive is the top-level method for calculating the image
noise. It may be used on a particular image or the current Frame or
Group file. If no image is specified via the B<IMAGE> parameter then
the B<GROUP> flag is used to determine whether to use the Frame or
Group image. If an image is given the standard deviation is returned
as an entry in the primitive hash and no log entry is written.

The noise can be estimated using one of three available methods:

=over 4

=item MASK

Mask out all sources detected in the image and calculate the
statistics of the remaining valid pixels.

=item MINimum aperture

Systematically places a series of apertures on the image and
calculates the image statistics within that aperture. The minimum
value is the sky noise.

=item VARiance

Calls the _FIND_VARIANCE_ primitive to return the standard deviation
of the stacked image via the VARIANCE component of the input file.

=back

=head1 ARGUMENTS

The following arguments are supported:

=item B<IMAGE>

Name of an image to be analyzed. 

=item B<METHOD>

Method by which the noise is determined. Valid values are C<minimum>,
C<mask> and C<variance>. Default is variance. Minimum matching is
supported.

=item B<RADIUS>

Radius of apertures to use for aperture photometry and/or noise
estimates. Default is 20 arcsec. A special value of -1 may be
specified in which case the aperture is set by the major and minor
axes of the object.

=item B<LOGFILE>

A flag to indicate whether log files should be written containing the
results of the flux and noise calculations. Default is 1
(true). However, if an input file is specified no log is written.

=item B<GROUP>

If true, use the current Group file as input, otherwise use the
current Frame. Default is 0 (false: use current Frame).

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is true.

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

ARDMASK, STATS

=item Other SCUBA-2 primitives

_GET_PIXEL_SCALE_, _FIND_INTEGRATED_INTENSITY_, _FIND_VARIANCE_

=back

=head1 OUTPUT DATA

The following entry in the primitive hash is returned unless a log
file entry is written:

=over 4

=item SIGMA

The standard deviation in the image

=back

The frame object is not updated.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2007-2008 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# Write logfiles (default to true)
my $uselog = get_prim_arg( $_PRIM_ARGS_, "LOGFILE", 1 );

# Should I be verbose? (Default to no)
my $verbose = get_prim_arg( $_PRIM_ARGS_, "VERBOSE", 0);

# Set aperture radius - default is 20 arcsec
my $radius = get_prim_arg( $_PRIM_ARGS_, "RADIUS", 20);

# Determine method for calculating noise
my $skymethod = lc(get_prim_arg( $_PRIM_ARGS_, "SKYMETHOD", "var" ));

# See if an input file has been specified
my $in = get_prim_arg( $_PRIM_ARGS_, "IMAGE", undef );

# Define PI
use constant PI => 3.1415926535;

# Determine if the user wants to use the current stacked Grp or Frm image
my $Obj;
# Flag to denote whether this primitive can be executed
my $calcnoise = 0;
my $group = get_prim_arg( $_PRIM_ARGS_, "GROUP", 0 );
unless ( defined $in ) {
  if( $group ) {
    $Obj = $Grp;
  } else {
    $Obj = $Frm;
  }
  if ( $Obj->nfiles == 1 ) {
    $in = $Obj->file;
    # Set calcnoise if the requested file exists
    if ( $Obj->file_exists ) {
      # Check if NEWIMAGE flag is set for Group image
      if ( $group ) {
	$calcnoise = ( $Grp->uhdr("NEWIMAGE") ) ? 1 : 0;
      } else {
	$calcnoise = 1;
      }
    } else {
      orac_warn "File $in does not exist: skipping this primitive\n" if $verbose;
    }
  } else {
    orac_throw "Error: _CALC_SKY_NOISE_ must be run after images have been combined\n";
  }
} else {
  # Unset uselog if an input file has been specified
  $uselog = 0;
}

# Proceed if all's well
if ( $calcnoise ) {
  my ($maskbright, $minap, $var) = (0, 0, 1);
  my $catalogue;
  if ( $skymethod =~ /^ma/ ) {
    # Find all of the sources in the current frame
    _FIND_SOURCES_ IMAGE=$in
    # Retrieve catalogue
    $catalogue = $_FIND_SOURCES_{CATALOGUE};
    if ( $catalogue->sizeof == 0 ) {
      orac_warn "Unable to use chosen MASK method for sky noise estimation - no sources in catalogue\nFalling back on default method `variance'\n";
      $maskbright = 0;
      $var = 1;
    } else {
      $maskbright = 1;
    }
  } elsif ( $skymethod =~ /^mi/ ) {
    $minap = 1;
  } elsif ( $skymethod =~ /^var/ ) {
    $var = 1;
  } else{
    orac_warn "Unknown choice for parameter SKYMETHOD, $skymethod - falling back on default value of `variance'\n";
    $maskbright = 0;
    $var = 1;
    $minap = 0;
  }
  my $sigma = undef;
  my $ORAC_STATUS;
  # 1) Mask out bright sources
  if ( $maskbright ) {
    # Create ARD file
    my $ard = new ORAC::TempFile;
    if (starversion_gt('kappa','V0.18-0')) {
      print {$ard->handle} "COFRAME(SKY,System=FK5)\n";
    }
    # Loop over all sources in image
    print {$ard->handle} "(\n";
    my $imax = $catalogue->sizeof;
    for my $i ( 1 .. $imax ) {
      my $source = $catalogue->starbyindex( $i - 1 );
      # Retrieve Astro::Coords object associated with current source
      my $coords = $source->coords;
      my $ra = $coords->ra;
      my $dec = $coords->dec;
      # Now retrieve morphology
      my $morph = $source->morphology;
      # Position angle
      my $pa = $morph->position_angle_world;
      # Major/minor axes - make 50% larger
      my $a = 7200.0 * $morph->major_axis_world;
      my $b = 7200.0 * $morph->minor_axis_world;
      # Elliptical aperture
      print {$ard->handle} "ELLIPSE($ra, $dec, 00:00:$a, 00:00:$b, $pa )\n";
    }
    print {$ard->handle} ")\n";
    $ard->handle->close;
    # Create temporary output file for ardmask
    my $outobj = new ORAC::TempFile;
    my $out = $outobj->file;
    # Name of ARD file
    my $ardin = $ard->file;
    my $ardargs;
    if (starversion_lt('kappa','V0.18-0')) {
      $ardargs = " cosys=data ";
    } else {
      $ardargs = " "; # in the ard file
    }
    # Mask out the bright sources
    $Mon{kappa_mon}->obeyw("ardmask", "in=$in out=$out ardfile=$ardin $ardargs");
    # Calculate statistics for the rest of the image
    $Mon{kappa_mon}->obeyw("stats","ndf=$out");
    ($ORAC_STATUS, $sigma) = $Mon{kappa_mon}->get("stats","sigma");
  } elsif ( $minap ) {
    # 2) Systematically plonk down an aperture across the image
    # Calc stats within each aperture: lowest std dev = sky noise
    _GET_PIXEL_SCALE_ IMAGE=$in VERBOSE=1 UNITS=arcsec WANTMAP=1

    # Retrieve bounds in pixel coords - note the implicit assumption
    # that the NDF has 2 dimensions.
    $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
    ($ORAC_STATUS, my $xmin, my $ymin) = $Mon{ndfpack_mon}->get("ndftrace","lbound");
    ($ORAC_STATUS, my $xmax, my $ymax) = $Mon{ndfpack_mon}->get("ndftrace","ubound");

    # Calculate size of image and determine number of apertures to use
    my $xsize = ($xmax - $xmin)*$_GET_PIXEL_SCALE_{RESULTS}->[0];
    my $ysize = ($ymax - $ymin)*$_GET_PIXEL_SCALE_{RESULTS}->[1];
    my $numxap = int($xsize / (2*$radius));
    my $numyap = int($ysize / (2*$radius));

    my $dx = int(($xmax - $xmin)/$numxap);
    my $dy = int(($ymax - $ymin)/$numyap);

    # Pixel to SKY mapping
    my $pixtosky = $_GET_PIXEL_SCALE_{MAPPING};

    # Should we set an upper limit on the number of apertures, say, 100?
    my (@xpixels, @ypixels);
    for my $i (1..$numxap) {
      for my $j (1..$numyap) {
	push ( @xpixels, $xmin + $i*$dx );
	push ( @ypixels, $ymin + $j*$dy );
      }
    }
    # Convert pixel positions to sky positions in one call
    (my $xsky, my $ysky) = $pixtosky->Tran2( \@xpixels, \@ypixels, 1);

    # Initialize the minimum sky level to something large
    my $minsky = 1.0e9;

    # Calculate number of pixels within an aperture
    my $npix = PI * $radius*$radius / 
      ($_GET_PIXEL_SCALE_{RESULTS}->[0] * $_GET_PIXEL_SCALE_{RESULTS}->[1]);

    # Now loop over number of apertures
    use Astro::Coords;
    for my $i (1..$numxap*$numyap) {
      # Convert X, Y positions to sexagesimal string via an Astro::Coords object
      my $coords = new Astro::Coords( ra => $xsky->[$i-1], dec => $ysky->[$i-1], 
				      units => 'radians', type => 'J2000' );
      my @xy = ( $coords->ra(format=>'s'), $coords->dec(format=>'s') );
      _FIND_INTEGRATED_INTENSITY_ RADIUS=$radius IMAGE=$in XYPOS=\@xy VERBOSE=0
      my $skynoise = $_FIND_INTEGRATED_INTENSITY_{SIGMA};
      my $ngood = $_FIND_INTEGRATED_INTENSITY_{NUMGOOD};
      $minsky = $skynoise if ( ($skynoise < $minsky) && ($ngood/$npix > 0.5) );
    }

    $sigma = $minsky;

  } elsif ( $var ) {
    # 3) Use the Variance component within the NDF as a measure of the noise
    _FIND_VARIANCE_ IMAGE=$in COMP=err
    $sigma = $_FIND_VARIANCE_{RESULT};
    # Check if sigma is a BAD value
    if ( $sigma == &NDF::VAL__BADD() ) {
      undef $sigma;
    }
  }

  if ( $sigma ) {
    # Write info to log file if requested
    if ( $uselog ) {
      _ADD_NOISE_LOG_ENTRY_ SIGMA=$sigma
    }
    $sigma = sprintf "%7.3f", $sigma;
    orac_print "Noise in image = $sigma \n";
  } else {
    orac_warn "No valid standard deviation found\n";
  }

  # If we are not logging these data to a file, store the noise in the
  # primitive hash
  unless ($uselog) {
    $_CALC_SKY_NOISE_{SIGMA} = $sigma;
  }
}
