# -*-cperl-*-

=head1 NAME

_CALCULATE_NEFD_

=head1 SYNOPSIS

_CALCULATE_NEFD_ METHOD=MEAN

=head1 DESCRIPTION

Calculate the Noise Equivalent Flux Density (NEFD) of the current
observation.

The NEFD is calculated using the formula:

NEFD = noise * sqrt(time)

where noise is in mJy, the time is the total integration time in
seconds. The units of NEFD are therefore mJy/rtHz. The integration
time is derived from the C<EXP_TIME> extension in the image.

The results are written to a log file, C<log.nefd>.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<GROUP>

Flag to indicate whether to obtain results from the Group file. Only
accessed if B<USENOISE>=0. Default is 0 (use the current Frame).

=item B<LOGFILE>

Flag to indicate whether or not to write a log file to disk. Default
is 1 (write a log file).

=item B<METHOD>

Preferred estimator for integration time. Valid options are C<MEAN>,
C<MEDIAN> or C<MODE>. Only accessed if B<USENOISE>=0. Default is
C<MEDIAN>.

=item B<USENOISE>

Flag to denote whether to determine the NEFD from noise data or from a
map. Default is 1 (use noise data).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

CMULT

=item ORAC-DR PRIMITIVES:

_FIND_IMAGE_STATISTICS_, _FIND_VARIANCE_, _GET_LOG_PARAMETERS_

=back

=head1 NOTES

This primitive must be run on calibrated images.

For the case when B<USENOISE>=1, this primitive will give erroneous
results in offline mode.

=head1 OUTPUT DATA

If no log file is to be written, then the primitive hash contains the
key C<NEFD> with the calculated NEFD.

=head1 OUTPUT FILES

Optionally writes a log file C<log.nefd>.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Write a log file? Default to yes
my $uselog = get_prim_arg( $_PRIM_ARGS_, "LOGFILE", 1 );

# Use the noise image or object image?
my $usenoise = get_prim_arg( $_PRIM_ARGS_, "USENOISE", "1");

if ($usenoise) {

  if ( $Frm->uhdr("NOISE") ) {
    # Obtain the files in the current Frame - there will be one file per
    # subarray at this point.
    my @noisefiles = $Frm->files;

    # FCF, tau and airmass are independent of subarray
    # But for a skydip we are going to need to choose different
    # airmasses rather than using an average
    my $fcf = $Cal->gain($Frm->uhdr("ORAC_FILTER"), "BEAM") * 1000;

    # so if we have multiple files for nefd calculation
    # we will read information from each file
    # else just use the header values
    my @fileinfo;

    my $calc_extcor = sub {
      my $frm = shift;
      my $tau = $frm->uhdr("ORAC_TAU");
      my $airmass = 0.5*($frm->uhdr("ORAC_AIRMASS_START") +
                         $frm->uhdr("ORAC_AIRMASS_END"));
      return { airmass => $airmass,
               tau => $tau,
               extcor => exp($tau * $airmass) };
    };

    if (@noisefiles == 1) {
      @fileinfo = ( $calc_extcor->( $Frm ) );
    } else {
      # read the files and translate the headers
      for my $f (@noisefiles) {
        my $tmpfrm = $Frm->new();
        $tmpfrm->raw( $f );
        $tmpfrm->file( $f );
        $tmpfrm->readhdr;
        push(@fileinfo, $calc_extcor->($tmpfrm) );
      }
    }

    # FCF is in Jy/beam/pW; NEP is in W Hz**-0.5. Therefore need to
    # multiply by 1e12 to get the units right.
    for my $item (@fileinfo) {
      $item->{mult} = $item->{extcor} * $fcf * 1.0e12;
    }

    # Calculate NEFD for each file
    foreach my $noisefile (@noisefiles) {

      my $nep = $noisefile.".more.smurf.nep";

      my $nefd = new ORAC::TempFile;
      my $nefdimage = $nefd->file;
      my $info = shift(@fileinfo);
      $Mon{kappa_mon}->obeyw("cmult","in=$nep out=$nefdimage scalar=".$info->{mult});

      _FIND_IMAGE_STATISTICS_ IMAGE=$nefdimage VERBOSE=0 HISTAT=1 COMP=DATA

      my $median = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEDIAN};
      if (defined $median) {
        my $trans = sprintf "%3d", 100.0 / $info->{extcor};
        $median = sprintf "%6.2f", $median;
        my $airmass = sprintf "%6.4f", $info->{airmass};
        orac_print ("NEFD = $median mJy/beam/Hz**0.5, "
                    ."Sky trans = $trans %, A = $airmass\n", "yellow");
      } else {
        orac_warn "Could not determine median NEFD for $noisefile\n";
      }
    }
  }
} else {

  # Has the user requested the use of the Group image?
  my $groupflag = get_prim_arg( $_PRIM_ARGS_, "GROUP", 0 );
  my $Obj = ( $groupflag ) ? $Grp : $Frm;

  # Integration time estimator - default is MEDIAN
  my $estimator = uc(get_prim_arg( $_PRIM_ARGS_, "METHOD", "MEDIAN" ));
  # Check we were given something sensible
  unless ( $estimator eq "MEDIAN" || $estimator eq "MEAN" || $estimator eq "MODE" ) {
    orac_warn "_CALCULATE_NEFD_: Unrecognized estimator for integration time, $estimator\n falling back on default (MEDIAN)\n";
    $estimator = "MEDIAN";
  }

  # This primitive must be run after files have been combined into a
  # mosaic
  if ( $Obj->nfiles == 1 ) {

    # Retrieve current file associated with Frame or Group
    my $datafile = $Obj->file;

    # Obtain variance of current image
    _FIND_VARIANCE_ IMAGE=$datafile COMP=err
      my $noise = $_FIND_VARIANCE_{RESULT};

    # Obtain median exposure time
    $datafile .= ".MORE.SMURF.EXP_TIME";
    _FIND_IMAGE_STATISTICS_ IMAGE=$datafile VERBOSE=0
      my $texp = $_FIND_IMAGE_STATISTICS_{RESULTS}->{$estimator};

    # Calculate NEFD
    my $nefd = $noise * sqrt( $texp );

    if ( $uselog ) {
      # Write entry to a log file
      my $time = gmtime();
      my $nefdlog = new ORAC::LogFile("log.nefd");
      $nefdlog->header("#NEFD log file - created on $time UT",
                       "#\n# UT                HST   Obs Source       Mode           Filter  El CSO    Tau  Seeing  NEFD",
                       "#----------------------------------------------------------------------------------------------------");

      # Get general parameters for logging
      _GET_LOG_PARAMETERS_ GROUP=$groupflag
        my ($uttime, $hst, $obsnum, $src, $mode, $filter, $el, $cso, $tau, $see) =
          @{ $_GET_LOG_PARAMETERS_{PARAMS} };

      # Reformat NEFD for printing
      $nefd = sprintf "%9.5f", $nefd;

      # Write entry
      $nefdlog->addentry("$uttime $hst $obsnum $src $mode   $filter   $el $cso $tau $see  $nefd");
    } else {

      # If we're not writing a log file, return the NEFD to the caller
      $_CALCULATE_NEFD_{NEFD} = $nefd;

    }

  } else {
    orac_warn "_CALCULATE_NEFD_ must be run after files have been combined\n";
  }
}
