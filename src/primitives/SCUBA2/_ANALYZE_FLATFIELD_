# -*-cperl-*-

=head1 NAME

_ANALYZE_FLATFIELD_ - Analyze the current flatfield solution

=head1 SYNOPSIS

_ANALYZE_FLATFIELD_ ERR=1

=head1 DESCRIPTION

Analyze the current flatfield solution and compare with previous
flatfields. The analysis is performed on the current and previous
responsivity images and is only carried out if the OBSEND FITS header
flag is true. The results are displayed numerically (including
percentage changes) and visually (see the documentation for
_DISPLAY_RESPONSIVITIES_ for further information).

On completion, a flag file is written to indicate that flatfield
processing is complete and the flatfield solution is stored in the
calibration system.

This is a Frame operation.

=head1 ARGUMENTS

This primitive supports the following arguments:

=over 4

=item B<CLIP>

Level at which to clip the data before calculating statistics, given
in number of standard deviations. Default is 0, no clipping.

=item B<ERR>

Flag to denote whether to analyze the error in the responsivities
rather than the responsivities themselves. Default is 0 (false), use
the responsivity data.

=item B<LOGFILE>

Flag to denote whether or not to write a log file. Default is 1
(yes). Log file is called C<log.flatfield>.

=item B<LOGPAR>

Specifies the type of log file to write. May be C<ABS> or C<DIFF>
depending on whether absolute values from both solutions are required,
or just those from the new solution and the differences from the
previous. Default is C<DIFF>.

=item B<PERCENTILES>

Comma-separated list of percentiles to calculate. Default is the null
parameter, C<!>, which indicates no percentiles.

=item B<RESPRATIO>

A flag to indicate whether an output image is created of the ratio of
the current and previous responsivities. Default is 0 (do not
calculate the ratio image).

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA:

NDFTRACE

=item ORAC-DR PRIMITIVES:

_ADD_FLATFIELD_LOG_ENTRY_, _DISPLAY_RESPONSIVITIES_,
_FIND_IMAGE_STATISTICS_, _WRITE_FLAG_FILE_

=back

=head1 NOTES

It might be more logical to write the flag file and store the
flatfield in the calibration system in _CALCULATE_FLATFIELD_ rather
than here.

=head1 OUTPUT DATA

The name of each flatfield solution is stored in the calibration
system in C<index.flat>.

The percentage change image is stored as an NDF extension in the
flatfield file called C<RESP_DELTA> (under .MORE.SMURF).

If the B<RESPRATIO> parameter is true, then the responsivity ratio
image is also stored as an NDF extension called C<RESP_RATIO>.

=head1 OUTPUT FILES

A (hidden) flag file is written with the extension C<.ok> which
contains the names of all of the new flatfield solutions. it is
written after the pipeline has performed its own analysis.

If B<LOGFILE> is true, then the file C<log.flatfield> is written with
the current subarray, median, mean, sigma, max, min and number of good
solutions along with assoaicted changes compared with previous
solutions. See the documentation for
L<_ADD_FLATFIELD_LOG_ENTRY_|_ADD_FLATFIELD_LOG_ENTRY_> for more
details.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2008-2009 the University of British Columbia.  All
Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Flatfield can only be calculated after the observation has ended
if ( $Frm->uhdr("OBSEND") ) {

  # Flag to denote whether to write a log file
  my $uselog = get_prim_arg( $_PRIM_ARGS_, "LOGFILE", 1 );

  # Get ERR argument
  my $err = get_prim_arg( $_PRIM_ARGS_, "ERR", 0 );

  # Which component to analyze?
  my $comp = ( $err ) ? "err" : "data";
  my $preftext = ( $err ) ? "Uncertainties in" : "Values of";

  # Level to clip the data before calculating statistics?
  my $clip = get_prim_arg( $_PRIM_ARGS_, "CLIP", "" );

  # Percentiles
  my $percentiles = get_prim_arg( $_PRIM_ARGS_, "PERCENTILES", "!" );

  # What type of log file should be written? Absolute values or
  # differences?
  my $logpar = lc(get_prim_arg( $_PRIM_ARGS_, "LOGPAR", "diff" ));
  my $abslog = ($logpar eq "abs") ? 1 : 0;

  # Is the responsivity analysis calculating a ratio or a percentage
  # change image? Default to percentage change.
  my $respratio = get_prim_arg( $_PRIM_ARGS_, "RESPRATIO", 0 );

  # List of flatfield file names for writing to flag (.ok) file
  my @flatfiles;

  # List of alternative `previous' fastflat solutions for comparison
  my %fastflats = %{$Grp->uhdr("FASTFLATSOL")}
    if (defined $Grp->uhdr("FASTFLATSOL"));

  # Loop over subarrays... Use subgrps method to return list of Groups
  # sorted by subarray
  my @Grps = $Grp->subgrps( "SUBARRAY" );

  foreach my $Subgrp ( @Grps ) {
    my @frames = $Subgrp->members;
    # Retrieve the representative Frame object
    my $Frmobj = $frames[0];
    # Retrieve flatfield solution
    my $flatfile = $Frmobj->file;
    # Store the current flatfield file in the list to be written.
    # Note that the flag file is written regardless of whether the
    # solution is any good.
    push( @flatfiles, $flatfile );

    # If this is a FASTFLAT then look for the earlier solution
    if (defined $fastflats{$Frmobj->hdr("SUBARRAY")}) {
      my $newprevious = $fastflats{$Frmobj->hdr("SUBARRAY")} .".more.smurf.resp_new";
      my $cpargs = "in=$newprevious out=".($Frmobj->uhdr("RESP_OLD"));
      $Mon{ndfpack_mon}->obeyw("ndfcopy","$cpargs");
    }

    # Get responsivity file names
    my $respfile = $Frmobj->uhdr("RESP_NEW");
    my $previous = $Frmobj->uhdr("RESP_OLD");

    # Get the responsivity units if info is being displayed to the screen
    my $units;
    unless ( $uselog ) {
      $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$respfile");
      (my $ORAC_STATUS, $units) = $Mon{ndfpack_mon}->get("ndftrace","units");
    }

    my $subarray = $Frmobj->hdr('SUBARRAY');

    # Check there are enough solutions to analyze - unset the CLIP parameter
    if ( $Frmobj->uhdr("NUMGOOD") < 10 ) {
      my $numgood = $Frmobj->uhdr("NUMGOOD");
      orac_warn "Very few good solutions for subarray $subarray ($numgood)\n";
      $clip = "";
    }

    # Check if we really have a responsivity file
    if ( $respfile && $previous ) {
      ### Calculate responsivity statistics ###
      # Analyze current resp file - use STATS for sigma-clipping
      _FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0 PERCENTILES=$percentiles
      my %results = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
      # Now get the mode using HISTAT
      if ( $results{NUMGOOD} > 0 ) {
        _FIND_IMAGE_STATISTICS_ IMAGE=$respfile COMP=$comp VERBOSE=0
        $results{MODE} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MODE};
      } else {
	# If this happens then something went badly wrong!
	$results{MODE} = 0.0;
      }
      $results{LABEL} = "END  ";

      # Calculate how many values have been dropped due to
      # sigma-clipping and what proportion that represents
      my $totalgood = $_FIND_IMAGE_STATISTICS_{RESULTS}->{NUMGOOD};
      my $dn = $totalgood - $results{NUMGOOD};
      # Trap division by zero - set a dummy 100% as a default
      my $dnpc = ($totalgood > 0) ? sprintf "%5.1f", 100.0 * $dn/$totalgood
	: 100;

      # Analyze previous resp solution - use STATS to get
      # sigma-clipped statistics
      _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0 CLIP=$clip HISTAT=0 PERCENTILES=$percentiles
      my %previous = %{ $_FIND_IMAGE_STATISTICS_{RESULTS} };
      # Now get the mode using HISTAT
      if ( $previous{NUMGOOD} > 0 ) {
        _FIND_IMAGE_STATISTICS_ IMAGE=$previous COMP=$comp VERBOSE=0
        $previous{MODE} = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MODE};
      } else {
	# We can get here if there is no previous solution to analyze
	$previous{MODE} = 0.0;
      }
      $previous{LABEL} = "START";

      ### Obtain and store the desired statistics for printing/logging ###
      # Print out results from current solution and calculate
      # percentage changes from previous solution
      orac_print ("---- $preftext responsivity fits for subarray $subarray ---- \n", "green");
      orac_print ("---- Clipped at $clip sigma ($dn solutions omitted = $dnpc %) ----\n", "green")
	if ($clip ne "");
      # Define two arrays to hold the results for the current and
      # previous solutions respectively. The `current' array is always
      # populated, and has diff values included under normal
      # circumstances. When writing an absolute-value log file (such
      # as when comparing fast-ramp flatfields), the `previous' array
      # is populated. Each set of results is written as an entry to
      # the log file if appropriate.
      my @curlogpar = ($subarray);
      my (@prelogpar, @perval, @pervalstrings);
      # Add extra parameters if an `absolute' logfile is being written
      if ($abslog) {
	push(@curlogpar, $results{LABEL});
	push(@prelogpar, $subarray, $previous{LABEL});
      }
      my $numdiff = $results{NUMGOOD} - $previous{NUMGOOD};
      # Loop over the statistics calculated above and reformat to
      # store in the array(s) as necessary
      foreach my $stat ( qw/ MEDIAN MEAN MODE SIGMA MAX MIN / ) {
        my $curval = $results{$stat};
        if ($curval == &NDF::VAL__BADD) {
          $curval = "NaN" + 0;
        } else {
          $curval = sprintf "%11.4f", $results{$stat};
        }
        my $diff;
        if ($previous{$stat} eq &NDF::VAL__BADD) {
          $diff = "NaN" + 0;
        } else {
          $diff = sprintf "%11.4f", ($results{$stat} - $previous{$stat});
        }
	if ($uselog) {
	  push (@curlogpar, $curval);
	  if ($abslog) {
	    my $preval = sprintf "%11.4f", $previous{$stat};
	    push (@prelogpar, $preval);
	  } else {
	    push (@curlogpar, $diff);
	  }
	} else {
	  my $deltapc = sprintf "%4.1f", 100*abs($diff / $previous{$stat});
	  my $incdec = ( $diff == 0) ? "change" :
	    (( $diff > 0 ) ? "increase" : "decrease");
	  # Align the output for easy reading
	  my $outstat = sprintf "%-8s", $stat;
	  orac_print ( " $outstat = $curval $units ( $deltapc % $incdec )\n",
		       "green");
	}

	# Store in uhdr
	$Frmobj->uhdr( $stat, $curval );
	$Frmobj->uhdr( "D".$stat, $diff );
      }

      ### Write results to log file if appropriate ###
      if ($uselog) {
	push (@curlogpar, $results{NUMGOOD});
	my $logtype = "flatfield";

	my @names;
	my $parlist = "BRIEF";
	# For absolute log files, the previous details must be written
	# first
	if ($abslog) {
	  $parlist = "FULL";
	  push (@prelogpar, $previous{NUMGOOD});

	  # Define an anon sub to get the percentiles info
	  my $get_percentiles = sub {
	    my ($flatsol, $percentiles) = @_;
	    my $pervals = $flatsol->{PERCENTILES};
	    # List of requested percentiles and calculated values
	    my @pc = split(/\,/, $percentiles);
	    my @pervals = (ref($pervals) eq "ARRAY") ? @{$pervals} : ($pervals);
	    # Arrays to store returned values
	    my (@pervalpar, @pervalstrings);
	    # Loop over the elements in the arrays
	    for my $i (0 .. $#pc) {
	      push(@pervalstrings, "PC_".$pc[$i]);
	      my $value = sprintf "%11.4f", $pervals[$i];
	      push(@pervalpar, $value);
	      push(@pervalstrings, "DELTA_".$pc[$i]);
	      # Define the DELTA value as the difference between the
	      # value at the current percentile and the mode, divided
	      # by sigma
	      $value = sprintf "%11.4f", ($pervals[$i] - $flatsol->{MODE}) / $flatsol->{SIGMA};
	      push(@pervalpar, $value);
	    }
	    return [ \@pervalpar, \@pervalstrings];
	  };

	  # Get the percentiles info provided the percentiles
	  # parameter is not null
	  if ( $percentiles ne "!" ) {
	    my $pcresults = $get_percentiles->(\%results, $percentiles);
	    push(@curlogpar, @{$pcresults->[0]});
	    push(@pervalstrings, @{$pcresults->[1]});

	    $pcresults = $get_percentiles->(\%previous, $percentiles);
	    push(@prelogpar, @{$pcresults->[0]});
	  }

	  @names = ("Subarray", "Fastflat", "Median", "Mean", "Mode", "Sigma", "Max", "Min", "Ngood", @pervalstrings);
	  _ADD_LOG_ENTRY_ LOGFILE=$logtype ENTRIES=\@prelogpar PARAMS=\@names PARLIST=$parlist
	} else {
	  @names = ("Subarray", "Median", "Delta", "Mean", "Delta", "Sigma", "Delta", "Max", "Delta", "Min", "Delta", "Ngood", "Delta");
	  push(@curlogpar, $numdiff);
	}
	_ADD_LOG_ENTRY_ LOGFILE=$logtype ENTRIES=\@curlogpar PARAMS=\@names PARLIST=$parlist
      }

      ### Now print out the change in the number of good solutions ###
      my $numstring = "no change";
      # Make sure we don't divide by zero - set a dummy 100% as a default
      my $deltapc = ($previous{NUMGOOD} > 0)
	? sprintf "%4.1f", 100*abs($numdiff / $previous{NUMGOOD})
	  : 100;
      $numstring = abs($numdiff) . " changed : $deltapc % ".
	($numdiff > 0 ? "increase" : "decrease");
      orac_print (" NGOOD    = $results{NUMGOOD} solutions ( $numstring )\n",
		  "green");
      # Store in uhdr
      $Frmobj->uhdr( "NGOOD", $results{NUMGOOD} );
      $Frmobj->uhdr( "DNGOOD", $numdiff );

      ### Create the `percentage change' image ###
      my $deltafile = $Frmobj->inout("_pcrsp");
      my $exp = "PA*(IA-IB)/IB";
      my $args = "exp=$exp IA=$respfile IB=$previous PA=100.0 out=$deltafile";
      $Mon{kappa_mon}->obeyw("maths","$args");
      # Set the title to something meaningful
      my $sign = ( $Frmobj->uhdr("DNGOOD") > 0 ) ? "+" : "-";
      my $title = "Change (%) / N = ".$Frmobj->uhdr("NGOOD")." ($sign".abs($Frmobj->uhdr("DNGOOD")).")";
      $args = "ndf=$deltafile title='".$title."'";
      $Mon{ndfpack_mon}->obeyw("settitle","$args");

      # Store this as another extension in flatfield file
      my $pcresp = $flatfile.".MORE.SMURF.RESP_DELTA";
      $Mon{ndfpack_mon}->obeyw("ndfcopy","in=$deltafile out=$pcresp");
      # However, for display purposes, store the original percentage
      # change image
      $Frmobj->uhdr("RESP_DELTA", $deltafile);

      # Display the results
      _DISPLAY_RESPONSIVITIES_ FRAME=$Frmobj CLIP=$clip

      # Now create the resposivity ratio image if requested - note
      # there is no display associated with this image
      if ($respratio) {
	my $ratiofile = new ORAC::TempFile;
	my $title = "Ratio of fastramp flatfields from beginning and end of obs";
	my $args = "in1=$previous in2=$respfile out=$ratiofile title='".$title."'";
	$Mon{kappa_mon}->obeyw("div","$args");
	# Store this as another extension in flatfield file
	my $respratio = $flatfile.".MORE.SMURF.RESP_RATIO";
	$Mon{ndfpack_mon}->obeyw("ndfcopy","in=$ratiofile out=$respratio");

	# No display as yet - no entries in disp.dat, will need to
	# update _DISPLAY_RESPONSIVITIES_ too
      }
    } else {
      orac_warn "No responsivity file for subarray $subarray\n";
    }

    # Finally register the flatfield with the Calibration system -
    # note this has to be done after the analysis in order to store
    # the results in the index file
    $Cal->flatindex->add( $flatfile, {%{$Frmobj->hdr}, %{$Frmobj->uhdr}} );

    # HACK - remove the .more.smurf.resp* files from the intermediates
    # array so they are not deleted.
    my @newintermediates;
    foreach my $interfile ( $Frmobj->intermediates ) {
      push (@newintermediates, $interfile)
	unless ( $interfile =~ /.more.smurf.resp/i);
    }
    $Frmobj->intermediates(@newintermediates);
  }
  # Now create an ok file to indicate processing is complete.
  if ( @flatfiles ) {
    _WRITE_FLAG_FILE_ FILES=\@flatfiles PREFIX=s
    $Frm->uhdr("FLATFIELD",1);
  } else {
    $Frm->uhdr("FLATFIELD",0);
  }

}
