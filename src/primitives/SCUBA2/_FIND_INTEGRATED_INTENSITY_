# -*-perl-*-

=head1 NAME

_FIND_INTEGRATED_INTENSITY_ - aperture photometry of image using statistics

=head1 SYNOPSIS

 _FIND_INTEGRATED_INTENSITY_ IMAGE=$image XYPOS=\@xy

 _FIND_INTEGRATED_INTENSITY_ IMAGE=$image XYPOS=\@xy RADIUS=50

=head1 DESCRIPTION

This primitive calculates the integrated intensity, in whatever units
the image is currently using, around a single (point) source that is
assumed to be the only source on the map (so that the sky contribution
can be calculated). The value is corrected for pixel area and has a
background level subtracted from it. The SKY domain is used
throughout; the coordinate system used is the current one as obtained
from the WCS C<system> attribute.

The background is estimated by masking out the source and calculating
the mean value in the image. This method will work well for
DREAM/STARE images or SCAN images made with the iterative map-maker
which have a single point source. The rebinning map maker for SCAN
data will produce a bowl around a bright source which this method will
not cope with.

The integrated intensity is calculated using the following procedure:

=over 4

=item 1

Define radius of aperture (input parameter, or default of 20 arcsec)

=item 2

Mask all data outside the calculated radius centred on the given position.

=item 3

Calculate the sum of all valid pixels.

=back

Results are returned in the primitive hash.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<IMAGE>

Input image. No default.

=item B<RADIUS>

The radius of the aperture in arcsec. Default is 20 arcsec.

=item B<VERBOSE>

Flag to indicate whether informational messages should be given to the
user. Default is true.

=item B<XYPOS>

An array reference containing the formatted X, Y coordinates in the
chosen frame. No default.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA:

ARDMASK, WCSATTRIB

=item ORAC-DR PRIMITIVES:

_FIND_IMAGE_STATISTICS_, _GET_PIXEL_SCALE_

=back

=head1 NOTES

The current coordinate frame must be a SKY frame. No checks are made.

It may be desireable to allow different (e.g. PIXEL) frames to be used.

=head1 OUTPUT DATA

On successful completion, the primitive hash
C<%_FIND_INTEGRATED_INTENSITY_> contains the following keys (undef if
the method failed):

=over 4

=item NUMGOOD

The number of pixels which contribute to the estimate of the flux

=item NUMPIX

The total number of pixels in the image

=item PEAKFLUX

The peak intensity in the aperture

=item SIGMA

The standard deviation in the image

=item SUM

The sum of the data values from all pixels within the aperture

=item TOTALFLUX

The total flux within the aperture in units of
signal_units*pixel_units^2

=back

The Frame object is not updated.

=head1 OUTPUT FILES

None.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>,
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 2005-2007 Particle Physics and Astronomy Research
Council. Copyright (C) 2005-2008 University of British Columbia. All
Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# Set the input file name
my $in = get_prim_arg( $_PRIM_ARGS_, "IMAGE", undef );

unless ( defined ($in) ) {
  orac_throw "Error: _FIND_INTEGRATED_INTENSITY_ must be supplied with an image\n";
}

# Should I be verbose (default to yes)
my $verbose = get_prim_arg( $_PRIM_ARGS_, "VERBOSE", 1 );

# Define X and Y positions
my $xypos = get_prim_arg( $_PRIM_ARGS_, "XYPOS", undef );
my ($x, $y);
if (defined $xypos && ref($xypos) eq 'ARRAY') {
  ($x, $y) = @$xypos;
  # what should happen if we have undef x and y?
  orac_throw "Error: Empty position provided to _FIND_INTEGRATED_INTENSITY_\n"
      unless (defined $x && defined $y);
} else {
  orac_throw "Error: must provide an array reference with X, Y position of source\n";
}

# Set radius of mask - default is 20 arcsec
my $radius = get_prim_arg( $_PRIM_ARGS_,"RADIUS", 20.0 );

# Initialize entries in primitive hash
foreach my $item (qw/ PEAKFLUX TOTALFLUX SUM SIGMA NUMGOOD NUMPIX /) {
  $_PRIM_ARGS_->{$item} = undef;
}

# Create the temporary file for the ard description
my $ard = new ORAC::TempFile;

my $ORAC_STATUS;
# Get current coordinate system
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=system(1)");
($ORAC_STATUS, my $cosys) = $Mon{ndfpack_mon}->get("wcsattrib","value");
# Convert string to upper case
$cosys = uc($cosys);

# Write the ard description - start with the coordinate frame
print {$ard->handle} "COFRAME(SKY,System=$cosys)\n";

# Mask out everything EXCEPT a circle centred on X, Y. Radius has to
# be specified correctly in current coordinate system.
# If AzEl or Galactic, convert to degrees
if ( $cosys eq "AZEL" || $cosys eq "GALACTIC" ) {
  my $dradius = $radius/3600.0;
  print {$ard->handle} ".NOT.CIRCLE($x, $y, $dradius)\n";
} else {
  # All other supported systems are HMS/DMS so need to format
  # correctly
  if ( $radius < 60.0 ) {
    print {$ard->handle} ".NOT.CIRCLE($x, $y, 00:00:$radius)\n";
  } else {
    my $mradius = int( $radius / 60.0 );
    my $sradius = $radius - ($mradius * 60);
    print {$ard->handle} ".NOT.CIRCLE($x, $y, 00:$mradius:$sradius)\n";
  }
}

# Close the file
$ard->handle->close;

# Get temporary output file
my $outobj = new ORAC::TempFile;
my $out = $outobj->file;
my $ardin = $ard->file;

# Run ardmask
$Mon{kappa_mon}->obeyw("ardmask", "in=$in out=$out ardfile=$ardin ");

# Find stats on the masked image to get the flux in the aperture
_FIND_IMAGE_STATISTICS_ IMAGE=$out VERBOSE=0 HISTAT=0
my $sum     = $_FIND_IMAGE_STATISTICS_{RESULTS}->{SUM};
my $maxflux = $_FIND_IMAGE_STATISTICS_{RESULTS}->{MAX};
my $ngood   = $_FIND_IMAGE_STATISTICS_{RESULTS}->{NUMGOOD};
my $npix    = $_FIND_IMAGE_STATISTICS_{RESULTS}->{NUMPIX};
my $sigma   = $_FIND_IMAGE_STATISTICS_{RESULTS}->{SIGMA};

# Now repeat for the rest of the image - mask out the central source
# and calculate a mean background. Note this will only provide a
# useful result for DREAM/STARE images with a single point source in
# the centre. The QL scan-mapmaker will produce a bowl around a bright
# source which this method will not deal with.

# Create another temporary file for the new ard description
$ard = new ORAC::TempFile;

# Write the ard description - start with the coordinate frame
print {$ard->handle} "COFRAME(SKY,System=$cosys)\n";

# Mask out a circle centred on X, Y as above
if ( $cosys eq "AZEL" || $cosys eq "GALACTIC" ) {
  my $dradius = $radius/3600.0;
  print {$ard->handle} "CIRCLE($x, $y, $dradius)\n";
} else {
  # All other supported systems are HMS/DMS so need to format
  # correctly
  if ( $radius < 60.0 ) {
    print {$ard->handle} "CIRCLE($x, $y, 00:00:$radius)\n";
  } else {
    my $mradius = int( $radius / 60.0 );
    my $sradius = $radius - ($mradius * 60);
    print {$ard->handle} "CIRCLE($x, $y, 00:$mradius:$sradius)\n";
  }
}

# Close the ard file
$ard->handle->close;

# Get a temporary output file
my $bgoutobj = new ORAC::TempFile;
my $bgout = $bgoutobj->file;
$ardin = $ard->file;

# Run ardmask to mask out source
$Mon{kappa_mon}->obeyw("ardmask", "in=$in out=$bgout ardfile=$ardin ");

# Now calculate stats of the masked file to get the mean (background)
# level outside the source aperture
_FIND_IMAGE_STATISTICS_ IMAGE=$bgout VERBOSE=0 HISTAT=0
my $meanbg = ($_FIND_IMAGE_STATISTICS_{RESULTS}->{NUMGOOD})
  ? $_FIND_IMAGE_STATISTICS_{RESULTS}->{MEAN} : 0.0;

orac_warn "Unable to determine background level: integrated intensity may be over/underestimated\n" unless $meanbg;

# This is mean value per pixel, so reduce maxflux and sum accordingly
$maxflux -= $meanbg;
$sum -= ($meanbg * $ngood);

if ( $ORAC_STATUS == ORAC__OK ) {
  # Retrieve pixel scale in arcsec so totalflux is returned as a flux
  # with units of signal*arcsec^2
  _GET_PIXEL_SCALE_ IMAGE=$out VERBOSE=0
  my $pixarea = $_GET_PIXEL_SCALE_{AREA};

  # Store sum in the hash
  $_PRIM_ARGS_->{TOTALFLUX} = $sum*$pixarea;
  $_PRIM_ARGS_->{SUM} = $sum;
  $_PRIM_ARGS_->{PEAKFLUX} = $maxflux;
  $_PRIM_ARGS_->{SIGMA} = $sigma;
  $_PRIM_ARGS_->{NUMGOOD} = $ngood;
  $_PRIM_ARGS_->{NUMPIX} = $npix;
}
