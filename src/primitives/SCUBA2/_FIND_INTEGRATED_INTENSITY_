#! -*-perl-*-

=head1 NAME

_FIND_INTEGRATED_INTENSITY_ - aperture photometry of image using statistics

=head1 SYNOPSIS

 _FIND_INTEGRATED_INTENSITY_ IMAGE=$image

 _FIND_INTEGRATED_INTENSITY_ IMAGE=$image LOGFILE=0 RADIUS=50

=head1 DESCRIPTION

This primitive calculates the integrated intensity, in whatever units
the image is currently using, around a single (point) source that is
assumed to be the only source on the map (so that the sky contribution
can be calculated). The value is corrected for pixel area. The SKY
domain is used throughout; the coordinate system used is the current
one as obtained from the C<system> WCS attrobute.

The integrated intensity is calculated using the following technique:

=over 4

=item 1

Define radius of aperture (input parameter, or default of 20 arcsec)

=item 2

Mask all data outside the calculated radius centred on the given position.

=item 3

Calculate the sum of all valid pixels.

=back

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item IMAGE

Input image. No default.

=item RADIUS

The radius of the aperture in arcsec. Default is 20 arcsec.

=item XYPOS

An array reference containing the formatted X, Y coordinates in the
chosen frame. No default.

=item LOGFILE

A flag to indicate whether a log file should be written containing the
results of the integrated intensity calculation. Default is true.

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is true.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

C<ardmask>, C<stats>, C<histat>

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_FIND_INTEGRATED_INTENSITY_>
contains the following keys:

=over 4

=item SUM

The sum of all the pixels within the aperture.

=item TOTALFLUX

The total flux within the aperture in units of
signal_units*pixel_units^2.

=item PEAKFLUX

The peak intensity in the aperture

=item SIGMA

The standard deviation in the image

=item NUMGOOD

The number of pixels which contribute to the estimate of the flux

=item NUMPIX

The total number of pixels in the image

=back

The frame object is not updated.

=head1 NOTES

It may be desireable to allow different domains to be used.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>,
Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005-2007 Particle Physics and Astronomy Research
Council and University of British Columbia.  All Rights Reserved.

=cut

# Set the input file name
my $in = (exists $_FIND_INTEGRATED_INTENSITY_{IMAGE} &&
	  defined $_FIND_INTEGRATED_INTENSITY_{IMAGE}) 
          ? $_FIND_INTEGRATED_INTENSITY_{IMAGE} : undef;

unless ( defined ($in) ) {
  orac_throw "Error: _FIND_INTEGRATED_INTENSITY_ must be supplied with an image\n";
}

# Write logfile (default to true)
my $uselog = ( exists $_FIND_INTEGRATED_INTENSITY_{LOGFILE} && 
	       defined $_FIND_INTEGRATED_INTENSITY_{LOGFILE} ) ?
               $_FIND_INTEGRATED_INTENSITY_{LOGFILE} : 1;

# Should I be verbose (default to yes)
my $verbose = ( exists $_FIND_INTEGRATED_INTENSITY_{VERBOSE} && 
		defined $_FIND_INTEGRATED_INTENSITY_{VERBOSE} ) ?
                $_FIND_INTEGRATED_INTENSITY_{VERBOSE} : 1;

# Define X and Y positions
my ($x, $y);
if ( exists $_FIND_INTEGRATED_INTENSITY_{XYPOS} && 
     defined $_FIND_INTEGRATED_INTENSITY_{XYPOS} && 
     ref($_FIND_INTEGRATED_INTENSITY_{XYPOS}) eq "ARRAY" ) {
  ($x, $y) = @{ $_FIND_INTEGRATED_INTENSITY_{XYPOS} };
} else {
  orac_throw "Error: must provide an array reference with X, Y position of source\n";
}

# Set radius of mask - default is 20 arcsec
my $radius = $_FIND_INTEGRATED_INTENSITY_{RADIUS} || 20.0;

# Initialize entries in primitive hash
foreach my $item (qw/ PEAKFLUX TOTALFLUX SUM SIGMA NUMGOOD NUMPIX /) {
  $_FIND_INTEGRATED_INTENSITY_{$item} = undef;
}

# Create the temporary file for the ard description
my $ard = new ORAC::TempFile;

my $ORAC_STATUS;
# Get current coordinate system
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=system");
($ORAC_STATUS, my $cosys) = $Mon{ndfpack_mon}->get("wcsattrib","value");
# Convert string to upper case
$cosys = uc($cosys);

# Write the ard description
# In kappa 18 we need to add a COFRAME - we are using arcseconds
if (starversion_gt('kappa','V0.18-0')) {
  print {$ard->handle} "COFRAME(SKY,System=$cosys)\n";
}

# Mask out everything EXCEPT a circle centred on X, Y. Radius has to
# be specified correctly in current coordinate system.
# If AzEl or Galactic, convert to degrees
if ( $cosys eq "AZEL" || $cosys eq "GALACTIC" ) {
  my $dradius = $radius/3600.0;
  print {$ard->handle} ".NOT.CIRCLE($x, $y, $dradius)\n";
} else {
  # All other supported systems are HMS/DMS so need to format
  # correctly
  if ( $radius < 60.0 ) {
    print {$ard->handle} ".NOT.CIRCLE($x, $y, 00:00:$radius)\n";
  } else {
    my $mradius = int( $radius / 60.0 );
    my $sradius = $radius - ($mradius * 60);
    print {$ard->handle} ".NOT.CIRCLE($x, $y, 00:$mradius:$sradius)\n";
  }
}

# Close the file
$ard->handle->close;

# Get temporary output file
my $outobj = new ORAC::TempFile;
my $out = $outobj->file;
my $ardin = $ard->file;

# Arguments for ardmask depend on kappa version
my $ardargs;
if (starversion_lt('kappa','V0.18-0')) {
  $ardargs = "cosys=data";
} else {
  $ardargs = ""; # in the ard file
}

# Run ardmask
$Mon{kappa_mon}->obeyw("ardmask", "in=$in out=$out ardfile=$ardin $ardargs");

# Now calculate stats of the masked file to get the flux in the
# aperture
$Mon{kappa_mon}->obeyw("stats","ndf=$out");

# Get sum and number of valid pixels
($ORAC_STATUS, my $sum) = $Mon{kappa_mon}->get("stats","total");
($ORAC_STATUS, my $maxflux) = $Mon{kappa_mon}->get("stats","maximum");
($ORAC_STATUS, my $ngood) = $Mon{kappa_mon}->get("stats","numgood");
($ORAC_STATUS, my $npix) = $Mon{kappa_mon}->get("stats","numpix");
($ORAC_STATUS, my $sigma) = $Mon{kappa_mon}->get("stats","sigma");

if ($verbose) {
  my $outsum = sprintf "%6.3f", $sum;
  orac_print "Sum calculated to be $outsum UNITS from $npix pixels\n";
}

if ( $ORAC_STATUS == ORAC__OK ) {
  # Retrieve pixel scale so totalflux is returned as a flux with units
  # of signal*arcsec^2
  $Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$out");
  ($ORAC_STATUS, my @dxy) = $Mon{ndfpack_mon}->get("ndftrace","fpixscale");
  my $dx = $dxy[0];
  my $dy = $dxy[1];

  # Store sum in the hash
  $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX} = $sum*$dx*$dy;
  $_FIND_INTEGRATED_INTENSITY_{SUM} = $sum;
  $_FIND_INTEGRATED_INTENSITY_{PEAKFLUX} = $maxflux;
  $_FIND_INTEGRATED_INTENSITY_{SIGMA} = $sigma;
  $_FIND_INTEGRATED_INTENSITY_{NUMGOOD} = $ngood;
  $_FIND_INTEGRATED_INTENSITY_{NUMPIX} = $npix;
}
