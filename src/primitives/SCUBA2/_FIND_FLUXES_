# -*-perl-*-

=head1 NAME

_FIND_FLUXES_ - Determine the peak and integrated flux of sources in image

=head1 DESCRIPTION

Finds the peak and total flux of all sources in an image either by
fitting or aperture photometry.

The total flux can be determined by fitting a Sersic profile to the
source and integrating underneath that profile using a standard
integral solution. If the fit is poor (defined by the axis ratio
falling outside a pre-defined range) then the default aperture
photometry method is used instead.

This primitive is designed to work on a single image and will fail if
the current Frame object contains more than one file.

Important: Data should be calibrated in Jy/beam before calling this
primitive so that meaningful values are logged.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item B<USEPSF>

A flag to indicate whether to calculate the source flux from either a
fit the source using the Kappa PSF function or using an aperture
photometry method. Default is to use aperture photometry (USEPSF = 0).

=item B<RADIUS>

Radius of apertures to use for aperture photometry (if USEPSF is 0)
and/or noise estimates. Default is 20 arcsec. A special value of -1
may be specified in which case the aperture is set by the major and
minor axes of the object.

=item B<LOGFILE>

A flag to indicate whether log files should be written containing the
results of the flux and noise calculations. Default is true.

=item B<GROUP>

If true, use the current Group file as input, otherwise use the
current Frame. Default is 0 (false: use current Frame).

=item B<VERBOSE>

Flag to indicate whether informational messages should be 
given to the user. Default is true.

=back

=head1 EXTERNAL TASKS

=over 4

=item KAPPA

PSF, WCSFRAME

=item Other SCUBA-2 primitives

_FIT_PSF_, _FIND_INTEGRATED_INTENSITY_, _FIND_SOURCES_

=back

=head1 OUTPUT DATA

The primitive hash returns no keys if the user specifies writing the
results to a logfile. If no logfile is to be written then the
following keys are set:

=over 4

=item INTFLUX

Reference to array of integrated fluxes. Undef if no sources found.

=item PEAKFLUX

Reference to array of peak fluxes. Undef if no sources found.

=back

=head1 OUTPUT FILES

The following files are created:

=over 4

=item C<log.peak>

Log of peak flux values.

=item C<log.integrated>

Log of integrated flux values.

=back

The frame object is not updated.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2007-2008 the University of British Columbia.  All
Rights Reserved.

=cut

# Should check that this has been run after calibration?

# Write logfiles (default to yes)
my $uselog = get_prim_arg($_PRIM_ARGS_, "LOGFILE", 1);

# Should I be verbose? (Default to yes)
my $verbose = get_prim_arg($_PRIM_ARGS_, "VERBOSE", 1);

# Check the desired flux calculation method.
my $usepsf = get_prim_arg($_PRIM_ARGS_, "USEPSF", 0);

# Set aperture radius - default is 20 arcsec
my $radius = get_prim_arg($_PRIM_ARGS_, "RADIUS", 20);

# Initialize the log files if necessary
my ($pklog, $intlog);

# Determine if the user wants to use the current Grp or Frm image
my $group = get_prim_arg($_PRIM_ARGS_, "GROUP", 0);
my ($Obj, $in);
if( $group ) {
  $Obj = $Grp;
} else {
  $Obj = $Frm;
}
if ( $Obj->nfiles == 1 ) {
  $in = $Obj->file;
} else {
  orac_throw "Error: _FIND_FLUXES_ must be run after images have been combined\n";
}

# What if the Group file does not exist yet?
if ( $group  && $Grp->file_exists ) {

my (@intfluxes, @pkfluxes);

# Are the data calibrated?

# If we are observing a standard source then just find the centroid.

# Find all of the sources in the current frame
_FIND_SOURCES_ IMAGE=$in
# Retrieve catalogue
my $catalogue = $_FIND_SOURCES_{CATALOGUE};

# Extractor does not understand offset coordinate systems, so we must
# check and ensure we are working in an absolute system. In practice,
# this means setting SkyRefIs = Ignored, AlignOffset = 0 and System =
# ICRS. These attributes are reset on successful exit
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=system");
my ($ORAC_STATUS, $cosys_in) = $Mon{ndfpack_mon}->get("wcsattrib","value");
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=get name=skyrefis");
($ORAC_STATUS, my $skyrefis) = $Mon{ndfpack_mon}->get("wcsattrib","value");
my $offset = ( lc($skyrefis) eq "origin" ) ? 1 : 0;
if ( $offset ) {
  $Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$in mode=mset setting='system=icrs,skyrefis=ignored,alignoffset=0'");
}

# Check that the catalogue has sources in it
if ( $catalogue->sizeof == 0 ) {
  # Issue an error and skip the rest
  orac_warn "Unable to determine fluxes, no sources found\n";
} else {
  # Check if installed version of Kappa has a PSF task we can use
  if ( $usepsf && starversion_lt('kappa', 'V0.15-0')) {
    # warn
    orac_warn "Your kappa version is too old to use PSF. Using stats to find total flux\n";
    $usepsf = 0;
  }

  my $fluxcorr = 1.0;
  my $ORAC_STATUS;

  if ($usepsf) {
    orac_print "Calculating fluxes by fitting a PSF\n" if $verbose;
  } else {
    orac_print "Calculating fluxes by aperture photometry\n" if $verbose;
  }
  # Define all the parameters we might need
  my ($amp, $fwhm, $axisr, $totalflux);

  # Set up log file entries - these will be the same for all sources in the field
  if ($uselog) {
    my $time = gmtime();
    # Peak fluxes
    $pklog = new ORAC::LogFile("log.peak");
    $pklog->header("#Peak flux log file - created on $time UT",
		   "#\n# UT                HST   Obs Source       Mode         Filter  El CSO    Tau  Seeing ID    RA          Dec       Peak       FWHM",
		   "#---------------------------------------------------------------------------------------------------------------------------------------");
    # Integrated fluxes
    $intlog = new ORAC::LogFile("log.integrated");
    $intlog->header("#Integrated flux log file - created on $time UT",
		    "#\n# UT                HST   Obs Source       Mode         Filter El CSO    Tau  Seeing ID    RA          Dec       Flux",
		    "#---------------------------------------------------------------------------------------------------------------------------");
  }
  # Retrieve logging parameters anyway
  _GET_LOG_PARAMETERS_ GROUP=$group
  my ( $uttime, $hst, $obsnum, $src, $mode, $filter, $el, $cso, $tau, $see ) 
    = @{ $_GET_LOG_PARAMETERS_{PARAMS} };

  # Loop over all sources in the catalogue and run desired
  # flux-calculation method
  for my $i ( 1 .. $catalogue->sizeof ) {
    my $source = $catalogue->starbyindex( $i - 1 ); # Catalogue is 0-indexed
    # Retrieve Astro::Coords object associated with current source
    my $coords = $source->coords;
    my $ra = $coords->ra;
    my $dec = $coords->dec;

    if ( $usepsf ) {
      # Write position to COFILE
      my $cofile = new ORAC::TempFile;
      print { $cofile->handle } $ra." ".$dec. "\n";
      $cofile->handle->close;
      # Fit the source
      _FIT_PSF_ IMAGE=$in COFILE=$cofile->file VERBOSE=0
      $amp = $_FIT_PSF_{AMPLITUDE};
      $fwhm = $_FIT_PSF_{FWHM};
      $axisr = $_FIT_PSF_{AXISR};
      $totalflux = $_FIT_PSF_{TOTALFLUX};
      undef $cofile;
      # Calculate geometric mean FWHM for logging
      $fwhm *= sqrt($axisr);
    } else {
      # Use an aperture photometry method
      my @xy = ( $ra, $dec );
      _FIND_INTEGRATED_INTENSITY_ RADIUS=$radius IMAGE=$in XYPOS=\@xy
      $totalflux = $_FIND_INTEGRATED_INTENSITY_{TOTALFLUX};
      $amp = $_FIND_INTEGRATED_INTENSITY_{PEAKFLUX};
      $fwhm = $Cal->fwhm;
    }

    # Convert flux to meaningful units
    $totalflux /= $fluxcorr;

    # Write info to log file if requested
    if ( $uselog ) {
      # Format for printing
      $totalflux = sprintf "%6.3f", $totalflux;
      $amp = sprintf "%6.3f", $amp;
      # Set source ID - assumes there will be <100 objects in image
      my $srcnum = sprintf "%02d", $i;

      $fwhm = sprintf "%6.2f", $fwhm;

      # Write the entry:
      $pklog->addentry( "$uttime $hst $obsnum $src $mode   $filter   $el $cso $tau $see  $srcnum $ra $dec  $amp  $fwhm");
      $intlog->addentry("$uttime $hst $obsnum $src $mode   $filter   $el $cso $tau $see  $srcnum $ra $dec  $totalflux");
    } else {
      push (@intfluxes, $totalflux);
      push (@pkfluxes, $amp);
    }
  }
}

# Reset WCS to input
if ( $offset ) {
  my $args = "ndf=$in mode=mset setting='system=".$cosys_in.",skyrefis=origin,alignoffset=1'";
  $Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
}

unless ($uselog) {
  $_FIND_FLUXES_{INTFLUX} = ($catalogue->sizeof) ? \@intfluxes : undef;
  $_FIND_FLUXES_{PEAKFLUX} = ($catalogue->sizeof) ? \@pkfluxes : undef;
}

}
