#! -*-perl-*-

=head1 NAME

_CREATE_REFERENCE_IMAGE_ - Create a 1x1 NDF aligned to a chosen Sky frame

=head1 SYNOPSIS

 _CREATE_REFERENCE_IMAGE SYSTEM=EQUATORIAL

=head1 DESCRIPTION

This primitive creates a 1x1 pixel NDF image to be used in aligning
and mosaicking individual DREAM/STARE images. The user has the option
of specifying the desired SKY frame. If none is specified then FK5
equatorial coordinates with a mean equinox J2000.0 is assumed.

The reference position and pixel scale is determined from the most
recent image added to the current Frame

This primitive is called only if a suitable reference image does not
already exist.

=head1 ARGUMENTS

=over 4

=item SYSTEM

The name of the sky coordinate system for the reference image. May be
ICRS, FK5, EQUATORIAL, GAPPT or GALACTIC. Note: AZEL is not supported.

Default is to use the same as the input.

=item PIXEL_SCALE

The pixel scale for the reference image, in arcsec. It may also take
the special value 0 to indicate that the pixel scale should be derived
from the input image instead. If a value is given, the X and Y scales
are set equal. Leave unset to use the internal default values (3.09
arcsec at 450 um, 5.8 arcsec at 850 um).

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is true.

=back

=head1 MOVING SOURCES

Creating a reference image for a moving source is more complex,
especially as SETSKY is not aware of the GAPPT coordinate system. The
procedure is as follows. If the input data have system=GAPPT and/or
the output system is GAPPT then the reference image is created with
system=GAPPT.

=over 4

=item Step 1 

Retrieve and store System and Epoch from input data file

=item Step 2

Create template reference image

=item Step 3 

Set system on input data file to ICRS, retrieve and store SkyRef (now
in ICRS coordinates)

=item Step 4 

Use SETSKY to add an ICRS SkyFrame to the reference image using
equinox = 2000, the input epoch and SkyRef in ICRS coordinates

=item Step 5

Set the system for the reference image to GAPPT - SkyRef is now in
GAPPT coordinates

=back

=head1 OUTPUT DATA

On completion the primitive hash C<%_CREATE_REFERENCE_IMAGE_> contains
the following key"

=over 4

=item REFIMAGE

Name of reference image, also stored in the $Cal object

=back

=head1 KNOWN ISSUES

Only EQUATORIAL (in its FK5 and ICRS guises), GAPPT and GALACTIC
coordinate systems are supported.

=head1 ALGORITHMS

Uses KAPPA CREFRAME, SETSKY and WCSATTRIB.

=head1

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005-2007 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# Check for arguments...
# Should I be verbose? (default to yes)
my $verbose = (exists $_CREATE_REFERENCE_IMAGE_{VERBOSE} && 
	       defined $_CREATE_REFERENCE_IMAGE_{VERBOSE}) ?
	       $_CREATE_REFERENCE_IMAGE_{VERBOSE} : 1;

# Check for desired OUTPUT coordinate frame
my $cosys_out = (exists $_CREATE_REFERENCE_IMAGE_{SYSTEM} &&
		  defined $_CREATE_REFERENCE_IMAGE_{SYSTEM}) ?
                  uc($_CREATE_REFERENCE_IMAGE_{SYSTEM}) : "";

# Tell the user what's going on
orac_print "Creating reference image: " if $verbose;

# Create the blank 3x3 pixel reference NDF
my $refimage = $Grp->raw."_ref";
my $imgargs = "lbound=\[1,1\] ubound=\[3,3\] mode=bl title=".$Frm->hdr('OBJECT');
$Mon{kappa_mon}->obeyw("creframe","out=$refimage ".$imgargs);
orac_print "create blank NDF, " if $verbose;

# Get first file in current Frame for WCS and FITS header info
my $datafile = $Frm->file(1);

# Calculate the pixel scale. Use default values if not set.
my $pixelscale = (exists $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE} &&
		  defined $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE}) ?
                  $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE} : $Cal->pixelscale;

# These should not be zero after this block...
my ($dx, $dy) = (0.0, 0.0);
if ( $pixelscale == 0 ) {
  _GET_PIXEL_SCALE_ IMAGE=$datafile DERIVE=0 UNITS=ARCSEC
  # Retrieve values in arcsec
  ($dx, $dy) = @{ $_GET_PIXEL_SCALE_{RESULTS}};
} else {
  # If we're not getting the pixel scale from the image, use the value
  # given and set the X and Y scales equal.
  $dx = $pixelscale;
  $dy = $dx;
}
# Check they're non-zero
if ( $dx == 0.0 || $dy == 0.0 ) {
  orac_err "Pixel scales still set to zero - something went very wrong\n";
}

# We may not have write access to the input frame so we
# have to force a SKY frame. This is important in QL mode
# where the data do not have a .WCS component. We can either
# modify read_wcs to parse FITS headers if the WCS does not
# contain a sky, or else copy the file, run wcsframe and then
# call read_wcs. This only happens for the first file so we can
# copy without slowing things down much

my $tmp = ORAC::TempFile->new(0);
my $tmpfile = $tmp->file;
$Mon{ndfpack_mon}->obeyw("ndfcopy","in=$datafile out=$tmpfile");

# Retrieve input WCS object - force creation of a sky frame to make
# sure the read_wcs call does not fail
$Mon{ndfpack_mon}->obeyw("wcsframe","ndf=$tmpfile frame=sky");
my $wcs = $Frm->read_wcs( $tmpfile );

# Get current INPUT coordinate system
my $cosys_in = $wcs->Get("System");

# Check that the OUTPUT coordinate system supported - use INPUT if not
# recognized
if ( $cosys_out eq "" ) {
  # Use same as input if not set
  $cosys_out = $cosys_in;
} elsif ( ( $cosys_out ne "ICRS" ) && ( $cosys_out ne "GAPPT" ) 
     && ( $cosys_out ne "EQUATORIAL" ) && ( $cosys_out ne "GALACTIC" )
     && ( $cosys_out ne "FK5" ) && ( $cosys_out ne "FK4" ) ) {
  orac_warn " Unsupported coordinate frame, $cosys_out. Using default (ICRS)\n";
  $cosys_out = $cosys_in;
}

# If we are dealing with a moving source, set the input coordinate
# system to ICRS for creating the output WCS
my $usesys = $cosys_in;
if ( $cosys_in eq "GAPPT" ) {
  $wcs->Set("System=ICRS");
  $usesys = "ICRS";
}

# Get coords of reference pixel in current SKY coordinate system
my $skyref = $wcs->Get("SkyRef");
my ($xstr, $ystr) = split(/,/,$skyref,2);

# Get equinox
my $equinox = $wcs->Get("Equinox");

# Epoch - for GAPPT output retrieve from input data
my $epoch;
if ( $cosys_out eq "GAPPT" ) {
  $epoch = $wcs->Get("Epoch");
} else {
  # Else use equinox before redefining the equinox as a string
  $epoch = $equinox;
}

# Reformat equinox as suitable string for future use
if ( $equinox eq "2000.0" ) {
  $equinox = "J2000";
} elsif ( $equinox eq "1950.0" ) {
  $equinox = "B1950";
}

my ($x0, $y0);
# Create Astro::Coords object using information from sky frame in
# input data and then retrieve parameters in desired output frame.
use Astro::Coords;
my $coords; 
if ( $cosys_in eq "GALACTIC" ) {
  $coords = new Astro::Coords( long => $xstr, lat => $ystr,
			       units => 'deg', type => 'galactic' );
} else {
  $coords = new Astro::Coords( ra => $xstr, dec => $ystr, 
			       units => 'sex', type => $equinox );
}

# Now retrieve reference coordinates in desired output frame
my $skycosys;
if ( $cosys_out eq "GALACTIC" ) {
  # Retrieve coords in degrees: SETSKY uses degrees by default
  $x0 = $coords->glong( format => 'deg' );
  $y0 = $coords->glat( format => 'deg' );
  $skycosys = $cosys_out;
} else {
  # Retrieve coords in radians
  $x0 = $coords->ra( format => 'rad' );
  $y0 = $coords->dec( format => 'rad' );

  # Convert to string and add units for SETSKY
  $x0 = $x0."r";
  $y0 = $y0."r";

  # Re-define output coordinate frame to be generically equatorial for
  # SETSKY but with appropriate equinox
  $skycosys = "EQUATORIAL($equinox)";
}

# Add a WCS sky frame - forces pixel scale to match raw input data
orac_print "adding WCS " if $verbose;

# Define parameters of WCS. Pixelsize is in ARCSEC, lat and lon are as
# defined above.
# Note quoting around the pixelsize arguments
my $wcsargs = "coords=$skycosys epoch=$epoch refcode=pixel pixelref=\[1.5,1.5\] pixelsize=\['".$dx."s', '".$dy."s'\] orient=0 positions=! projtype=gnom lon=".$x0." lat=".$y0;
$Mon{ndfpack_mon}->obeyw("setsky","ndf=$refimage $wcsargs");

# Now add a FITS header, copy from the first file in the Frm.
use Astro::FITS::Header::NDF;
my $fitshdr = new Astro::FITS::Header::NDF( File => $datafile );
$fitshdr->writehdr( File => $refimage );

# Store the SkyRef attribute in reference image
# SkyRef can not be stored using mset since astSet does not allow
# attribute values that include commas.
my $args = "ndf=$refimage mode=set name=skyref newval='".$skyref."'";
$Mon{ndfpack_mon}->obeyw("wcsattrib","$args");

# Need to set the Observatory location
my $obslon = $wcs->Get("ObsLon");
my $obslat = $wcs->Get("ObsLat");

# Work out which AST attributes need to be set
my $attrs = "obslon=$obslon,obslat=$obslat";

# If necessary, set the SkyRefIs, AlignOffset and System attributes
if ( $cosys_out eq "GAPPT" ) {
  $attrs .=",skyrefis=origin,alignoffset=1,system=GAPPT,epoch=$epoch";
  # Set a flag for moving sources
  $Grp->uhdr("MOVING",1);
} else {
  # Set a NULL flag for non-moving sources
  $Grp->uhdr("MOVING",0);
}

# Now set the attributes
$Mon{ndfpack_mon}->obeyw("wcsattrib","ndf=$refimage mode=mset setting='$attrs'");

# Store the reference image name in the primitive hash
$_CREATE_REFERENCE_IMAGE_{REFIMAGE} = $refimage;

# Store name of created reference image in Grp uhdr. Note this is not
# done for FOCUS observbations because it messes up the FITS headers
# when creating the cube for analysis.
unless ( $Frm->uhdr("ORAC_OBSERVATION_TYPE") eq "FOCUS" ) {
  $Grp->uhdr("REFIMAGE", $refimage);
}

# Create HISTORY component
$Mon{ndfpack_mon}->obeyw("hisset","ndf=$refimage mode=normal");

# All done - let the user know
$pixelscale = sprintf "%5.2f", $pixelscale;
orac_print "done. \nReference image created in $cosys_out coordinate system with pixel scale = $pixelscale arcsec\n" if $verbose;

