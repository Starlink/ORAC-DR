#! -*-perl-*-

=head1 NAME

_CREATE_REFERENCE_IMAGE_ - Create a 1x1 NDF aligned to a chosen Sky frame

=head1 SYNOPSIS

 _CREATE_REFERENCE_IMAGE FRAME=EQUATORIAL

=head1 DESCRIPTION

This primitive creates a 1x1 pixel NDF image to be used in aligning
and mosaicking individual DREAM/STARE images. The user has the option
of specifying the desired SKY frame. If none is specified then FK5
equatorial coordinates with a mean equinox J2000.0 is assumed.

The reference position and pixel scale is determined from the most
recent image added to the current Frame

This primitive is called only if a suitable reference image does not
already exist.

=head1 ARGUMENTS

=over 4

=item FRAME

The name of the chosen sky frame for the reference image. May be any
that AST knows about, i.e. ICRS, FK4, FK5, EQUATORIAL, GAPPT or
GALACTIC.

Default is ICRS (same as EQUATORIAL or FK5).

=item PIXEL_SCALE

The pixel scale for the reference image, in arcsec. It may also take
the special value 0 to indicate that the pixel scale should be derived
from the input image instead. If a value is given, the X and Y scales
are set equal. Leave unset to use the internal default values (3.09
arcsec at 450 um, 5.8 arcsec at 850 um).

=item VERBOSE

Flag to indicate whether informational messages should be given to the
user. Default is true.

=back

=head1 KNOWN ISSUES

Only ICRS (in its FK5, FK4 and EQUATORIAL guises), GAPPT and GALACTIC
coordinate systems are supported. Support for GAPPT needs to be more
thoroughly tested.

=head1 ALGORITHMS

Uses KAPPA CREFRAME, SETSKY and WCSATTRIB.

=head1

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2005-2007 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA

=cut

# Check for arguments...
# Should I be verbose? (default to yes)
my $verbose = (exists $_CREATE_REFERENCE_IMAGE_{VERBOSE} && 
	       defined $_CREATE_REFERENCE_IMAGE_{VERBOSE}) ?
	       $_CREATE_REFERENCE_IMAGE_{VERBOSE} : 1;

# Check for desired output coordinate frame
my $coordframe = (exists $_CREATE_REFERENCE_IMAGE_{FRAME} &&
		  defined $_CREATE_REFERENCE_IMAGE_{FRAME}) ?
                  uc($_CREATE_REFERENCE_IMAGE_{FRAME}) : "ICRS";

# Check that it's supported - continue using ICRS if not recognized
if ( $coordframe ne "ICRS" && $coordframe ne "GAPPT" && $coordframe ne "EQUATORIAL"
     && $coordframe ne "GALACTIC" && $coordframe ne "FK5" && $coordframe ne "FK4") {
  orac_warn "Warning: unsupported coordinate frame, $coordframe. Using default (ICRS)\n";
  $coordframe = "ICRS";
}

# Tell the user what's going on
orac_print "Creating reference image: " if $verbose;

# Create the blank 3x3 pixel reference NDF
my $refimage = $Frm->group."_ref";
my $imgargs = "lbound=\[1,1\] ubound=\[3,3\] mode=bl";
$Mon{kappa_mon}->obeyw("creframe","out=$refimage title=RefImage ".$imgargs);
orac_print "create blank NDF, " if $verbose;

# Get first file in current Frame for WCS and FITS header info
my $datafile = $Frm->file( 1);

# Calculate the pixel scale. Use default values if not set.
my $pixelscale = (exists $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE} &&
		  defined $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE}) ?
                  $_CREATE_REFERENCE_IMAGE_{PIXEL_SCALE} : 
                  ( ($Frm->hdr('FILTER') =~ /450/) ? 3.09 : 5.8) ;

my ($dx, $dy) = (0.0, 0.0); # These should not be zero after this block...
if ( $pixelscale == 0 ) {
  _GET_PIXEL_SCALE_ IMAGE=$datafile DERIVE=0 UNITS=ARCSEC
  # Retrieve values in arcsec
  ($dx, $dy) = @{ $_GET_PIXEL_SCALE_{RESULTS}};
} else {
  # If we're not getting the pixel scale from the image, use the value
  # given and set the X and Y scales equal.
  $dx = $pixelscale;
  $dy = $dx;
}
# Check they're non-zero
if ( $dx == 0.0 || $dy == 0.0 ) {
  orac_err "Pixel scales still set to zero - something went very wrong\n";
}

# Get coords of reference pixel in current SKY coordinate system
my $args = "ndf=$datafile mode=get name=skyref";
$Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
my ($ORAC_STATUS, $skyref) = $Mon{ndfpack_mon}->get("wcsattrib","value");
my ($xstr, $ystr) = split(/,/,$skyref,2);

# Get current coordinate system
$args = "ndf=$datafile mode=get name=system";
$Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
($ORAC_STATUS, my $cosys) = $Mon{ndfpack_mon}->get("wcsattrib","value");

# Get equinox
$args = "ndf=$datafile mode=get name=equinox";
$Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
($ORAC_STATUS, my $equinox) = $Mon{ndfpack_mon}->get("wcsattrib","value");

# Epoch - for GAPPT retrieve from input data
my $epoch;
if ( $cosys eq "GAPPT" ) {
  $args = "ndf=$datafile mode=get name=epoch";
  $Mon{ndfpack_mon}->obeyw("wcsattrib","$args");
  ($ORAC_STATUS, $epoch) = $Mon{ndfpack_mon}->get("wcsattrib","value");
} else {
  # Else use equinox before redefining the equinox as a string
  $epoch = $equinox;
}

# Reformat equinox as suitable string for future use
if ( $equinox eq "2000.0" ) {
  $equinox = "J2000";
} elsif ( $equinox eq "1950.0" ) {
  $equinox = "B1950";
}

my ($x0, $y0);
# Create Astro::Coords object using information from sky frame in
# input data and then retrieve parameters in desired output frame.
use Astro::Coords;
my $coords; 
if ( $cosys eq "GALACTIC" ) {
  $coords = new Astro::Coords( long => $xstr, lat => $ystr,
			       units => 'deg', type => 'galactic' );
} else {
  $coords = new Astro::Coords( ra => $xstr, dec => $ystr, 
			       units => 'sex', type => $equinox );
}

# Now retrieve reference coordinates in desired output frame
if ( $coordframe eq "GALACTIC" ) {
  # Retrieve coords in degrees: SETSKY uses degrees by default
  $x0 = $coords->glong( format => 'deg' );
  $y0 = $coords->glat( format => 'deg' );
} elsif ( $coordframe eq "GAPPT" ) {
  # THIS NEEDS TO BE TESTED... Need to check:
  # 1) Is the epoch a UTC time or TAI?
  # 2) What needs to be specified for SETSKY?

  # Create a DateTime object and register with Astro::Coords object
  use DateTime;
  my $date = DateTime->from_epoch( epoch => $epoch, time_zone => 'UTC' );
  $coords->datetime( $date );
  $x0 = $coords->ra_app( format => 'rad' );
  $y0 = $coords->dec_app( format => 'rad' );
  # Convert to string and add units for SETSKY
  $x0 = $x0."r";
  $y0 = $y0."r";

  # Re-define cosys to be generically equatorial for SETSKY
  $coordframe = "EQUATORIAL";
} else {
  # Retrieve coords in radians
  $x0 = $coords->ra( format => 'rad' );
  $y0 = $coords->dec( format => 'rad' );

  # Convert to string and add units for SETSKY
  $x0 = $x0."r";
  $y0 = $y0."r";

  # Re-define cosys to be generically equatorial for SETSKY
  $coordframe = "EQUATORIAL($equinox)";
}

# Add a WCS sky frame - forces pixel scale to match raw input data
orac_print "adding WCS " if $verbose;

# Define parameters of WCS. Pixelsize is in ARCSEC, lat and lon are as
# defined above.
# Note quoting around the pixelsize arguments
my $wcsargs = "coords=$coordframe epoch=$epoch refcode=pixel pixelref=\[1.5,1.5\] pixelsize=\['".$dx."s', '".$dy."s'\] orient=0 positions=! projtype=gnom lon=".$x0." lat=".$y0;
$Mon{ndfpack_mon}->obeyw("setsky","ndf=$refimage $wcsargs");

# Now add a FITS header, copy from the first file in the Frm.
use Astro::FITS::Header::NDF;
my $fitshdr = new Astro::FITS::Header::NDF( File => $datafile );
$fitshdr->writehdr( File => $refimage );

# Store the reference image name in the RESULTS hash
$_CREATE_REFERENCE_IMAGE_{RESULTS} = $refimage;

orac_print "done. Successfully created reference image.\n" if $verbose;
