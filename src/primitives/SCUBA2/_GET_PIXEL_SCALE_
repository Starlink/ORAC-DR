# -*-perl-*-

=head1 NAME

_GET_PIXEL_SCALE_ - Determine the pixel scale for a given image

=head1 DESCRIPTION

_GET_PIXEL_SCALE_ determines the pixel scale for a given image by
examining the information in the WCS extension. The calculation is
carried out by defining triplets of PIXEL positions in the image,
converting these into positions in the desired output frame (e.g. SKY)
and then using astDistance to compute the distance in radians between
the positions in the x- and y-directions respectively. Since field
distortion will change the scale across the image, the average of the
four corners plus the mid-point is returned.

Returns an error if desired frame is not in the frameset; currently
this means that if there is no SKY frame the primitive aborts.

=head1 ARGUMENTS

The following arguments are supported:

=over 4

=item IMAGE

Name of image. No default.

=item DOMAIN

Desired domain for output values. Default is SKY. (Currently SKY is
the B<only> supported domain.)

=item UNITS

Units for returned pixel scale. Valid units are radians, arcsec,
arcmin or degrees. Default is arcsec.

=item VERBOSE

Flag to indicate whether informational messages should be 
given to the user. Default is true.

=back

=head1 EXTERNAL TASKS

=over 4

=item AST and NDF

=back

=head1 OUTPUT DATA

On completion, the primitive hash C<%_GET_PIXEL_SCALE_>
contains the following keys:

=over 4

=item RESULTS

Array reference with pixel scales in the X and Y directions in the
requested units.

=back

=head1 KNOWN ISSUES

The checking for the presence of the SKY frame is not very
sophisticated, and only relies on seeing if a variable is left unset.

Output frames other than SKY are not yet supported.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

Copyright (C) 2005-2007 the University of British Columbia.  All
Rights Reserved.

=cut

# Load AST & NDF modules
use Starlink::AST;
use NDF;

# Determine that we have an image as an argument...
unless (exists $_GET_PIXEL_SCALE_{IMAGE} && defined $_GET_PIXEL_SCALE_{IMAGE}) {
  orac_throw "Error: _GET_PIXEL_SCALE_ requires a file as input \n";
}

# Set the input file
my $in = $_GET_PIXEL_SCALE_{IMAGE};

# Should I be verbose? (default to yes)
my $verbose = (exists $_GET_PIXEL_SCALE_{VERBOSE} && 
	       defined $_GET_PIXEL_SCALE_{VERBOSE}) ?
	       $_GET_PIXEL_SCALE_{VERBOSE} : 1;

# Values will be returned in these units:
my $units = (exists $_GET_PIXEL_SCALE_{UNITS} && 
	     defined $_GET_PIXEL_SCALE_{UNITS}) ?
             $_GET_PIXEL_SCALE_{UNITS} : "arcsec";

my $unitconv;
if ( $units eq "arcsec" ) {
  $unitconv = 206264.806;
} elsif ( $units eq "arcmin" ) {
  $unitconv = 3437.74677;
} elsif ( $units =~ "deg" ) {
  $unitconv = 57.2957795;
} elsif ( $units =~ "rad" ) {
  $unitconv = 1.0;
} else {
  orac_warn "_GET_PIXEL_SCALE_: Unknown output units, $units - assuming arcsec\n";
  $unitconv = 206264.806;
}

# initialise the results array
$_GET_PIXEL_SCALE_{RESULTS} = [];

my $indomain = "PIXEL";
# Check the desired output frame - default is SKY
my $outdomain = (exists $_GET_PIXEL_SCALE_{DOMAIN} &&
		 defined $_GET_PIXEL_SCALE_{DOMAIN}) ?
                 uc($_GET_PIXEL_SCALE_{DOMAIN}) : "SKY";

# For now only sky domains are supported. Shouldn't be too much of a
# problem as I can't see anyone wanting any of the intermediate
# domains.
unless ($outdomain =~ /SKY/) {
  orac_throw "Sorry requested domain $outdomain is not yet supported \n";
}

# Create FrameSet from the WCS info in the input file
my $STATUS = 0;
ndf_begin();
ndf_find( &NDF::DAT__ROOT(), $in, my $indf, $STATUS );

my $frameset = ndfGtwcs( $indf, $STATUS );
ndf_annul( $indf, $STATUS );
ndf_end( $STATUS );

# Frame numbers corresponding to the given in/out domain names
my $indom;
my $outdom = -1;
# Number of Frames in the FrameSet
my $nframes = $frameset->Get( 'Nframe' );

# Loop over the number of domains in the FrameSet to set the Frame
# number for the specified domain
for my $i (1 .. $nframes) {
  my $tmp_frame = $frameset->GetFrame( $i );
  my $domain = $tmp_frame->Get( 'Domain' );
  $indom = $i if ($domain eq $indomain);
  $outdom = $i if ($domain eq $outdomain);
}

# Check that the SKY domain exists - not fancy as it only
# checks whether $outdom is unset
orac_throw "Error: Image has no SKY domain \n" if ($outdom == -1);

# Retrieve the output SkyFrame
my $outframe = $frameset->GetFrame( $outdom );

# Retrieve mapping between PIXEL and SKY domains
my $mapping = $frameset->GetMapping( $indom, $outdom );

# Get PIXEL bounds for image
$Mon{ndfpack_mon}->obeyw("ndftrace","ndf=$in");
my $ORAC_STATUS;
($ORAC_STATUS, my $xmin, my $ymin) = $Mon{ndfpack_mon}->get("ndftrace","lbound");
($ORAC_STATUS, my $xmax, my $ymax) = $Mon{ndfpack_mon}->get("ndftrace","ubound");

# Loop over 5 positions to calculate X and Y scale and calculate average
my (@xpixels, @ypixels);
my ($avxscale, $avyscale) = (0.0, 0.0);
for my $posindex (1..5) {
  # Set up arrays of positions to use in pixel coords: four corners
  # plus centre.
  if ( $posindex == 1 ) {
    @xpixels = ($xmin, $xmin, $xmin+1);
    @ypixels = ($ymin, $ymin+1, $ymin);
  } elsif ( $posindex == 2 ) {
    @xpixels = ($xmin, $xmin, $xmin+1);
    @ypixels = ($ymax, $ymax-1, $ymax);
  } elsif ( $posindex == 3 ) {
    @xpixels = ($xmax, $xmax, $xmax-1);
    @ypixels = ($ymax, $ymax-1, $ymax);
  } elsif ( $posindex == 4 ) {
    @xpixels = ($xmax, $xmax, $xmax-1);
    @ypixels = ($ymin, $ymin+1, $ymin);
  } elsif ( $posindex == 5 ) {
    my $xmid = int( $xmax - $xmin );
    my $ymid = int( $ymax - $ymin );
    @xpixels = ($xmid, $xmid+1, $xmid);
    @ypixels = ($ymid, $ymid, $ymid+1);
  }

  # Convert pixel positions into sky positions using the mapping we
  # derived earlier
  (my $xskyref, my $yskyref) = $mapping->Tran2( \@xpixels, \@ypixels, 1);

  # Output positions on the sky
  my @xsky = ($xskyref->[0], $xskyref->[1], $xskyref->[2] );
  my @ysky = ($yskyref->[0], $yskyref->[1], $yskyref->[2] );

  # Use astDistance to calculate the distance on the sky between the positions
  my $pt1 = [ $xsky[0], $ysky[0] ] ;
  my $pt2 = [ $xsky[2], $ysky[2] ] ;
  my $xscale = $outframe->Distance($pt1, $pt2);

  my $pt2 = [ $xsky[1], $ysky[1] ] ;
  my $yscale = $outframe->Distance($pt1, $pt2);

  # Now, xscale and yscale are in radians, and so must be converted to
  # the output units.
  unless ( $unitconv == 1.0 ) {
    $xscale *= $unitconv;
    $yscale *= $unitconv;
  }
  # Add to sum
  $avxscale += $xscale;
  $avyscale += $yscale;
}
# Calculate average value to use
$avxscale /= 5;
$avyscale /= 5;

# Store the result in the hash
$_GET_PIXEL_SCALE_{RESULTS} = [$avxscale, $avyscale];

# If the caller would like access to the mapping then store that too
if ( $_GET_PIXEL_SCALE_{WANTMAP} ) {
  $_GET_PIXEL_SCALE_{MAPPING} = $mapping
}

# Format for pretty printing
if ($verbose) {
  $avxscale = sprintf "%6.2f", $avxscale;
  $avyscale = sprintf "%6.2f", $avyscale;
  orac_print " (X, Y) pixel scale is ($avxscale, $avyscale) $units \n";
  orac_print "Successfully calculated pixel scale for image\n";
}

