=head1 NAME

_MAKE_HIPS_ - Covert a collection of JSA tiles to a HiPS structure

=head1 DESCRIPTION

This primitive rearranges the given HEALPix tiles into the directory
structure used by HiPS, converting them to FITS files with minimal
headers.

The output is written in the directory specified by the C<HIPS_DIR>
recipe parameter.

=head1 BUGS

=over 4

=item *

This primitive is extremely slow due to the amount of I/O performed.

=item *

This primitive assumes that it will be given 1024x1024 tiles (which
it then splits into 512x512 tiles as recommended for HiPS).
This behavior should be controlled via C<_MAKE_HIPS_STEER_> because
it sets up the C<jsadicer> options which control the tiling parameters.

=item *

This primitive uses newly-constructed names for files which will
overwrite any already present with those names.

=back

=head1 COPYRIGHT

Copyright (C) 2019-2024 East Asian Observatory
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,51 Franklin
Street, Fifth Floor, Boston, MA  02110-1301, USA

=cut

use File::Spec;

# Read recpars.
my $root = $RECPARS{'HIPS_DIR'} // "hips-$$";
my $input_jsa_tiles = $RECPARS{'INPUT_JSA_TILES'} // 0;

unless ($input_jsa_tiles) {
    _EXTRACT_JSA_TILES_

    _DELETE_TEMP_FILES_ KEEP=_dice_ RETAINKEPT=1 FORCE=.
}

if ($Grp->lastallmembers($Frm)) {
    # Read steering parameters.
    my $maxorder = $Frm->uhdr('HIPS_MAX_ORDER');


    my $fits_opts = 'comp=D proexts=false prohis=false encoding="FITS-WCS(CD)" axisorder="RA DEC WAVE" bitpix="-32"';

    my $ORAC_STATUS;

    my $untrim_bounds = sub {
        my ($bound, $size) = @_;
        $bound -= $size - 1 if $bound < 0;
        my $lower = $size * int($bound / $size);
        return ($lower, $lower + $size - 1);
    };

    # Co-add all files for the same tile.
    my %tiles = ();

    do {
        my %grouped = ();

        foreach my $Obj ($Grp->allmembers()) {
            for (my $i = 0; $i < $Obj->nfiles(); $i ++) {
                my $file = $Obj->file($i + 1);
                my $tile = $Obj->hdrval('TILENUM', $i);

                push @{$grouped{$tile}}, $file;
            }
        }

        while (my ($tile, $files) = each %grouped) {
            my $coadd;

            if (1 == scalar @$files) {
                $coadd = $files->[0];
            }
            else {
                orac_say("  Co-adding tile $tile");
                $coadd  = sprintf('coadd_%i', $tile);

                my $mosfiles = write_file_list(@$files);

                $Mon{'ccdpack_reg'}->obeyw('makemos', "in=^$mosfiles out=$coadd method=mean usevar=true");
                $Mon{'ndfpack_mon'}->obeyw('provrem', "ndf=$coadd ancestor=all");

                $Grp->push_intermediates($coadd);
            }

            $tiles{$tile} = $coadd;
        }
    };

    # Chop up tiles to 512 pixels (ours are 1024) and permute axes.
    do {
        my %chopped = ();
        while (my ($tile, $file) = each %tiles) {
            orac_say("Splitting file $file");

            $Mon{'ndfpack_mon'}->obeyw('ndftrace', "ndf=$file quiet");
            ($ORAC_STATUS, my @lbnd) = $Mon{'ndfpack_mon'}->get('ndftrace', 'lbound');
            ($ORAC_STATUS, my @ubnd) = $Mon{'ndfpack_mon'}->get('ndftrace', 'ubound');
            my $width = 1 + $ubnd[0] - $lbnd[0];
            my $height = 1 + $ubnd[1] - $lbnd[1];
            unless ($width == 1024 and $height == 1024) {
                unless ($input_jsa_tiles) {
                    # Non-JSA tile input: we should have constructed
                    # the correct size.
                    die 'Unexpected width or height';
                }
                elsif ($width > 1024 or $height > 1024) {
                    # In the case of JSA tile input, allow for trimmed tiles,
                    # but they should not exceed the nominal tile size.
                    die 'Excess width or height';
                }

                # We have a trimmed JSA tile: recompute @lbnd (and @ubnd
                # although it is not currently used) to take into account
                # what the bounds of the full tile would have been.
                my @xbnd = $untrim_bounds->($lbnd[0], 1024);
                my @ybnd = $untrim_bounds->($lbnd[1], 1024);
                if ($xbnd[1] < $ubnd[0] or $ybnd[1] < $ubnd[1]) {
                    die 'Inconsistent tile bounds';
                }
                @lbnd = ($xbnd[0], $ybnd[0]);
                @ubnd = ($xbnd[1], $ybnd[1]);
            }

            foreach my $subtile (
                        [0, 512, 0],
                        [1, 0, 0],
                        [2, 512, 512],
                        [3, 0, 512],
                    ) {
                my ($i, $x, $y) = @$subtile;
                $x += $lbnd[0];
                $y += $lbnd[1];
                my $xx = $x + 511;
                my $yy = $y + 511;

                my $section = "($x:$xx,$y:$yy)";
                $Mon{'kappa_mon'}->obeyw('stats',"ndf=$file$section");
                ($ORAC_STATUS, my $ngood) = $Mon{'kappa_mon'}->get('stats', 'numgood');
                next unless $ngood > 0;

                my $out = sprintf('%s_%i', $file, $i);
                $Mon{'kappa_mon'}->obeyw('permaxes', "in=$file$section out=$out perm=[2,1]");
                $Grp->push_intermediates($out);

                $chopped{4 * $tile + $i} = $out;
            }
        }

        %tiles = %chopped;
    };

    # Construct the HiPS.
    mkdir $root;

    _MAKE_HIPS_PROPERTIES_ ROOT=$root

    my $isfirst = 1;
    for (my $order = $maxorder; $order > -1; $order --) {
        orac_say("Processing HiPS order: $order");
        if ($isfirst) {
            $isfirst = 0;
        }
        else {
            my %grouped = ();

            while (my ($tile, $file) = each %tiles) {
                my $sub = int($tile / 4);
                push @{$grouped{$sub}}, $file;
            }

            my %merged = ();

            while (my ($tile, $files) = each %grouped) {
                orac_say("  Processing tile $tile");

                my $pasted;

                if (1 == scalar @$files) {
                    $pasted = $files->[0];
                }
                else {
                    $pasted = sprintf('tile_%i_%i_unsquashed', $order, $tile);
                    $Grp->push_intermediates($pasted);
                    my $in = join ' ', @$files;
                    $Mon{'kappa_mon'}->obeyw('paste', "$in out=$pasted transp=true confine=false");
                }

                my $out = sprintf('tile_%i_%i', $order, $tile);
                $Mon{'kappa_mon'}->obeyw('sqorst', "in=$pasted out=$out mode=factors factors=[0.5,0.5] method=auto");
                $Grp->push_intermediates($out);

                $Mon{'ndfpack_mon'}->obeyw('ndftrace', "ndf=$out quiet");
                ($ORAC_STATUS, my @lbnd) = $Mon{'ndfpack_mon'}->get('ndftrace', 'lbound');
                ($ORAC_STATUS, my @ubnd) = $Mon{'ndfpack_mon'}->get('ndftrace', 'ubound');

                die 'Unexpected width' if ($ubnd[0] - $lbnd[0]) > 512;
                die 'Unexpected height' if ($ubnd[1] - $lbnd[1]) > 512;

                my ($x, $xx) = $untrim_bounds->($lbnd[0], 512);
                my ($y, $yy) = $untrim_bounds->($lbnd[1], 512);

                my $untrim = sprintf('%s_untrim', $out);
                $Mon{'ndfpack_mon'}->obeyw('ndfcopy', "in=$out($x:$xx,$y:$yy) out=$untrim");
                $Grp->push_intermediates($untrim);

                $merged{$tile} = $untrim;

            }

            %tiles = %merged;
        }

        my $orderdir = File::Spec->catdir($root, sprintf('Norder%i', $order));
        mkdir $orderdir;

        while (my ($tile, $file_orig) = each %tiles) {
            # Copy the file and remove all unnecessary information because
            # Aladin seems to fail to read the files properly if the header
            # is too long!
            my $file = $file_orig . '_copy';
            $Grp->push_intermediates($file);

            $Mon{'ndfpack_mon'}->obeyw('ndfcopy', "in=$file_orig out=$file");

            $Mon{'ndfpack_mon'}->obeyw('wcsremove', "ndf=$file frames=*");
            $Mon{'ndfpack_mon'}->obeyw('setorigin', "ndf=$file origin=[1,1]");

            my $hdrfile = new ORAC::TempFile();
            my $fh = $hdrfile->handle();
            printf $fh "ORDER   = %20i                                                  \n", $order;
            printf $fh "NPIX    = %20i                                                  \n", $tile;
            close $fh;
            $Mon{'ndfpack_mon'}->obeyw('fitstext', "ndf=$file file=$hdrfile");

            my $dirnum = int($tile / 10000) * 10000;
            my $tiledir = File::Spec->catdir($orderdir, sprintf('Dir%i', $dirnum));
            mkdir $tiledir;
            my $tilefile = File::Spec->catfile($tiledir, sprintf('Npix%i.fits', $tile));

            orac_say("  Writing tile $tilefile");
            $Mon{'convert_mon'}->obeyw('ndf2fits', "in=$file out=$tilefile $fits_opts");
        }

        if ($order == 3) {
            my $tilesref = \%tiles;
            _MAKE_HIPS_ALLSKY_ ROOT=$root ORDER=$order TILES=$tilesref
        }
    }
}
