# -*-cperl-*-

=head1 NAME

_CALC_NOISE_TEXP_ - calculate the mean noise and exposure time in an aperture

=head1 SYNOPSIS

_CALC_NOISE_TEXP_

=head1 DESCRIPTION

This PICARD primitive calculates the mean noise level and exposure
time within a specified aperture.

The default aperture has a radius of 30", though this is overridden by
the presence of the C<APERTURE_RADIUS> recipe parameter.

=head1 ARGUMENTS

This primitive has the following arguments:

=over 4

=item B<LOGFILE>

A flag to denote whether to store information in the C<PICARD_RESULTS>
hash for later writing to a logfile. Overridden by the presence of the
C<RECPAR_LOGFILE> recipe parameter. Default is 1.

=item B<RADIUS>

Radius of the aperture used to calculate the mean exposure time and
noise level. Default is 30 arcsec, though overridden by the
C<APERTURE_RADIUS> recipe parameter.

=back

=head1 EXTERNAL TASKS

The following external tasks are used:

=over 4

=item KAPPA

NDFCOPY

=item ORAC-DR primitives:

SCUBA2: _FIND_INTEGRATED_INTENSITY_, _CENTROID_IMAGE_;
PICARD: _GET_CURRENT_RESULTS_

=back

=head1 OUTPUT DATA

None.

=head1 OUTPUT FILES

Creates files with suffix C<_err> for all images of calibrators which
contain the square-root of the variance component for that image.

=head1 AUTHOR

Andy Gibb E<lt>agg@astro.ubc.caE<gt>

=head1 COPYRIGHT

Copyright (C) 2009-2010 University of British Columbia. All Rights
Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut

# First step is to redefine the calibration object as SCUBA2. Retrieve
# the original headers
my $thing1 = $Cal->thingone;
my $thing2 = $Cal->thingtwo;
# Create the new Cal object
$Cal = orac_calib_override( "ORAC::Calib::SCUBA2" );
# Store the header things in the new Calib object
$Cal->thingone($thing1);
$Cal->thingtwo($thing2);

# Tell the user what's going on
orac_print ("\nCalling _CALC_NOISE_TEXP_: calculate fluxes, noise etc\n", "yellow");

# Are results to be written to a logfile? Override with recipe parameter.
my $logfile = get_prim_arg($_PRIM_ARGS_, "LOGFILE", 1);
$logfile = $Frm->uhdr("RECPAR_LOGFILE")
  if (defined $Frm->uhdr("RECPAR_LOGFILE"));

# Radius of aperture in arcsec for calculating noise and texp
my $radius = get_prim_arg($_PRIM_ARGS_, "RADIUS", 30);
$radius = $Frm->uhdr("RECPAR_APERTURE_RADIUS")
  if (defined $Frm->uhdr("RECPAR_APERTURE_RADIUS"));

# Retrieve existing results if present
my @picard_results;
if (defined $Frm->uhdr("PICARD_RESULTS")) {
  @picard_results = @{ $Frm->uhdr("PICARD_RESULTS") };
}

# Retrieve info about files in Frame
my $nfiles = $Frm->nfiles;
my @files = $Frm->files;
# Make a copy to restore later
my $inFrm = $Frm;

# Create a new Frame object
$Frm = $Frm->new;

# Loop over each file
foreach my $i ( 1 .. $nfiles ) {
  # Define the header for the new Frame
  $Frm->files($files[$i-1]);
  $Frm->readhdr;

  # Calculate mean Texp within an aperture centred on the source,
  # determined as the centroid near the SkyRef position.
  _CENTROID_IMAGE_
  my $xypos = $_CENTROID_IMAGE_{RESULTS};
  my $image = $Frm->file .".more.smurf.exp_time";
  _FIND_INTEGRATED_INTENSITY_ IMAGE=$image MASK=0 RADIUS=$radius XYPOS=$xypos
  my $meantexp = $_FIND_INTEGRATED_INTENSITY_{SUM} / $_FIND_INTEGRATED_INTENSITY_{NUMGOOD};

  # Now repeat for the variance - unfortunately we have to copy it out
  # first to a temporary file
  my $var = new ORAC::TempFile;
  $image = $var->file;

  my $args = "in=".($Frm->file)." out=$image comp=var";
  $Mon{ndfpack_mon}->obeyw("ndfcopy","$args");
  _FIND_INTEGRATED_INTENSITY_ IMAGE=$image MASK=0 RADIUS=$radius XYPOS=$xypos
  my $meanvar = $_FIND_INTEGRATED_INTENSITY_{SUM} / $_FIND_INTEGRATED_INTENSITY_{NUMGOOD};

  # Obtain basic results and define current results hash
  _GET_CURRENT_RESULTS_ CURRENT=$i-1 PICARD_RESULTS=\@picard_results
  my %current_results = %{ $_GET_CURRENT_RESULTS_{RESULTS} };

  $current_results{texp} = $meantexp;
  $current_results{noise} = sqrt($meanvar);

  # Store the current results
  $picard_results[$i-1] = \%current_results;
}

# Since no new files were created, restore the original Frame object
$Frm = $inFrm;

# Store the results hash in the Frame uhdr
if ( $logfile ) {
  $Frm->uhdr("PICARD_RESULTS", \@picard_results);
}
