=head1 NAME

_INTERLEAVE_COADD_ - Interleave and coadd multiple integrations.

=head1 DESCRIPTION

This primitive takes all the integrations (sub-frames) in an observation and
interleaves and/or co-adds them as necessary to form a single NDF.

=head1 NOTES

This essentially replaces the old primitives 
_INTERLEAVE_DETECTOR_POSITIONS_ and 
_COADD_MULTIPLE_EXPOSURES_ 

The interleaved observation is stored in a file with a _inc suffix.

=head1 AUTHOR

Paul Hirst <p.hirst@jach.hawaii.edu>

=head1 COPYRIGHT

Copyright (C) 1998-2003 Particle Physics and Astronomy Research
Council. All Rights Reserved.

=cut

# OK, we're going to do this by working out what the sampling pattern
# used was, then looping through all the frames, adding them into the
# final NDF as appropriate. Thus, we make no assumptions about the
# number of integrations at each detector position, or about which
# position is in which integration component of the HDS, instead
# referring to the DINDEX header in the integration (ie .Ix) NDF
# headers.

my $detincr = $Frm->uhdr("ORAC_SCAN_INCREMENT");

# The expansion factor = $a
my $a = nint (1/ $detincr);

my $nfiles=$Frm->nfiles;

if ($nfiles > 1) {

   # OK, here goes

   my $expand = new ORAC::TempFile;
   my $efile = $expand->file;

   my $ard = new ORAC::TempFile;
   my $ardfile = $ard->file;

   # Create the ARD file here as there's no need to do this N times.
   # The ARD file blanks out all but the first out of every $a columns
   # Only if we're not $a=1

   if ($a != 1) {
      foreach my $x (0 .. $Frm->uhdr("ORAC_X_DIM") - 1 ) {
         foreach my $y (1 .. $a) {
            if ($y != 1) {
	        my $eval = $a*$x+$y;
                print {$ard->handle} "COLUMN( $eval )\n";
            }
         }
      }
      close $ard->handle or die "Could not close $ardfile: $!";
   }

   # Use a tmp file to store the list of input file for makemos-
   # otherwise we overflow the max length of the command line parameter
   my $list=new ORAC::TempFile;
   my $listfile =$list->file;
   open(LIST, ">$listfile");
   
   my $mosparam = "genvar=true usevar=true logto=neither logfile=! method=mean scale=false zero=false in=^$listfile";

   foreach my $i (1 .. $nfiles) {
      # Get input and output file names. This is to go to a step ready for mosaicing
      # ipm = interleave pre-mosaic This is essentially a temp file.
      my ($in, $out)=$Frm->inout("_ipm", $i);

      # Expand the file in the spectral dimention by a factor $a into a temp file
      if ($a == 1) {
         $Mon{'ndfpack_mon'}->obeyw("ndfcopy", "in=$in out=$efile");
      } else {
         $Mon{'kappa_mon'}->obeyw("pixdupe", "in=$in out=$efile expand=[$a, 1]");
      }

      # Now blank out all but the first column of expanded pixels
      if ($a != 1) {
         $Mon{'kappa_mon'}->obeyw("ardmask", "in=$efile out=$out ardfile=$ardfile");
      } else {
         $Mon{'ndfpack_mon'}->obeyw("ndfcopy", "in=$efile out=$out");
      }

      # Now shift the image in +x by DINDEX-1 pixels
      my $origin = $Frm->hdr->{$i}->{DINDEX};
      $Mon{'ndfpack_mon'}->obeyw("setorigin", "ndf=$out origin=\[ $origin\]");

      # Add to makemos list file
      print LIST "$out\n";

      # Update the Frm object and report
      $Frm->file($i, $out);
      orac_print ("$in to $out: Prepared for interleave-coadd\n");
      
   } 

   close(LIST);

   # We're going to 1 NDF now, and we're thru with $in

   $Frm->files($Frm->file);
   $Frm->file($Frm->file);

   my ($in, $out) = $Frm->inout ("_inc");

   $mosparam .= " title=$out out=$out";

   $Mon{'ccdpack_reg'}->obeyw("makemos", $mosparam);

   $Frm->files($out);
   $Frm->mergehdr;

   orac_print ("Frames interleaved and coadded into $out\n");
   $Frm->file($out);

   # Update the uhdr.
   $Mon{"ndfpack_mon"}->obeyw( "ndftrace", "ndf=$out" );
   (my $ORAC_STATUS, my @dims) = $Mon{"ndfpack_mon"}->get("ndftrace", "dims");
   $Frm->uhdr("ORAC_X_DIM", $dims[0]);

   # Proffer to display
   $Display->display_data( $Frm ) if defined $Display;
}

orac_print "\n";
