# For OS-independent filename creation.
    use File::Spec;

# Parameters
# ==========

# Load the rows from the calibration system, or store the rows.
    my $profile = $_FIND_PEAKS_BY_MAKING_IMAGE_{PROFILE};
    if ( !defined $profile ) {
       orac_throw "Programming error: _FIND_PEAKS_BY_MAKING_IMAGE_ invoked without " .
                  "PROFILE argument defined.\n";
    }

# Obtain the number of objects to locate defaulting to 1.
    my $beams_wanted = defined $_FIND_PEAKS_BY_MAKING_IMAGE_{MAXPEAKS} ? 
                       $_FIND_PEAKS_BY_MAKING_IMAGE_{MAXPEAKS} : 1;

# Obtain the name of the EXTRACTOR file in $ORAC_DATA_CAL and form the
# full file name including path.
    my $parfile = defined $_FIND_PEAKS_BY_MAKING_IMAGE_{PARFILE} ?
                           $_FIND_PEAKS_BY_MAKING_IMAGE_{PARFILE} : "extractor_peaks.sex";

    my $catpath = $ENV{ "ORAC_DATA_CAL" };
    $parfile = File::Spec->catfile( $catpath, $parfile );

    my ( $beams_found, @pos, @peak );

# Form image version of the profile
# =================================

# Create some work arrays.
    my $pad = new ORAC::TempFile;
    my $padfile = $pad->file;

    my $pad1 = new ORAC::TempFile;
    my $pad1file = $pad1->file;

    my $pad2 = new ORAC::TempFile;
    my $pad2file = $pad2->file;

    my $pad3 = new ORAC::TempFile;
    my $pad3file = $pad3->file;

    my $pad4 = new ORAC::TempFile;
    my $pad4file = $pad4->file;

    my $half = new ORAC::TempFile;
    my $halffile = $half->file;

    my $quart = new ORAC::TempFile;
    my $quartfile = $quart->file;

    my $image = new ORAC::TempFile;
    my $imagefile = $image->file;

# Create half and quarter times copies of the profile.
    $Mon{ 'kappa_mon' }->obeyw( "cmult", "in=$profile scalar=0.5 out=$halffile" );
    $Mon{ 'kappa_mon' }->obeyw( "cmult", "in=$profile scalar=0.25 out=$quartfile" );

# Make the 2-d array with five rows, placing the supplied profile in the central row.
    $Mon{ 'kappa_mon' }->obeyw( "manic", "in=$profile axes=[1,0] lbound=-1 ubound=3 out=$padfile" );

# Make the quarter and half scaled images into 2-d arrays, the signal weakening from the centre.
    $Mon{ 'kappa_mon' }->obeyw( "manic", "in=$quartfile axes=[1,0] lbound=-1 ubound=-1 out=$pad1file" );
    $Mon{ 'kappa_mon' }->obeyw( "manic", "in=$quartfile axes=[1,0] lbound=3 ubound=3 out=$pad2file" );
    $Mon{ 'kappa_mon' }->obeyw( "manic", "in=$halffile axes=[1,0] lbound=0 ubound=0 out=$pad3file" );
    $Mon{ 'kappa_mon' }->obeyw( "manic", "in=$halffile axes=[1,0] lbound=2 ubound=2 out=$pad4file" );

# Paste the scaled profiles into the 2-d array.
    my $param = "p1=$pad1file p2=$pad2file p3=$pad3file p4=$pad4file";
    $Mon{ 'kappa_mon' }->obeyw( "paste", "in=$padfile $param out=$imagefile" );
    $Mon{ 'ndfpack_mon' }->obeyw( "ndfcopy", "in=$padfile out=bum" );
    

# Perform inventory on the field
# ==============================

# Specify the EXTRACTOR parameters.  The name and format of the results catalogue
# is fixed, containing just the x position and the peak flux in the ASCII file
# ${ORAC_DATA_CAL}/extractor_profile.param.  Set the default catalogue
# name.
    my $resfile = "profile_peak.cat";

# Read the EXTRACTOR parameter file line by line until the DETECT_THRESH
# parameter is encountered.  Extract its value.  Note the
# parameter file is whitespace separated.
    open( my $fh_parfile, "< $parfile" ) ||
      orac_throw "Unable to open $parfile to read the source inventory.  Error: $!.\n";
    my $found = 0;
    my $sigma = 1.5;
    my $line;
    while ( defined( $line = <$fh_parfile> ) && ! $found ) {
       if ( $line =~ /^DETECT_THRESH/ ) {
          $found = 1;
          my @words = split( /\s+/, $line );
          $sigma = $words[ 1 ];
       }
    }

# Obtain the catalogue name from the .sex file.
    while ( defined( $line = <$fh_parfile> ) && ! $found ) {
       if ( $line =~ /^CATALOG_NAME/ ) {
          $found = 1;
          my @words = split( /\s+/, $line );
          $resfile = $words[ 1 ];
       }
    }

# Finished with the parameter file.
    close( $fh_parfile );

# Report the processing status.
    orac_print "Detecting profile peaks in at $sigma times sky noise above sky.\n";

# Derive an inventory of the images in $resfile.
    $param = "image=$imagefile config=$parfile";
    my $extractor_status = $Mon{ "extractor" }->obeyw( "extract", "$param" );

# We can handle a failure here by setting the number of found features to 0.
# So we test a # local status rather than let ORAC-DR go on to the next file.
    if ( $extractor_status == ORAC__OK ) {

# Read the results file into an array.  Obtain the number of objects.
# Remove the results file.
       open( my $fh_resfile, "< $resfile" ) ||
         orac_throw "Unable to open $resfile to read the source inventory.  Error: $!.\n";

# Read the file, junking the first two header lines.
       my @lines = <$fh_resfile>;

# Obtain the number of peaks found.
       my $numpeaks = $#lines + 1;

# Tidy the file.
       close( $fh_resfile );
#       unlink ( $resfile );

# Split on space and store each line as a reference to a hash in a
# temporary array, where we store the actual text for the row in the
# first element in the array for later recovery.
       my @fields = map { [ $_, split /\s+/,$_ ] } @lines;

# Need to sort on the second column, the peak flux, in ascending order.
       my @sorted = sort { $a->[3] <=> $b->[3] } @fields;

# Copy the table again, since the actual line is in position zero, then
# extract the columns into arrays.
       my @newlines = map { $_->[0] } @sorted;

       for ( my $ifd = 0; $ifd < $numpeaks; $ifd++ ) {
          my @fields = split( /\s+/, $newlines[$ifd] );

          push( @pos, $fields[1] );
          push( @peak, $fields[2] );
       }

# Now take the desired number of peaks.
       if ( $beams_wanted < $numpeaks ) {
          my @tmpos = ();
	  my @tmpeak = ();
          for ( my $i = 0; $i < $beams_wanted; $i++ ) {
             my $p = pop( @pos );
	     push( @tmpos, $p );
             $p = pop( @peak );
	     push( @tmpeak, $p );
          }
               
          @pos = @tmpos;
	  @peak = @tmpeak;
          $beams_found = $beams_wanted;
       } else {
          $beams_found = $numpeaks;
       }

    } else {
       $beams_found = 0;
       @pos = ();
       @peak = ();
    }

# Return the values.
# ==================
    $_FIND_PEAKS_BY_MAKING_IMAGE_{FOUND} = $beams_found;
    $_FIND_PEAKS_BY_MAKING_IMAGE_{POS} = \@pos;
    $_FIND_PEAKS_BY_MAKING_IMAGE_{PEAK} = \@peak;

