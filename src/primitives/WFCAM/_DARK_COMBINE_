    # How many frames?

    if ($Frm->hdr("OBSTYPE") eq "OBJECT" && $Frm->hdr("FILTER") eq "Blank") {
	$Frm->hdr("OBSTYPE"=>"DARK");
    }
    if ($Frm->hdr("OBSTYPE") eq "DARK") {
	my $subgrp = $Grp->subgrp("EXP_TIME"=>$Frm->hdr("EXP_TIME"),"OBSTYPE"=>"DARK");
	my @f = $subgrp->members;
	my $nf = @f;
	if ($nf == 0) {
	    orac_throw("No members of current group are available for combining!\n");
	}

	# Output file name

	my $outfile;
	$outfile = sprintf("dark_%s_%d%s",$Grp->name,$Frm->hdr("EXP_TIME"),
	    $Frm->fitssuffix);

	# If the output file already exists, then just delete it and do the
	# combination again with the current list of frames. Also set up a
	# flag to say later on that this dark shouldn't be added to the
	# index, because it's already there...

	my $addit = 1;
	if (-f $outfile) {
	    unlink $outfile;
	    $addit = 0;
	}

	# How many frames?

	if ($nf < 2) {
	    copy($Frm->file,$outfile);
	} else {

	    # Do background stats on the images and scale find the relevant
	    # scale factors for the imcombine

	    foreach my $frm ($subgrp->members) {
		my $Frm = $frm;
		_IMSTAT_ HDRUP=1
	    }
            {
                my $Grp = $subgrp;
 	        _ICSCALE_
            }

	    # Get some header keywords...

	    my $readkey = $Frm->hdrkeys("READNOISE");
	    my $gainkey = $Frm->hdrkeys("GAIN");
	    my $expkey = $Frm->hdrkeys("EXPOSURE_TIME");

	    # Now loop for each image extension

	    my $nextn = $Frm->findnsubs;
	    my $i;
	    for ($i = 1; $i <= $nextn; $i++) {

		# Get a temporary file

		my $tmpfil = new ORAC::TempFile;
		my $fh = $tmpfil->handle;

		# Write the names of the input files to the temporary file

		foreach my $frm ($subgrp->members) {
		    print $fh $frm->getasubframe($i)->file . "\n";
		}
		$fh->close;

		# Output file name specification

		my $outf = sprintf("%s[%d]",$outfile,$Frm->getasubframe($i)->subfrmnumber);

		# Do the combination now...

		my ($retval,$errmsg);
		$retval = cir_imcombine($tmpfil->file,$outf,"","",MEDIANCALC,0,1,
		    0,NOBPM,REJPOISSON,1,1,1,3.0,3.0,$readkey,$gainkey,$expkey,
		    $errmsg);
		if ($retval != CIR_OK) {
		    orac_throw "CIR_IMCOMBINE: failed in _DARK_COMBINE_\n$errmsg\n";
		}
		$tmpfil->DESTROY;
	    }
	}

	# Write some stuff to the PHU

	my $darkfrm = $Frm->new($outfile);
	$darkfrm->update_header("WFRTYPE",TSTRING,CALDARK,"Calibration frame type");
	if ($addit) {
	    _FILE_DARK_ NAME=$outfile
	}

	# Display it

	{
	    my $Frm = $darkfrm;
	    _DISPLAY_IMAGE_
	}
    }

=head1 NAME

_DARK_COMBINE_ -- Form a mean dark frame

=head1 DESCRIPTION

If there is only one frame in the group then this primtive just copies it
to the output file name. If there are more than one then this primitive first 
works out the background values for all the frames in a group. This provides
scaling factors or zero points that can be used to scale the images
to a common median during the combine phase. A combination is done for
each extension. If the dark frame output file already exists, then it is
deleted and the combination is done again. This is to get around the fact that
currently there is no way of 'grouping' dark exposures together in such a way
that you can flag when a sequence of dark exposures is finished. This shouldn't
be a problem though as the timing should be trivial

=head1 ARGUMENTS

None

=head1 NOTES

=over 4

=item *

Mean dark is filed in index file.

=back

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2004-2007 Cambridge Astronomy Survey Unit. 
All Rights Reserved

=cut
