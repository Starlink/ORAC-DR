    my $group = $Grp->name;
    my $filter = $Frm->uhdr("ORAC_FILTER");
    my $camnum = $Frm->hdr("CAMNUM");
    my $logfile = "focus_".$group."_".$filter."_".$camnum.".log";
    my $log = new ORAC::LogFile($logfile);

    # Do flat field correction and dark correction

    _STAGE1_SPECIAL_ FLATCOR=1 DARKCOR=1

    # Create an output file name for the catalogue

    my ($basename,$dir,$suffix,$extn) = $Frm->parsefname;
    my $outfile = sprintf("%s_cat%s",$basename,$suffix);
    unlink $outfile if (-f $outfile);

    # First hedit in the confidence map...

    my $cpm = $Cal->CPM;
    my $cpmfr = sprintf("%s[1]",$cpm);
    my ($errmsg,$retval);
    $Frm->uhdr("CATFILE",$outfile);
    foreach my $i (1 .. $Frm->findnsubs) {
        my $snum = $Frm->getasubframe($i)->subfrmnumber;
        $retval = cir_update_hdr($Frm->getasubframe($i)->file,"CIR_CPM",
            "STRING",$cpmfr,"Name of Confidence Map",$errmsg);
        $Frm->getasubframe($i)->hdr("CIR_CPM",$cpmfr);
 
        # Now do an image detection

        my $inf = $Frm->getasubframe($i)->file;
        my $outf = sprintf("%s[%d]",$outfile,$i);
        my $ellf = "";
        $retval = cir_imcore($inf,$cpmfr,50,2.0,0,3.5,64,$outf,$ellf,
	    0,1,$errmsg);
        $Frm->getasubframe($i)->uhdr("CATFILE",$outf);
        if ($retval != CIR_OK) {
            orac_throw "CIR_IMCORE: failed in _IMCORE_\n$errmsg\n";
        }
    }

    # Do the image classification

    _CLASSIFY_

    # Dump some stuff from the catalogue and get the relevant info

    my @allcols = ('X_coordinate','Y_coordinate','Ellipticity',
	'Gaussian_sigma','Classification');
    my @fws = ();
    my @focs = ();
    foreach my $i (1 .. $Frm->findnsubs) {
        my $fwhm = 0.0;
        my $nsamp = 0;
        my $nxl = $Frm->getasubframe($i)->hdr("NAXIS1") - 25.0;
        my $nyl = $Frm->getasubframe($i)->hdr("NAXIS2") - 25.0;
        my $tab = $Frm->getasubframe($i)->uhdr("CATFILE");
        my $tmpfile = ORAC::TempFile->new(0);
        $retval = cir_tabledump($tab,$tmpfile->file,\@allcols,5,$errmsg);
        my $fh = $tmpfile->handle;
        open $fh,$tmpfile->file;
        while (<$fh>) {
            chomp;
            my @a = split /\s+/;
            $a[3] *= 2.235;
    
            # Calculate mean FWHM for class=-1 objects that are away from the
            # the edges

            if(($a[0] > 25.0 && $a[1] > 25.0 && $a[0] < $nxl && $a[1] < $nyl) 
		&& $a[2] < 0.25) {
                $nsamp++;
                $fwhm+=$a[3];
            }
        }
	$fh->close;
        $tmpfile->DESTROY;
        if ($nsamp > 0) {
	    $fwhm /= $nsamp;
            $fwhm = sprintf("%8.2f", $fwhm);
            my $foc = $Frm->getasubframe($i)->hdr("FOC_OFFS");
            push @focs,$foc;
            push @fws,$fwhm;
            orac_print("Mean FWHM of objects is: $fwhm, at foc_posn $foc\n");
            orac_print("$foc, $fwhm # FOC, FWHM\n");
            $log->header("#Foc, fwhm");
            $log->addentry("$foc, $fwhm");
        }
    }      

    # Arrays @focs and @fws now ready for Paul!

=head1 NAME

_FOCUS_SERIES_ -- Do very basic analysis on a focus series and report back
the FWHM as a function of focus offset

=head1 DESCRIPTION

This recipe does a very basic dark subtraction and flat field calibration on
a focus series. All of the images are in the same container file, so the input
will have only images from a single detector. Once the dark and flat are dealt
with, a very simple image detection is done. The mean FWHM of the objects on
the frame is extracted from the header and presented on the screen as a 
function of focus offset.

=head1 ARGUMENTS

None

=head1 NOTES

None

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2004-2007 Cambridge Astronomy Survey Unit. 
All Rights Reserved

=cut
