    my $group = $Grp->name;
    my $filter = $Frm->uhdr("ORAC_FILTER");
    my $camnum = $Frm->hdr("CAMNUM");
    my $logfile = "focus_".$group."_".$filter."_".$camnum.".log";
    my $log = new ORAC::LogFile($logfile);
    my $tcslogfile = "tcs_focus_".$group.".log";
    my $tcslog = new ORAC::LogFile($tcslogfile);

    # Do flat field correction and dark correction

    _STAGE1_SPECIAL_ FLATCOR=1 DARKCOR=1

    # Create an output file name for the catalogue

    my ($basename,$dir,$suffix,$extn) = $Frm->parsefname;
    my $outfile = sprintf("%s_cat%s",$basename,$suffix);
    unlink $outfile if (-f $outfile);

    # First hedit in the confidence map...

    my $cpm = $Cal->CPM;
    my $cpmfr = sprintf("%s[1]",$cpm);
    my ($errmsg,$retval);
    $Frm->uhdr("CATFILE",$outfile);
    foreach my $i (1 .. $Frm->findnsubs) {
        my $snum = $Frm->getasubframe($i)->subfrmnumber;
        $retval = cir_update_hdr($Frm->getasubframe($i)->file,"CIR_CPM",
            "STRING",$cpmfr,"Name of Confidence Map",$errmsg);
        $Frm->getasubframe($i)->hdr("CIR_CPM",$cpmfr);
 
        # Now do an image detection

        my $inf = $Frm->getasubframe($i)->file;
        my $outf = sprintf("%s[%d]",$outfile,$i);
        my $ellf = "";
        $retval = cir_imcore($inf,$cpmfr,50,2.0,0,3.5,64,$outf,$ellf,
	    0,1,$errmsg);
        $Frm->getasubframe($i)->uhdr("CATFILE",$outf);
        if ($retval != CIR_OK) {
            orac_throw "CIR_IMCORE: failed in _IMCORE_\n$errmsg\n";
        }
    }

    # Do the image classification

    _CLASSIFY_

    # Dump some stuff from the catalogue and get the relevant info

    my @allcols = ('X_coordinate','Y_coordinate','Ellipticity',
	'Gaussian_sigma','Classification');
    my @fws = ();
    my @focs = ();
    my $foc_keyword = ($Frm->hdr("OBSTYPE") eq "FOCUS" ? "FOC_OFF" : "FOC_OFFS");
    foreach my $i (1 .. $Frm->findnsubs) {
        my $fwhm = 0.0;
        my $nsamp = 0;
        my $nxl = $Frm->getasubframe($i)->hdr("NAXIS1") - 25.0;
        my $nyl = $Frm->getasubframe($i)->hdr("NAXIS2") - 25.0;
        my $tab = $Frm->getasubframe($i)->uhdr("CATFILE");
        my $tmpfile = ORAC::TempFile->new(0);
        $retval = cir_tabledump($tab,$tmpfile->file,\@allcols,5,$errmsg);
        my $fh = $tmpfile->handle;
        open $fh,$tmpfile->file;
	my @samp = ();
        while (<$fh>) {
            chomp;
            my @a = split /\s+/;
            $a[3] *= 2.235;
    
            # Calculate median FWHM for class=-1 objects that are away from the
            # the edges

            if(($a[0] > 25.0 && $a[1] > 25.0 && $a[0] < $nxl && $a[1] < $nyl) 
		&& $a[2] < 0.5) {
	        push @samp,$a[3];
            }
        }
	$fh->close;
        $tmpfile->DESTROY;
	$nsamp = @samp;
        if ($nsamp > 0) {
            @samp = sort {$a <=> $b} @samp;
            if ($nsamp % 2) {
	        $fwhm = $samp[$nsamp/2];
            } else {
	        $fwhm = 0.5*($samp[$nsamp/2 - 1] + $samp[$nsamp/2]);
            }
            $fwhm = sprintf("%8.2f", $fwhm);
            my $foc = $Frm->getasubframe($i)->hdr($foc_keyword);
            push @focs,$foc;
            push @fws,$fwhm;
            orac_print("Median FWHM of objects is: $fwhm, at foc_posn $foc\n");
            $log->header("#Foc, fwhm");
            $log->addentry("$foc, $fwhm");
        }
    }      

    # Arrays @focs and @fws now ready for Paul!

    my $i=0;
    my $n=0;
    my $sum=0;
    my $sumsq=0;
    while((exists $focs[$i]) && (exists $focs[$i+1])) {
      my $dfwhm = $fws[$i+1] - $fws[$i];
      my $dfoc = $focs[$i+1] - $focs[$i];
      if ($dfoc) {
        my $delta = $dfwhm / $dfoc;
        my $change = $delta / 35.0;
        my $dstring = sprintf("%.2f", $delta);
        my $cstring = sprintf("%.3f", $change);
        orac_print "FWHM delta: $dstring ; Indicates Telescope focus change of $cstring\n";
        $sum += $change;
        $sumsq += ($change * $change);
        $n++;
      }
      $i++;
    }
    if($i>0) {
       my $mean = $sum / $n;
       my $var = ($sumsq / $n) - ($mean*$mean);
       my $sd = sqrt($var);
       my $mstring = sprintf("%.3f", $mean);
       my $sdstring = sprintf("%.3f", $sd);
       orac_print "Indicated focus change: $mstring +- $sdstring\n";
       my $tcsfoc = $Frm->hdr("TCS_FOC");
       $tcsfoc+=$mean;
       my $tfstring = sprintf("%.2f", $tcsfoc);
       $tcslog->header("#SuggestedFocus");
       $tcslog->addentry($tcsfoc);
       orac_print "Suggest setting telescope focus to: $tfstring\n";
    } else {
       orac_print "Didn't detect enough stars to generate focus result\n";
    }




=head1 NAME

_FOCUS_SERIES_ -- Do very basic analysis on a focus series and report back
the FWHM as a function of focus offset

=head1 DESCRIPTION

This recipe does a very basic dark subtraction and flat field calibration on
a focus series. All of the images are in the same container file, so the input
will have only images from a single detector. Once the dark and flat are dealt
with, a very simple image detection is done. The mean FWHM of the objects on
the frame is extracted from the header and presented on the screen as a 
function of focus offset.

=head1 ARGUMENTS

None

=head1 NOTES

None

=head1 AUTHORS

JRL: Jim Lewis (CASU, IoA)

=head1 COPYRIGHT

Copyright (C) 2004-2007 Cambridge Astronomy Survey Unit. 
All Rights Reserved

=cut
