# -*-cperl-*-

=head1 NAME

_TAG_AS_REDUCED_PRODUCT_ -- Tag current file as "reduced".

=head1 DESCRIPTION

For the relevant file (or files), copy it to a new name with product
"reduced" and filename ending in _reduced.

=head1 ARGUMENTS

=over 4

=item FILE = STRING (Given)

By default all files in the given Frame object are tagged as
reduced. This argument allows an explicit file to be tagged.

=item FLAG_QUAL_BAD = LOGICAL (Given)

Whether or not to flag any pixels with a non-zero quality flag as
bad. [0]

=item GROUP = LOGICAL (Given)

Whether to operate on the current Frame or Group object. Defaults to
Frame. [0]

=item UPDATE = LOGICAL (Given)

If true, the output files are stored in the current Frame or Group
object (see C<GROUP> argument) and tagged as product
"reduced". Default is for this update to not happen. [0]

=back

=head1 OUTPUT DATA

=over 4

=item *

Products with suffix _reducedNNN. If a single file is given (see C<FILE>
argument), then the suffix will be _reduced.

=back

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council. All
Rights Reserved.

=cut

# Handle arguments.
my $file = get_prim_arg( $_PRIM_ARGS_, "FILE", undef );
my $flag = get_prim_arg( $_PRIM_ARGS_, "FLAG_QUAL_BAD", 0 );
my $group = ( $_PRIM_ARGS_->{GROUP} ? 1 : 0 );
my $update = ( $_PRIM_ARGS_->{UPDATE} ? 1 : 0 );

my $Obj;
if( $group ) {
  $Obj = $Grp;
} else {
  $Obj = $Frm;
}

if( ! defined( $file ) ) {

  foreach my $i ( 1 .. $Obj->nfiles ) {

    my $in = $Obj->file( $i );
    my $out;
    if ($in =~ /reduced$/) {
      # it is already tagged
      $out = $in;
    } else {
      ( $in, $out ) = $Obj->inout( "_reduced", $i );
    }

    if( $flag ) {

      # We need to set the quality bad-bits mask to 255 so everything
      # with a non-zero quality can get flagged as bad.
      my $params = "ndf=$in bb=255";
      $Mon{'ndfpack_mon'}->obeyw( "setbb", "$params" );

    }

    # We can only do a hardlink if we're not updating the current
    # Object. This is because updating it also sets the product(),
    # which sets the PRODUCT header, and we want the original file to
    # remain untouched.
    if( $update ) {
      if ($in ne $out) {
        $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$out" );
      }
      my $prevsync = $Obj->allow_header_sync;
      $Obj->allow_header_sync(1);
      $Obj->product( "reduced" );
      $Obj->file( $i, $out );
      $Obj->allow_header_sync( $prevsync );

    } else {

      if ($in ne $out) {
        hardlink( "$in.sdf", "$out.sdf" ) or orac_throw "Could not link $in.sdf to $out.sdf: $!\n";
      }
    }

    orac_say "$in to $out:\n Tagged as reduced product.";

    _DISPLAY_FILE_ FILE=$out GROUP=$group

  }
} else {

  my $in = $file;
  ( undef, my $out ) = $Obj->inout( "_reduced" );

  # We can only do a hardlink if we're not updating the current
  # Object. This is because updating it also sets the product(), which
  # sets the PRODUCT header, and we want the original file to remain
  # untouched.
  if( $update ) {
    $Mon{'ndfpack_mon'}->obeyw( "ndfcopy", "in=$in out=$out" );
    $Obj->product( "reduced" );
    $Obj->file( $out );
  } else {

    hardlink( "$in.sdf", "$out.sdf" ) or orac_throw "Could not link $in.sdf to $out.sdf: $!\n";

  }

  orac_say "$in to $out:\n Tagged as reduced product.";

  _DISPLAY_FILE_ FILE=$out GROUP=$group

}


