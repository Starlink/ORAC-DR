#!/usr/local/bin/perl  

my $instruction_list = $ARGV[0];
open FF,"$instruction_list";
$instructions = "";
while (<FF>) {
    chop;
    $instructions .= $_;
}
close FF;
eval $instructions;
unlink $instruction_list;


my $IPIX = $$VAR1{ipix};
my $THRESH = $$VAR1{thresh};
my $GRID = $$VAR1{grid};
my $CATTYPE = $$VAR1{cattype};
my $ICROWD = $$VAR1{icrowd};
my $RCORE = $$VAR1{rcore};
my $CATSRC = $$VAR1{catsrc};
my $SITE = $$VAR1{site};
my $CATPATH = $$VAR1{catpath};
my $jitter_number = $$VAR1{jitter};
my $oractime = $$VAR1{oractime};
my $infiles = $$VAR1{infiles};
my $dodisp = $$VAR1{dodisp};
my @allfiles = @$infiles;
	     
# Load some modules. First, everyone else's

use Astro::FITS::CFITSIO qw(:constants :longnames);
use File::Basename;
use File::Temp qw(tempfile);
use FileHandle;
use ORAC::Basic;
use ORAC::Display;
use ORAC::Display::GAIA;
use ORAC::Frame::WFCAM;

# Now mine

use Cirdr::Primitives qw(:constants :routines);

# Global WCS parameters...

our %wcsparms = ('CRVAL1'  => TDOUBLE,
                 'CRVAL2'  => TDOUBLE,
                 'CRPIX1'  => TDOUBLE,
                 'CRPIX2'  => TDOUBLE,
                 'CD1_1'   => TDOUBLE,
                 'CD1_2'   => TDOUBLE,
                 'CD2_1'   => TDOUBLE,
                 'CD2_2'   => TDOUBLE,
                 'CUNIT1'  => TSTRING,
                 'CUNIT2'  => TSTRING,
                 'CTYPE1'  => TSTRING,
                 'CTYPE2'  => TSTRING,
                 'WCSPASS' => TINT,
                 'NUMBRMS' => TINT,
                 'STDCRMS' => TDOUBLE,
                 'PROJP1'  => TFLOAT,
                 'PROJP3'  => TFLOAT,
                 'PV2_0'   => TFLOAT,
                 'PV2_1'   => TFLOAT,
                 'PV2_2'   => TFLOAT,
                 'PV2_3'   => TFLOAT);

# A few extra globals

our $scale;
our $skylevel;

# Some global parameters to determine how to do the object detection

our $nominal_scale = 0.4;
our @icpars_dither_offsets = (50,7.0,0,2.5,256);
our @icpars_object_det = ($IPIX,$THRESH,$ICROWD,$RCORE,$GRID);

# Get the files we want to dither. 

my $nf = @allfiles;

# Open a file to put messages...

our $msg_fh = new FileHandle;
$msg_fh->open(">jitter_$jitter_number.log");
$msg_fh->autoflush;
print $msg_fh "Begin work on files: @allfiles\n";

# Get a global hash for DQC

our %DQC = ();
our @skydqc = ('SKYLEVEL','SKYNOISE','SEEING','ELLIPTIC');
our @alldqc = ('ORACTIME','CAMNUM','SKYLEVEL','SKYNOISE','SEEING','ELLIPTIC',
	       'MAGZPT','MAGZRR','RAZP','DECZP','STDCRMS','NUMBRMS','FILTER',
	       'MAGZPT_J','SKYLEVEL_JMAG','SKYLEVEL_MAG','PA','AIRMASS');

# If there aren't enough, then there isn't much point in being here...

if ($nf < 2) {
    print $msg_fh "Not enough files to warrant being here...quitting\n";
    exit 0;
}

# Work out what you'd like to call the output

my ($name,$path,$suffix) = fileparse($allfiles[0],".fit");
my $outdith = sprintf("%s_st%s",$name,$suffix);
my $outconf = sprintf("%s_st_conf%s",$name,$suffix);
my $outcat = sprintf("%s_st_cat%s",$name,$suffix);
$name =~ /\S(\d{8})/;
my $utdate = $1;

# If it already exists, then don't continue...

exit 0 if (-f $outdith);

# Find out how big one of the data arrays is

my $status = 0;
my @naxis;
my $fptr = Astro::FITS::CFITSIO::open_file($allfiles[0],READONLY,$status);
my ($stdexp,$junk);
$fptr->read_key(TFLOAT,"EXP_TIME",$stdexp,$junk,$status);
$fptr->movabs_hdu(2,$hdutype,$status);
$fptr->get_img_size(\@naxis,$status);
$fptr->close_file($status);
if ($status != 0) {
    fitserr($status,"Can't open file $allfiles[0]");
    exit 1;
} 

# Right...so let's do the object detection first. Loop for each file and
# for each image extension in the file.

my %cats = ();
my @framesubs = ();
my @cpmsubs = ();
my @exps = ();
my ($retval,$errmsg,$fname,$fnamesub);
my $doconf = 1;
my $cpm;
foreach $fname (@allfiles) {

    # Work out a name for the object file. 

    ($name,$path,$suffix) = fileparse($fname,".fit");
    my $catbase = sprintf("temp_%s_cat%s",$name,$suffix); 
    $cats{$fname} = $catbase;
    unlink $catbase if (-f $catbase);
    push @exps,$stdexp;

    # Create an extension name.
    
    my $fnamesub = sprintf("%s[%d]",$fname,1);
    push @framesubs,$fnamesub;
    my $catsub = sprintf("%s[%d]",$catbase,1);

    # Is there a confidence map defined here?

    $cpm = gethdrval($fnamesub,"CIR_CPM");
    push @cpmsubs,$cpm;
    if (! $cpm) {
	$cpm = "noconf";
	$doconf = 0;
    }

    # Work out 'plate scale' for image and scale the detection parameters
    # accordingly

    plate_scale ($fnamesub);
    my $nsc = int($scale/$nominal_scale + 0.5);
    my @icpars = @icpars_dither_offsets;
    $icpars[0] *= $nsc;
    $icpars[3] *= $nsc;
    $icpars[4] *= $nsc;

    # Do the image detection

    $retval = cir_imcore($fnamesub,$cpm,@icpars,$catsub,"",0,3,$errmsg);
    if ($retval != CIR_OK) {
	print $msg_fh "CIR_IMCORE failed for file %s -- %s\n",$fnamesub,
	    $errmsg;
	exit 1;
    }
}

# Right, we got through that. Now, work out the implied offset between images
# given the header info that we already have. NB: only do this for the first
# header as presumably any others will have exactly the same offset.

my @xoffs = ();
my @yoffs = ();
$xoffs[0] = 0.0;
$yoffs[0] = 0.0;
my $ref = sprintf("%s[1]",$allfiles[0]);
my $prog;
foreach $fname (@allfiles) {
    next if ($fname eq $allfiles[0]);
    $prog = sprintf("%s[1]",$fname);
    my ($xx,$yy);
    $retval = cir_diffxywcs($prog,$ref,$xx,$yy,$errmsg);
    if ($retval != CIR_OK) {
        $xx = 0.0;
        $yy = 0.0;
        printf $msg_fh "CIR_DIFFXYWCS: Might be a problem with WCS match between %s and %s\n",$ref,$prog;
    }
    push @xoffs,$xx;
    push @yoffs,$yy;
    printf $msg_fh "WCS offset between %s and %s: %g %g\n",$fname,$allfiles[0],
        $xx,$yy;
}

# Now 'improve' these offsets by looking at the position of the stars in the
# catalogues... First get some temporary file names...

my $tmp;
(undef,$ref) = tempfile("refXXXX",OPEN=>0);
(undef,$prog) = tempfile("progXXXX",OPEN=>0);
(undef,$tmp) = tempfile("tmpXXXX",OPEN=>0);

# Now dump the first file's catalogue

my $tabname = $cats{$allfiles[0]} . "[1]";
$retval = cir_tabledump($tabname,$ref,["X_coordinate","Y_coordinate"],2,
			$errmsg);

# Now loop through the rest of them...

my $i = -1;
foreach $fname (@allfiles) {
    $i++;
    next if ($i == 0);
    $tabname = $cats{$fname} . "[1]";
    $retval = cir_tabledump($tabname,$tmp,["X_coordinate","Y_coordinate"],2,
	$errmsg);

    # Read the x,y coordinates and update them by the WCS offsets....

    my $fh = new FileHandle;
    $fh->open("$tmp");
    my $fh2 = new FileHandle;
    $fh2->open(">$prog");
    while (<$fh>) {
	chop;
        my @coords = split /\s+/;
        $coords[0] += $xoffs[$i];
	$coords[1] += $yoffs[$i];
	print $fh2 "@coords \n";
    }
    $fh->close;
    $fh2->close;
    unlink $tmp;

    # Now for the offsets

    my ($xoff,$yoff,$nm);
    $retval = cir_matchxy($prog,$ref,10,$naxis[0],$naxis[1],$xoff,$yoff,$nm,
	$errmsg);
    if ($retval != CIR_OK || $nm == 0) {
	printf $msg_fh "Object match between %s and %s failed.\n$errmsg\nUsing WCS values\n",
	    $allfiles[$i],$allfiles[0];
    }
    unlink $prog;
    $xoffs[$i] += $xoff;
    $yoffs[$i] += $yoff;
    printf $msg_fh "Object offset between %s and %s: %g %g\n",$fname,
        $allfiles[0],$xoffs[$i],$yoffs[$i];
}
unlink $ref;

# Find the mins of the offset arrays and shift them by that amount. Add the
# final values to the headers

my $minx = min(@xoffs);
my $miny = min(@yoffs); 
foreach $i (0 .. $nf-1) {
    $xoffs[$i] -= $minx;
    $yoffs[$i] -= $miny;
    my $fnamesub = sprintf("%s[%d]",$allfiles[$i],1);
    $retval = cir_update_hdr($fnamesub,"CIR_XOFF","FLOAT",$xoffs[$i],
			     "Dither offset X",$errmsg);
    $retval = cir_update_hdr($fnamesub,"CIR_YOFF","FLOAT",$yoffs[$i],
			     "Dither offset Y",$errmsg);
}

# Do a bit of intermediate tidying by getting rid of the catalogue files.

foreach $fname (@allfiles) {
    unlink $cats{$fname} if (-f $cats{$fname});
}

# Initialise the DQC array

%DQC = ();

# Do the combination. 

my $n = @framesubs;
my $outd = sprintf("%s[%d]",$outdith,1);
my $outc;
if ($doconf) {
    $outc = sprintf("%s[%d]",$outconf,1);
} else {
    $outc = "";
}
cir_imdither(\@framesubs,\@cpmsubs,$n,$outd,$outc,\@xoffs,\@yoffs,\@exps,5.0,
	     5.0,$errmsg);
if ($retval != CIR_OK) {
    print $msg_fh "CIR_IMDITHER failed on dither %s -- %s\n",
	$outd,$errmsg;
    exit 1;
}
print $msg_fh "Files successfully dithered to $outd $outc\n";

# Update the header by shifting CRPIX by the offset of the first frame
# (which is the frame from which the output image will have inherited
# its initial WCS).

$status = 0;
$fptr = Astro::FITS::CFITSIO::open_file($outd,READWRITE,$status);
if ($status != 0) {
    fitserr($status,"Can't open file $outd");
    exit 1;
}
$fptr->get_img_size(\@naxis,$status);
$fptr->read_key(TDOUBLE,"CRPIX1",$value,$junk,$status);
$value += $xoffs[0];
$fptr->update_key(TDOUBLE,"CRPIX1",$value,$junk,$status);    
$fptr->read_key(TDOUBLE,"CRPIX2",$value,$junk,$status);
$value += $yoffs[0];
$fptr->update_key(TDOUBLE,"CRPIX2",$value,$junk,$status);    
$fptr->close_file($status);

# Work out 'plate scale' for image and scale the detection parameters
# accordingly

plate_scale($outd);
my $nsc = int($scale/$nominal_scale + 0.5);
my @icpars = @icpars_object_det;
$icpars[0] *= $nsc;
$icpars[3] *= $nsc;
$icpars[4] *= $nsc;

# Do the catalogue generation for this image extension

if ($doconf) {
    $cpm = $outc;
} else {
    $cpm = "noconf";
}
$retval = cir_imcore($outd,$cpm,@icpars,$outcat,"",0,$CATTYPE,$errmsg);
if ($retval != CIR_OK) {
    print $msg_fh "CIR_IMCORE failed on dither %s -- %s\n",$outd,$errmsg;
    exit 1;
}
print $msg_fh "File $outd used to generate catalogue $outcat\n";

# Fit a WCS to the output dither using the catalogue generated above.
# Start by getting some information about the current WCS

my ($raref,$decref);
$retval = cir_xy2radec($outd,0.5*$naxis[0],0.5*$naxis[1],$raref,$decref,
		       $errmsg);
if ($retval != CIR_OK) {
    print $msg_fh "CIR_XY2RADEC failed on dither %s -- %s\n",$outd,$errmsg;
    exit 1;
}

# Get some standard stars

(undef,$ref) = tempfile("refXXXX",OPEN=>0);
$retval = cir_getstds($outd,$ref,$CATSRC,$SITE,$CATPATH,2000.0,
		      5,1,$errmsg);
if ($retval != CIR_OK) {
    printf $msg_fh "CIR_GETSTDS failed on dither %s -- %s\n",$outd,$errmsg;
    exit 1;
}

# Now match the standards with the catalogue stars...

my $maxsize = max($naxis[0],$naxis[1]);
my $srad = int(0.25*$maxsize);
(undef,$tmp) = tempfile("tmpXXXX",OPEN=>0);
my $nmatch;
my $outcatsub = $outcat . "[1]";
my $retval = cir_matchstds($outcatsub,$ref . "[1]",$srad,$naxis[0],$naxis[1],
			   $tmp,$nmatch,$errmsg);
unlink $ref;
if ($retval != CIR_OK) {
    unlink $tmp;
    print $msg_fh "CIR_MATCHSTDS: Failed on $outcatsub\n$errmsg\n";
    print $msg_fh "Continuing with caution\n";
} elsif ($nmatch == 0) {
    unlink $tmp;
    print $msg_fh "CIR_MATCHSTDS: Failed on $outcatsub\nNo objects matched\n";
    print $msg_fh "Continuing with caution\n";
} else {
    print $msg_fh "$nmatch objects matched astrometric standards\n";
}

# Do the plate solution

$retval = cir_platesol($outd,$tmp,6,2,1,$errmsg);
if ($retval != CIR_OK) {
    print $msg_fh "CIR_PLATESOL: Failed on $outd\n$errmsg\n";
    print $msg_fh "Continuing with the current WCS\n";
}
unlink $tmp;
$fptr = Astro::FITS::CFITSIO::open_file($outd,READONLY,$status);
my ($stdcrms,$numbrms);
$fptr->read_key(TFLOAT,"STDCRMS",$stdcrms,$junk,$status);
$fptr->read_key(TINT,"NUMBRMS",$numbrms,$junk,$status);
$fptr->close_file($status);
$DQC{'STDCRMS'} = $stdcrms;
$DQC{'NUMBRMS'} = $numbrms;
printf $msg_fh "WCS fit to %d stars with RMS %g\n",$numbrms,$stdcrms;

# Work out WCS zeropoint shift and write it to the header.

my ($raref2,$decref2);
$retval = cir_xy2radec($outd,0.5*$naxis[0],0.5*$naxis[1],$raref2,$decref2,
		       $errmsg);
if ($retval != CIR_OK) {
    print $msg_fh "CIR_XY2RADEC failed on dither %s -- %s\n",$outd,$errmsg;
    exit 1;
}
$raref2 = ($raref2 - $raref)*3600.0;
$decref2 = ($decref2 - $decref)*3600.0;
$DQC{'RAZP'} = $raref2;
$DQC{'DECZP'} = $decref2;

# Copy the WCS information to the header of the catalogue 

$retval = update_cat_wcs($outd,$outcatsub);  

# Update the catalogues so that the objects have equatorial coordinates

$retval = cir_catcoord($outd,$outcatsub,$errmsg);

# Update the headers of the input files so that they have the new WCS

foreach $fnamesub (@framesubs) {
    $retval = cir_wcsoffset($outd,$fnamesub,1,$errmsg);
    if ($retval != CIR_OK) {
	print $msg_fh "CIR_WCSOFFSET: Failed on $outd and $fnamesub\n$errmsg\n";
    }
}
print $msg_fh "WCS of input images updated\n";

# Classify the objects...

$retval = cir_classify($outcatsub,"EXP_TIME",$errmsg);
if ($retval != CIR_OK) {
    print $msg_fh "CIR_CLASSIFY: Failed on $outcatsub\n$errmsg\n";
}
print $msg_fh "Catalogue $outcatsub objects are classified\n";

# Update the image header

$status = 0;
$fptr = Astro::FITS::CFITSIO::open_file($outcatsub,READONLY,$status);
foreach my $kk (@skydqc) {
    my ($value,$junk);
    $fptr->read_key(TFLOAT,$kk,$value,$junk,$status);
    $DQC{$kk} = $value;
}
$fptr->close_file($status);
$fptr = Astro::FITS::CFITSIO::open_file($outd,READWRITE,$status);
foreach my $kk (@skydqc) {
    $fptr->update_key(TFLOAT,$kk,$DQC{$kk},"",$status);
}
$fptr->update_key(TFLOAT,"RAZP20",$DQC{'RAZP'},
		  "[arcsec] Ref RA shift pass 2 to 0 (new - old)",$status);
$fptr->update_key(TFLOAT,"DECZP20",$DQC{'DECZP'},
		  "[arcsec] Ref Dec shift pass 2 to 0 (new - old)",$status);
$fptr->read_key(TINT,"CAMNUM",$val,$junk,$status);
$DQC{'CAMNUM'} = $val;
$fptr->close_file($status); 

# Modify the seeing DQC index so that it's in arcseconds.

seeing($outd);

# Work out the median position angle of the objects 

$retval = cir_tabledump($outcatsub,$tmp,["Position_angle"],1,$errmsg);
my $fh = new FileHandle;
$fh->open("$tmp");
my @allpa = ();
while (<$fh>) {
    chop;
    push @allpa,$_;
}
$fh->close;
unlink $tmp;
@allpa = sort {$a <=> $b} @allpa;
my $npa = @allpa;
my $npa2 = $npa/2;
if ($npa % 2) {
    $DQC{'PA'} = $allpa[$npa2];
} else {
    $DQC{'PA'} = 0.5*($allpa[$npa2 - 1] + $allpa[$npa2]);
}

# Do the photometry now

$retval = do_photom($outdith,$outcat);

# Process the history records

cir_prochist($outd);
foreach $fname (@allfiles) {
    $fnamesub = $fnamesubs{$fname};
    cir_prochist($fnamesub);
}

# Write out the dqc index

$DQC{'ORACTIME'} = $oractime;
write_dqc($outd);
log_results($utdate,$outd);


# Write a semaphore file for the catalogue

my $sem = "." . $outcat;
$sem =~ s/\.fit$/\.ok/;
my $fh = new FileHandle;
$fh->open(">$sem");
$fh->close;

# Display the damn thing...

if ($dodisp) {
    $Display = orac_setup_display;
    my $Frm = new ORAC::Frame::WFCAM($outdith);
    $Display->display_data($Frm->getasubframe(1),{WINDOW=>2}) if (defined $Display);
}

#estar($outdith,$outcat,$oractime);


exit 0;

sub log_results {
    my ($utdate,$outf) = @_;

    # Does the log file exist already? If not then create it and put in some
    # column headers 

    my $logfile = sprintf("res_%d.log",$utdate);
    my $oldfile = (-f $logfile);
    my $log_fh = new FileHandle;
    $log_fh->open(">>$logfile");
    $log_fh->autoflush;
    if (! $oldfile) {
        my $heading1 = "";
        my $heading2 = "";

        # File name

        $heading1 .= "          Filename          |";
	$heading2 .= "----------------------------|";
	#             123456789+123456789+12345678

        # UT date and time

        $heading1 .= " UTdate |   UT   |";
        $heading2 .= "--------|--------|";
	#             123456789+123456789+12345678

        # RA and Dec (base)

        $heading1 .= "    RA    |    Dec    |";
	$heading2 .= "----------|-----------|";
	#             123456789+123456789+12345678
    
	# Airmass, filter, exposure time

        $heading1 .= " AM |Filter| ExpT |";
	$heading2 .= "----|------|------|";
	#             123456789+123456789+12345678

        # Seeing and ellipticity

        $heading1 .= "FWHM|Ellp|";
        $heading2 .= "----|----|";
	#             123456789+123456789+12345678

        # Skylevel and sky noise

        $heading1 .= "  Sky   |SkyRMS| Skybrt |";
        $heading2 .= "--------|------|--------|";
	#             123456789+123456789+12345678

        # Mag zeropoint and error

        $heading1 .= "MagZPT|MagZRR|";
        $heading2 .= "------|------|";
	#             123456789+123456789+12345678

        # WCS fit goodness and number of standards

        $heading1 .= "WCSRMS|N_WCS|Scale|";
        $heading2 .= "------|-----|-----|";
	#             123456789+123456789+12345678
        printf $log_fh "%s\n",$heading1;
        printf $log_fh "%s\n",$heading2;
    }

    # Get the info you need from the file

    my $status = 0;
    my $fptr = Astro::FITS::CFITSIO::open_file($outf,READONLY,$status);
    my ($hdu,$hdutype,$utstart,$rabase,$decbase,$airmass,$filter,$exptime);
    my ($status);
    $fptr->get_hdu_num($hdu);
    $fptr->movabs_hdu(1,$hdutype,$status);
    $fptr->read_key(TFLOAT,"UTSTART",$utstart,$junk,$status);
    $fptr->read_key(TFLOAT,"RABASE",$rabase,$junk,$status);
    $fptr->read_key(TFLOAT,"DECBASE",$decbase,$junk,$status);
    $fptr->read_key(TFLOAT,"AMSTART",$airmass,$junk,$status);
    $fptr->read_key(TSTRING,"FILTER",$filter,$junk,$status);
    $fptr->read_key(TFLOAT,"EXP_TIME",$exptime,$junk,$status);
    $fptr->movabs_hdu($hdu,$hdutype,$status);
    $fptr->close_file($status);

    # Reformat some of them

    $utstart = substr(sexigesimal($utstart,1),0,8);
    $rabase = sexigesimal($rabase,2);
    $decbase = sexigesimal($decbase,3);

    # Now write the results

    my $line = "";
    $line = sprintf("%-28s %8d %s %s %s %4.2f %-6s %6.2f %4.1f %4.2f %7.2f %6.2f %7.2f %6.2f %6.2f %6.2f %5d %5.2f",
		    $outf,$utdate,$utstart,$rabase,$decbase,$airmass,$filter,
		    $exptime,$DQC{'SEEING'},$DQC{'ELLIPTIC'},$DQC{'SKYLEVEL'},
		    $DQC{'SKYNOISE'},$skylevel,$DQC{'MAGZPT'},$DQC{'MAGZRR'},
                    $DQC{'STDCRMS'},$DQC{'NUMBRMS'},$scale);
    print $log_fh "$line\n";
    $log_fh->close;
}

sub sexigesimal {
    my ($inval,$type) = @_;
    my (@a,$retval);

    # Divide by 15 to get to hours for RA

    if ($type == 2) {
	$inval /= 15.0;
    }

    # Save the sign for DEC

    if ($type == 3) {
        if ($inval < 0) {
	    $sign = '-';
            $inval = abs($inval);
        } else {
            $sign = '+';
        } 
    } else {
        $sign = "";
    }

    # Do the conversion

    $a[0] = sprintf("%02d",int($inval));
    $inval = 60.0*($inval - $a[0]);
    $a[1] = sprintf("%02d",int($inval));
    $inval = 60.0*($inval - $a[1]);
    $a[2] = sprintf("%04.1f",$inval);
    $retval = $sign;
    $retval .= join ':',@a;
    return($retval);
}

sub seeing {
    my ($fname) = @_;

    plate_scale($fname);

    # Now scale the seeing DQC parameter

    $DQC{'SEEING'} *= $scale;
}

sub plate_scale {
    my ($fname) = @_;

    # Open the file and read the CD matrix. Keep the biggest one (absolute
    # value). Since the rotation is small this is probably just fine

    my $status = 0;
    my @cds = ('CD1_1','CD1_2','CD2_1','CD2_2');
    my $fptr = Astro::FITS::CFITSIO::open_file($fname,READONLY,$status);
    my @vals = ();
    my ($val,$junk);
    foreach my $kk (@cds) {
        $fptr->read_key(TFLOAT,$kk,$val,$junk,$status);
        push @vals,abs($val);
    }
    $scale = 3600.0*max(@vals);
    $fptr->close_file($status);

}    

sub write_dqc {
    my ($outd) = @_;
    my $kk;

    # Open the index file. See if it exists first...

    my $indfile = "index.dqc";
    my $newfile = (! -f $indfile);
    my $fh = new FileHandle;
    $fh->open(">>$indfile");
    if ($newfile) {
        my $line = "#" . join ' ',sort @alldqc;
        print $fh "$line\n";
    }

    # Now write the results out
    
    my @vars = map {sprintf "$DQC{$_}"} sort keys %DQC;
    print $fh "$outd @vars\n";
    close $fh;
}  

sub do_photom {
    my ($imagefile,$catfile) = @_;

    # Get a bit of information you need 

    my $status = 0;
    my $iptr = Astro::FITS::CFITSIO::open_file($imagefile,READONLY,$status);
    if ($status != 0) {
       fitserr($status,"Can't open file $imagefile\n");
       return(1);
    }
    my ($filter,$exposed,$airmass,$hdutype,$junk);
    $iptr->read_key(TSTRING,"FILTER",$filter,$junk,$status);
    if (! $filter || $status != 0) {
        print $msg_fh "Can't get filter information!\n";
	return(1);
    }
    $iptr->read_key(TFLOAT,"EXP_TIME",$exposed,$junk,$status);
    if ($status != 0) {
	print $msg_fh "No exposure time in header!\n";
	return(1);
    }
    $iptr->read_key(TFLOAT,"AMSTART",$airmass,$junk,$status);
    if ($status != 0) {
	print $msg_fh "No airmass in header. Setting to 1. Procede with caution!\n";
        $status = 0;
	$airmass = 1;
    }
    $DQC{'FILTER'} = $filter;
    $DQC{'AIRMASS'} = $airmass;
    $iptr->movabs_hdu(2,$hdutype,$status);
    $iptr->read_key(TFLOAT,"SKYLEVEL",$skylevel,$junk,$status);
    $iptr->close_file($status);
    my $photfile = $ENV{'ORAC_DATA_CAL'} . "/" . "photomdata.fit";
    
    # Do the photometry

    my ($retval,$errmsg);
    $retval = cir_photom([$imagefile],[$catfile],1,"cirphot.log",$filter,
			 $photfile,"amstart","exp_time","utdate",$errmsg);
    if ($retval != CIR_OK) {
	print $msg_fh "CIR_PHOTOM: Photometry failed: $errmsg\n";
        return(1);
    }

    # Now get some zero point information from the header of the image file
    # to add to the DQC list

    my $iptr = Astro::FITS::CFITSIO::open_file($imagefile,READONLY,$status);
    if ($status != 0) {
       fitserr($status,"Can't open file $imagefile\n");
       return(1);
    }
    my ($magzp,$magzrr,$extinct);
    $iptr->movabs_hdu(2,$hdutype,$status);
    $iptr->read_key(TFLOAT,"MAGZPT",$magzp,$junk,$status);
    $iptr->read_key(TFLOAT,"MAGZRR",$magzrr,$junk,$status);
    $iptr->read_key(TFLOAT,"EXTINCT",$extinct,$junk,$status);
    $iptr->close_file($status);
    if ($status != 0) {
	print $msg_fh "Photometric zeropoint info not found. DQC indexes rubbish\n";
    }

    # Work out sky level 

    my $cf = $skylevel/$exposed;
    $cf = 1.0 if ($cf < 1.0);
    $cf /= ($scale*$scale);
    my $fluxmag = 2.5*log10($cf);
    $skylevel = $magzp - $fluxmag - $extinct*($airmass - 1.0);
    $DQC{'SKYLEVEL_MAG'} = $skylevel;
    $DQC{'SKYLEVEL_JMAG'} = ($filter eq 'J' ? $skylevel : 0.0);

    # Tweak zero point to take sampling of interleaves into account

    $pixscale = int(0.4/$scale + 0.5);
    $DQC{'MAGZPT'} = $magzp - 5.0*log10($pixscale);
    $DQC{'MAGZPT_J'} = ($filter eq 'J' ? $DQC{'MAGZPT'} : 0.0);
    $DQC{'MAGZRR'} = $magzrr;
    printf $msg_fh "Photometry fit\n";
    printf $msg_fh "   Zeropoint: %g +/- %g\n",$magzp,$magzrr;
}


sub update_cat_wcs {
    my ($image,$cat) = @_;

    # Open the two input files.

    $status = 0;
    my $cptr = Astro::FITS::CFITSIO::open_file($cat,READWRITE,$status);
    if ($status != 0) {
	print $msg_fh "Catalogue $cat cannot be opened for WCS update\n";
	return(1);
    }
    my $iptr = Astro::FITS::CFITSIO::open_file($image,READONLY,$status);
    if ($status != 0) {
	$cptr->close_file($status);
	print $msg_fh "Image $image cannot be opened for WCS update of catalogue\n";
	return(1);
    }

    # Now, copy the WCS keywords over.

    my ($value,$comment);
    foreach my $kk (keys %wcsparms) {
	$status = 0;
        $iptr->read_key($wcsparms{$kk},$kk,$value,$comment,$status);
	$cptr->update_key($wcsparms{$kk},$kk,$value,$comment,$status);
    }

    # Close things up...

    $cptr->close_file($status);
    $iptr->close_file($status);
}

sub estar {
    my ($fname,$catalogue,$oractime) = @_;

    # Decide whether we even need to be here...

    my $rmtagent = gethdrval($fname,"RMTAGENT");
    my $agentid = gethdrval($fname,"AGENTID");
    if ($rmtagent eq 'ESTAR') {
        print $msg_fh "Doing eSTAR trigger.\n";
	if (! $agentid || $agentid =~ /none/i) {
	    print $msg_fh "ESTAR trigger with corresponding ID\n";
	    $agentid = 1;
	} else {
	    print $msg_fh "Processing ESTAR trigger with ID of $agentid\n";
	}
    } else {
	return;
    }

    # Load these in these here to help synch with primitive.

    require SOAP::Lite;
    require Digest::MD5;
    require URI;
    require HTTP::Cookies;

    # Hard-wired for the moment. Probably okay for now since we
    # should be checking for UKIRT domain. Probably do not want the
    # password in the shipped pipeline.
    
    my $host = "kauwa.ukirt.jach.hawaii.edu";
    my $port = 8080;
    my $user = "agent";
    my $password = "InterProcessCommunication";

    # Original comment from primitive.
    # -----------------------------------------------------------------------
    # Quick hack to send multiple messages on trigger, need both 'update' and
    # 'observation' messages. Brad, read carefully before making further changes.
    #
    # -- AALLAN (21-JUL-03)
    #
    # Note that there are two types of alert the ORAC-DR pipeline should
    # send to the eSTAR agent. An 'update' alert and an 'observation' alert.
    # An update alert is currently ignored by the agent, but should come at
    # the end of each observation frame, a 'observation' alert comes at the
    # end of all processing pointing to the final data products. For now
    # lets hardwire the sending of both alerts, after all we've just finished
    # a frame, and then (since the observation currently only consists of
    # a single frame) we need an update message to say that frame is done and
    # then immediately an observation message to say the observation is
    # done.
    # ------------------------------------------------------------------------

    # Create URI. Start with the date and time

    my $fits = "http://omp.jach.hawaii.edu/cgi-bin/staffworf.pl?ut=";
    $utdate =~ /(\d{4})(\d{2})(\d{2})\.(\d+)/;
    $fits .= sprintf("%s-%s-%s-",$1,$2,$3);
    my $res = $4;
    my $hour = int($res*24.0);
    $res -= $hour/24.0;
    my $minute = int($res*1440.0);
    $res -= $minute/1440.0;
    my $second = int($res*86400 + 0.5);
    $fits .= sprintf("%02d-%02d-%02d",$hour,$minute,$second);
    
    # Now the run number of the first image of the combined file. This can
    # be found by looking at the image name.

    $fname =~ /^(\s)\d{8}_(\d{5})(_.*?)\.fit$/;
    my $wfinstrum = $1;
    my $runno = $2 + 0;
    my $suffix = $3;
    $wfinstrum =~ tr/wxyz/1234/;
    $fits .= "&runnr=$runno";
    $fits .= "&inst=WFCAM$wfinstrum";
    $fits .= "&suffix=$suffix&group=1";

    # Create the query hash

    my %hash = (ID => $Frm->uhdr("ESTAR_ID"),
                FITS => $fits,
                Catalog => "file://" . $ENV{'ORAC_DATA_OUT'} . "/" . $catalogue,
		);
    my $endpoint = "http://" . $host . ":" . $port;
    my $uri = new URI($endpoint);

    # This is an inline version of Alasdair's make_cookie
    # routine from ESTAR

    my $cookie = $user . "::" . Digest::MD5::md5_hex( $password );
    $cookie =~ s/(.)/sprintf("%%%02x", ord($1))/ge;
    $cookie =~ s/%/%25/g;
    
    # end make_cookie

    # put the cookie in an object suitable for SOAP transport

    my $cookie_jar = HTTP::Cookies->new();
    $cookie_jar->set_cookie( 0, user => $cookie, '/', $uri->host(), $uri->port());

    # we are now going to connect to the SOAP agent

    my $soap = new SOAP::Lite();
    my $urn = "urn:/node_agent";

    $soap->uri($urn);
    $soap->proxy( $endpoint, cookie_jar => $cookie_jar );

    # UPDATE MESSAGE
    # --------------

    $hash{AlertType} = "update";

    print $msg_fh "Sending SOAP message:\n";
    for my $key (sort keys %hash) {
       print $msg_fh "        $key: $hash{$key}\n";
    }

    my $result;
    eval {$result = $soap->handle_data(%hash)};
    if ($@) {
        print $msg_fh "***Unable to handle SOAP request: $@\n";
	return;
    }

    # The result of the SOAP request.

    unless($result->fault()) {
        print $msg_fh "SOAP Result: " . $result->result() . "\n";
    } else {
        print $msg_fh "***SOAP Fault Code: " . $result->faultcode() . "\n";
        print $msg_fh "***SOAP Fault String: " . $result->faultstring() . "\n";
    }

    # OBSERVATION MESSAGE
    # -------------------

    $hash{AlertType} = "observation";

    print $msg_fh ("Sending SOAP message:\n");
    for my $key (sort keys %hash) {
        print $msg_fh "        $key: $hash{$key}\n";
    }

    eval {$result = $soap->handle_data(%hash)};
    if ($@) {
        print $msg_fh "***Unable to handle SOAP request: $@";
	return;
    }

    # The result of the SOAP request.

    unless($result->fault()) {
        print $msg_fh "SOAP Result: " . $result->result() . "\n";
    } else {
        print $msg_fh "***SOAP Fault Code: " . $result->faultcode() . "\n";
        print $msg_fh "***SOAP Fault String: " . $result->faultstring() . "\n";
    }
}

    
sub fitserr {
    my ($status,$msg) = @_;
    my ($ferr);

    my $i = Astro::FITS::CFITSIO::fits_get_errstatus($status,$ferr);
    print $msg_fh "$msg\n$ferr\n";
}

sub gethdrval {
    my ($fname,$keyword) = @_;

    my $status = 0;
    my ($value,$junk);
    my $fptr = Astro::FITS::CFITSIO::open_file($fname,READONLY,$status);
    $fptr->read_keyword($keyword,$value,$junk,$status);
    $fptr->close_file($status);
    return ("") if ($status != 0);
    $value =~ s/^'(.*?)\s*'$/$1/ if ($value =~ /'/);
    return($value);
}

sub min {
    my @list = @_;

    my $v = (sort {$a <=> $b} @list)[0];
    return($v);
}

sub max {
    my @list = @_;

    my $v = (sort {$a <=> $b} @list)[-1];
    return($v);
}

sub sum {
    my @list = @_;
 
    my $v = 0.0;
    foreach (@list) {
        $v += $_;
    }
    return($v);
}

sub deg2rad {
    my ($a) = @_;

    return($a/57.2957795);
}

sub log10 {
    my ($a) = @_;
    
    my $b = log($a)/log(10.0);
    return($b);
}
