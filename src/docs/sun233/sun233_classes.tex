\subsection{ORAC::Calib\label{ORAC::Calib}\index{ORAC::Calib}}


Base class for selecting calibration frames in ORAC-DR

\subsubsection*{SYNOPSIS\label{ORAC::Calib_SYNOPSIS}\index{ORAC::Calib!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Calib;
\end{verbatim}
\begin{verbatim}
  $Cal = new ORAC::Calib;
\end{verbatim}
\begin{verbatim}
  $dark = $Cal->dark;
  $Cal->dark("darkname");
\end{verbatim}
\begin{verbatim}
  $Cal->standard(undef);
  $standard = $Cal->standard;
  $bias = $Cal->bias;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Calib_DESCRIPTION}\index{ORAC::Calib!DESCRIPTION}}


This module provides the basic methods available to all ORAC::Calib
objects.  This class should be used for selecting calibration frames.



Unless specified otherwise, a calibration frame is selected by first,
the nearest reduced frame; second, explicit specification via the
-calib command line option (handled by the pipeline); third, by search
of the appropriate index file.



Note this version: Index files not implemented.

\subsubsection*{PUBLIC METHODS\label{ORAC::Calib_PUBLIC_METHODS}\index{ORAC::Calib!PUBLIC METHODS}}


The following methods are available in this class.

\paragraph*{Constructors\label{ORAC::Calib_Constructors}\index{ORAC::Calib!Constructors}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a ORAC::Calib object.
The object identifier is returned.

\begin{verbatim}
  $Cal = new ORAC::Calib;
\end{verbatim}
\end{description}
\paragraph*{Accessor Methods\label{ORAC::Calib_Accessor_Methods}\index{ORAC::Calib!Accessor Methods}}
\begin{description}

\item[{\textbf{arc}}] \mbox{}

Return (or set) the name of the current arc.

\begin{verbatim}
  $arc = $Cal->arc;
\end{verbatim}

\item[{\textbf{baseshift}}] \mbox{}

Determine the pixel indices of the base position to be used for the
current observation.  This allows for incorrect instrument apertures.
In theory a 0;0 offset should place a source at the base position.
This method returns a semicolon-separated doublet "x;y" string rather
than a particular file even though it uses an index file.  Semicolon
is used to avoid problems with command-line parsing.



Croaks if it was not possible to determine a valid base location
(usually indicating that a standard has not been observed).

\begin{verbatim}
  $base = $Cal->baseshift;
\end{verbatim}


The index file is queried every time (usually not a problem since the
index is cached in memory) unless the noupdate flag is true.



If the noupdate flag is set there is no verification that the base
location meets the specified rules (this is because the command-line
override uses a value rather than a file).



The index file must include a column named BASESHIFT.


\item[{\textbf{bias}}] \mbox{}

Return (or set) the name of the current bias.

\begin{verbatim}
  $bias = $Cal->bias;
\end{verbatim}

\item[{\textbf{dark}}] \mbox{}

Return (or set) the name of the current dark - 
checks suitability on return.


\item[{\textbf{flat}}] \mbox{}

Return (or set) the name of the current flat.

\begin{verbatim}
  $flat = $Cal->flat;
\end{verbatim}

\item[{\textbf{mask}}] \mbox{}

Return (or set) the name of the bad pixel mask

\begin{verbatim}
  $mask = $Cal->mask;
\end{verbatim}

\item[{\textbf{polrefang}}] \mbox{}

Determine the anti-clockwise angle of the first (X) axis to the
polarimeter reference direction.  This, in essence, is the angle in
degrees to correct the measured positional angles to their true
orientations, thereby allowing for instrumental misalignment.



Croaks if it was not possible to determine a valid angle.

\begin{verbatim}
  $angle = $Cal->polrefang;
\end{verbatim}


The index file is queried every time (usually not a problem since the
index is cached in memory) unless the noupdate flag is true.



If the noupdate flag is set there is no verification that the
polarisation reference angle meets the specified rules (this is because
the command-line override uses a value rather than a file).



The index file must include a column named POLREFANG.


\item[{\textbf{readnoise}}] \mbox{}

Determine the readnoise to be used for the current observation.
This method returns a number rather than a particular file even
though it uses an index file.



Croaks if it was not possible to determine a valid readnoise.
(usually indicating that ARRAY\_TESTS have not been reduced).

\begin{verbatim}
  $readnoise = $Cal->readnoise;
\end{verbatim}


The index file is queried every time (usually not a problem since there
are only a limited number of array tests per night and the index
is cached in memory) unless the noupdate flag is true.



If the noupdate flag is set there is no verification that the readnoise
meets the specified rules (this is because the command-line override
uses a value rather than a file).



The index file must include a column named READNOISE.


\item[{\textbf{referenceoffset}}] \mbox{}

Determine the pixel offsets of the reference pixel with respect to the
frame centre to be used for the current observation.  This allows for 
the source to be placed away from the centre avoiding defects and the
joins of quadrants.



This method returns a semicolon-separated doublet "x;y" string rather than
a particular file even though it uses an index file.  Semicolon is
used to avoid problems with command-line parsing.



In theory a 0;0 offset should place the reference position at the
centre of the frame.  When this is not the case because of say poor
co-ordinates of the source, or incorrect instrument apertures,
calibration baseshift may be used, which in essence, measures the
displacement of the reference position from nominal.



Croaks if it was not possible to determine a valid reference pixel.

\begin{verbatim}
  $shift = $Cal->referenceoffset;
\end{verbatim}


The index file is queried every time (usually not a problem since the
index is cached in memory) unless the noupdate flag is true.



If the noupdate flag is set there is no verification that the base
location meets the specified rules (this is because the command-line
override uses a value rather than a file).



The index file must include a column named REFERENCEOFFSET.


\item[{\textbf{rotation}}] \mbox{}

Return (or set) the name of the rotation transformation matrix

\begin{verbatim}
  $rotation = $Cal->rotation;
\end{verbatim}

\item[{\textbf{sky}}] \mbox{}

Return (or set) the name of the current "sky" frame


\item[{\textbf{skybrightness}}] \mbox{}

Determine the sky brightness to be used for the current observation.
This method returns a number rather than a particular file even though
it uses an index file.



Croaks if it was not possible to determine a valid sky brightness,
which usually indicates that photometric calculations have not been
made.

\begin{verbatim}
  $skybrightness = $Cal->skybrightness;
\end{verbatim}


The index file is queried every time unless the noupdate flag is true.



If the noupdate flag is set there is no verification that the sky
brightness meets the specified rules (this is because the command-line
override uses a value rather than a file).



The index file must include a column named SKY\_BRIGHTNESS.


\item[{\textbf{standard}}] \mbox{}

Return (or set) the name of the current standard.

\begin{verbatim}
  $standard = $Cal->standard;
\end{verbatim}

\item[{\textbf{zeropoint}}] \mbox{}

Determine the zeropoint to be used for the current observation.
This method returns a number rather than a particular file even
though it uses an index file.



Croaks if it was not possible to determine a valid zeropoint, which
usually indicating that an \_APHOT recipe was not run.

\begin{verbatim}
  $zeropoint = $Cal->zeropoint;
\end{verbatim}


The index file is queried every time unless the noupdate flag is true.



If the noupdate flag is set there is no verification that the
readnoise meets the specified rules (this is because the command-line
override uses a value rather than a file).



The index file must include a column named ZEROPOINT.


\item[{\textbf{arcname}}] \mbox{}

Return (or set) the name of the current arc---no checking.

\begin{verbatim}
  $arc = $Cal->arcname;
\end{verbatim}

\item[{\textbf{biasname}}] \mbox{}

Return (or set) the name of the current bias---no checking.

\begin{verbatim}
  $dark = $Cal->biasname;
\end{verbatim}

\item[{\textbf{darkname}}] \mbox{}

Return (or set) the name of the current dark--no checking.

\begin{verbatim}
  $dark = $Cal->darkname;
\end{verbatim}

\item[{\textbf{flatname}}] \mbox{}

Return (or set) the name of the current flat---no checking.

\begin{verbatim}
  $flat = $Cal->flatname;
\end{verbatim}

\item[{\textbf{skyname}}] \mbox{}

Return (or set) the name of the current sky frame---no checking.

\begin{verbatim}
  $dark = $Cal->skyname;
\end{verbatim}

\item[{\textbf{standardname}}] \mbox{}

Return (or set) the name of the current standard frame---no checking.

\begin{verbatim}
  $dark = $Cal->standardname;
\end{verbatim}

\item[{\textbf{baseshiftcache}}] \mbox{}

Cached value of the baseshift.  Only used when noupdate is in effect.


\item[{\textbf{polrefangcache}}] \mbox{}

Cached value of the angle to the polarisation reference direction.  Only
used when noupdate is in effect.


\item[{\textbf{readnoisecache}}] \mbox{}

Cached value of the readnoise.  Only used when noupdate is in effect.


\item[{\textbf{referenceoffsetcache}}] \mbox{}

Cached value of the referenceoffset.  Only used when noupdate is in effect.


\item[{\textbf{zeropointcache}}] \mbox{}

Cached value of the zeropoint.  Only used when noupdate is in effect.


\item[{\textbf{referenceoffsetcache}}] \mbox{}

Cached value of the referenceoffset.  Only used when noupdate is in effect.


\item[{\textbf{arcnoupdate}}] \mbox{}

Stops arc object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{baseshiftnoupdate}}] \mbox{}

Stops baseshift object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{biasnoupdate}}] \mbox{}

Stops bias object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{darknoupdate}}] \mbox{}

Stops dark object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{flatnoupdate}}] \mbox{}

Stops flat object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{polrefangnoupdate}}] \mbox{}

Stops polrefang object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{readnoisenoupdate}}] \mbox{}

Stops readnoise object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{referenceoffsetnoupdate}}] \mbox{}

Stops referenceoffset object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{skynoupdate}}] \mbox{}

Stops sky object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{skybrightnessnoupdate}}] \mbox{}

Stops sky brightness object from updating itself with more recent
data.



Used when using a command-line override to the pipeline.


\item[{\textbf{standardnoupdate}}] \mbox{}

Stops standard object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{zeropointnoupdate}}] \mbox{}

Stops zeropoint object from updating itself with more recent data.



Used when using a command-line override to the pipeline.


\item[{\textbf{arcindex}}] \mbox{}

Return (or set) the index object associated with the arc index file


\item[{\textbf{baseshiftindex}}] \mbox{}

Return (or set) the index object associated with the baseshift index file.


\item[{\textbf{biasindex}}] \mbox{}

Return (or set) the index object associated with the bias index file


\item[{\textbf{darkindex}}] \mbox{}

Return (or set) the index object associated with the dark index file


\item[{\textbf{flatindex}}] \mbox{}

Return (or set) the index object associated with the flat index file


\item[{\textbf{dqcindex}}] \mbox{}

Return (or set) the index object associated with the data quality
parameters index file.


\item[{\textbf{photindex}}] \mbox{}

Return (or set) the index object associated with the photmetric
information index file.


\item[{\textbf{polrefangindex}}] \mbox{}

Return (or set) the index object associated with the polrefang index file.
The index is static, therefore it resides in the calibration directory.


\item[{\textbf{readnoiseindex}}] \mbox{}

Return (or set) the index object associated with the readnoise index file.


\item[{\textbf{referenceoffsetindex}}] \mbox{}

Return (or set) the index object associated with the referenceoffset index file.


\item[{\textbf{skyindex}}] \mbox{}

Return (or set) the index object associated with the sky index file


\item[{\textbf{skybrightnessindex}}] \mbox{}

Return (or set) the index object associated with the sky brightness
index file.


\item[{\textbf{standardindex}}] \mbox{}

Return (or set) the index object associated with the standard index file


\item[{\textbf{zeropointindex}}] \mbox{}

Return (or set) the index object associated with the zeropoint index file.


\item[{\textbf{thing}}] \mbox{}

Returns the hash that can be used for checking the validity of
calibration frames. This is a combination of the two hashes
stored in \texttt{thingone} and \texttt{thingtwo}. The hash returned
by this method is readonly.

\begin{verbatim}
  $hdr = $Cal->thing;
\end{verbatim}

\item[{\textbf{thingone}}] \mbox{}

Returns or sets the hash associated with the header of the object
(frame or group or whatever) needed to match calibration criteria
against.



Ending sentences with a preposition is a bug.


\item[{\textbf{thingtwo}}] \mbox{}

Returns or sets the hash associated with the user defined header of
the object (frame or group or whatever) against which calibration
criteria are applied.

\end{description}
\paragraph*{General Methods\label{ORAC::Calib_General_Methods}\index{ORAC::Calib!General Methods}}
\begin{description}

\item[{\textbf{find\_file}}] \mbox{}

Returns the full path and filename of the requested file (the first
file found in the search path).

\begin{verbatim}
  $filename = $Cal->find_file("fs_izjhklm.dat");
\end{verbatim}


croaks if the file can not be found. It's likely that this is a bit
drastic but it will indicate something bad is going on before some
other unexpected behaviour occurs.  See
\textbf{ORAC::Inst::Defn::orac\_determine\_calibration\_search\_path} for
information on setting up calibration directories.


\item[{\textbf{retrieve\_by\_column}}] \mbox{}

Returns the value for the specified column in the specified index.

\begin{verbatim}
  $value = $Cal->retrieve_by_column( "readnoise", "ORACTIME" );
\end{verbatim}


The first argument is a queryable

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Calib_SEE_ALSO}\index{ORAC::Calib!SEE ALSO}}


\emph{ORAC::Group} and
\emph{ORAC::Frame}

\subsubsection*{REVISION\label{ORAC::Calib_REVISION}\index{ORAC::Calib!REVISION}}


\$Id: Calib.pm 7847 2008-05-23 23:20:59Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Calib_COPYRIGHT}\index{ORAC::Calib!COPYRIGHT}}


Copyright (C) 1998-2004 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Calib::SCUBA\label{ORAC::Calib::SCUBA}\index{ORAC::Calib::SCUBA}}


SCUBA calibration object

\subsubsection*{SYNOPSIS\label{ORAC::Calib::SCUBA_SYNOPSIS}\index{ORAC::Calib::SCUBA!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Calib::SCUBA;
\end{verbatim}
\begin{verbatim}
  $Cal = new ORAC::Calib::SCUBA;
\end{verbatim}
\begin{verbatim}
  $gain = $Cal->gain($filter);
  $tau  = $Cal->tau($filter);
  @badbols = $Cal->badbols;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Calib::SCUBA_DESCRIPTION}\index{ORAC::Calib::SCUBA!DESCRIPTION}}


This module returns (and can be used to set) calibration information
for SCUBA. SCUBA calibrations are used for extinction correction
(the sky opacity) and conversion of volts to Janskys.



It can also be used to set and retrieve lists of bad bolometers generated
by noise observations.



This class does inherit from \textbf{ORAC::Calib} although nearly all the
methods in the base class are irrelevant to SCUBA (this class only
uses the thing() method).

\subsubsection*{PUBLIC METHODS\label{ORAC::Calib::SCUBA_PUBLIC_METHODS}\index{ORAC::Calib::SCUBA!PUBLIC METHODS}}


The following methods are available in this class.
These are in addition to the methods inherited from \textbf{ORAC::Calib}.

\paragraph*{Constructor\label{ORAC::Calib::SCUBA_Constructor}\index{ORAC::Calib::SCUBA!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a ORAC::Calib::SCUBA object.
The object identifier is returned.

\begin{verbatim}
  $Cal = new ORAC::Calib::SCUBA;
\end{verbatim}
\end{description}
\paragraph*{Accessor Methods\label{ORAC::Calib::SCUBA_Accessor_Methods}\index{ORAC::Calib::SCUBA!Accessor Methods}}
\begin{description}

\item[{\textbf{badbols}}] \mbox{}

Set or retrieve the name of the system to be used for bad bolometer
determination. Allowed values are:

\begin{itemize}

\item index

Use an index file generated by noise observations
using the reflector blade. The bolometers stored in this
file are those that were above the noise threshold in 
the \_REDUCE\_NOISE\_ primitive. The index file is generated
by the \_REDUCE\_NOISE\_ primitive


\item file

Uses the contents of the file \emph{badbol.lis} (contains a space
separated list of bolometer names in the first line). This
file is in ORAC\_DATA\_OUT. If the file is not found, no
bolometers will be flagged.


\item 'list'

A colon-separated list of bolometer names can be supplied.
If badbols=h7:i12:g4,... then this list will be used
as the bad bolometers throughout the reduction.

\end{itemize}


Default is to use the 'file' method.
The value is always upper-cased.


\item[{\textbf{badbolsindex}}] \mbox{}

Return (or set) the index object associated with the bad bolometers
index file. This index file is used if badbols() is set to index.


\item[{\textbf{badbolsnoupdate}}] \mbox{}

Flag to prevent the badbols system from being modified during data
processing.


\item[{\textbf{engine\_launch\_object}}] \mbox{}

Returns the \texttt{ORAC::Msg::EngineLaunch} object that can be used
to initialise message systems as required by the particular
algorithm engines.

\begin{verbatim}
 $engobj = $self->engine_launch_object;
\end{verbatim}

\item[{\textbf{fluxes\_mon}}] \mbox{}

Retrieves the algorithm engine object associated with
the Starlink fluxes monolith.



A new object is created if the value is undefined.



Relies on the Adam messaging system being available.
ADAM messaging will be initialised if not present.


\item[{\textbf{gains}}] \mbox{}

Determines whether gains are derived from the default values
(DEFAULT) or from the index files (INDEX). Default is to
use the default gains. The value is upper-cased.


\item[{\textbf{gainsindex}}] \mbox{}

Return (or set) the index object associated with the gains
index file. This index file is used if gains() is set to INDEX.


\item[{\textbf{gainsnoupdate}}] \mbox{}

Flag to prevent the gains selection from being modified during data
processing.


\item[{\textbf{skydipindex}}] \mbox{}

Return (or set) the index object associated with the skydip
index file. This index file is used if tausys() is set to skydip.


\item[{\textbf{tausys}}] \mbox{}

Set (or retrieve) the name of the system to be used for
tau determination. Allowed values are 'CSO', 'SKYDIP',
'850SKYDIP' or a number. Currently the number is assumed to be the 
CSO tau since this number is independent of wavelength.
'INDEX' is an allowed synonym for 'SKYDIP'. '850SKYDIP'
mode uses the results of 850 micron skydips from index
files to derive the opacity for the requested wavelength.



Additionally, modes 'DIPINTERP' and '850DIPINTERP' can be 
used to interpolate the current tau from skydips taken
either side of the current observation.



Currently there is no way to specify an actual 850 micron
tau value (the number is treated as a CSO value). In the future
this may change (or a tausys of 850=value will be used??)



If tausys has not been set it defaults to '850SKYDIP'


\item[{\textbf{tausysnoupdate}}] \mbox{}

Flag to prevent the tau system from being modified during data
processing.


\item[{\textbf{taucache}}] \mbox{}

Internal cache providing access to previously calculated tau values.
This is a reference to a hash of hashes with keys of uppercased
\texttt{tausys()}, ORACTIME and filter name.

\begin{verbatim}
 $cacheref = $Cal->taucache;
\end{verbatim}
\begin{verbatim}
 $tau = $Cal->taucache->{TAUSYS}->{'19980515.453'}->{$filter};
\end{verbatim}


Returns a hash reference.


\item[{\textbf{csofit}}] \mbox{}

Object containing all the tau fitting information.
The object is configured the first time the information
is requested. The fitting data are located in
\texttt{ORAC\_DATA\_CAL/csofit.dat}

\end{description}
\paragraph*{General methods\label{ORAC::Calib::SCUBA_General_methods}\index{ORAC::Calib::SCUBA!General methods}}
\begin{description}

\item[{\textbf{badbol\_list}}] \mbox{}

Returns list of bolometer names that should be turned off for the
current observation. The source of this list depends on the setting
of the badbols() parameter (controlled by the user).
Can be one of 'index', 'file' or actual bolometer list. See the
badbols() method documentation for more information.


\item[{\textbf{fluxcal}}] \mbox{}

Return the flux of a calibrator source

\begin{verbatim}
  $flux = $Cal->fluxcal("sourcename", "filter", $ismap);
\end{verbatim}


The optional third argument is used to specify whether a map
flux (ie total integrated flux) is required (true), or 
simply a flux in beam (used for photometry). Default is to
return flux in beam. This should return the same answer if the
calibrator is a point source.



Currently, all secondary calibrators are assumed to be point like.



Returns undef if the flux could not be determined.


\item[{\textbf{gain}}] \mbox{}

Method to return the current gain (aka 'flux conversion factor') 
for the specified filter that is usable for the current frame.



\texttt{undef} is returned if no gain can be determined.

\begin{verbatim}
  $gain = $Cal->gain($filter, $units);
\end{verbatim}


The units must be either BEAM (for Jy/beam/V) or ARCSEC (for
Jy/arcsec**2/V). If no units are supplied the default is BEAM.



If gains() is set to DEFAULT then this method will simply return
the current canonical gain for this filter (first trying a specific
filter [eg \texttt{450w}] then trying a generic filter name [eg \texttt{450}]).
This value will not take into account observing mode (eg scan map
gain is lower than jiggle map gain).



If gains() is set to INDEX the index will be searched for a calibration
observation that matches the observation mode (ie Chop throw, sample
mode, observing mode agree).



The current index system refuses to continue if a calibration can
not be found. In future this may well be changed so that the
DEFAULT values are used if no calibration is available.



It may also be useful if the gains either side of current observation
are retrieved so that the gain can be interpolated (as for tau
calculation).


\item[{\textbf{iscalsource}}] \mbox{}

Given the source name and filter, work out whether we have calibration
information on this source (ie we know the flux for this filter). If
information is availble return true (1) else return (0).

\begin{verbatim}
  $yesno = $Cal->iscalsource("source_name","filter");
\end{verbatim}


If filter is not supplied, it is assumed we are simply asking
whether the source is a calibrator independent of whether we
actually have a calibration value for it....


\item[{\textbf{tau}}] \mbox{}

Returns the tau associated with the supplied filter.

\begin{verbatim}
  $tau = $Cal->tau($filter);
\end{verbatim}


This routine works as follows. First tausys() is queried to determine
the system to use to calculate the tau. If this is CSO, the current
frame is queried for the CSO tau value stored and the tau calculated
for FILTER. If tausys() returns a number it is assumed
to be the actual CSO tau to use. If it is set to Skydip (or index) then
the selected wavelength is updated in the frame header (Key=FILTER)
and the skydip index is queried for the skydip that matched the criterion
and is closest in time.



The tausys='850SKYDIP' mode uses the results of 850 micron skydips
from index files to derive the opacity for the requested wavelength.



Additionally, modes 'DIPINTERP' and '850DIPINTERP' can be used to
interpolate the current tau from skydips taken either side of the
current observation.



The skydip modes will default to using CSO if a suitable
skydip can not be found. Also, a warning is raised if a skydip
is found but was takan more than 3 hours before or after the
current observation.



undef is returned if an error occurred [eg the CSO is so high that the
tau can not be calculated using the linear relationship].



The value is cached for a given tausys and observation (ORACTIME is
used for uniqueness) to prevent delays in searching for a tau when the
observation has not changed. It is very unlikely that a tau calibration
will change during a data reduction of a single frame (and, in reality
it is required that if you use a particular tau for extinction correction
that you can retrieve the exact same tau that was used at a later date).
The tau value is not cached if it can not be determined.

\end{description}
\paragraph*{Destructor\label{ORAC::Calib::SCUBA_Destructor}\index{ORAC::Calib::SCUBA!Destructor}}
\begin{description}

\item[{\textbf{DESTROY}}] \mbox{}

Removes any directories that may have been created by this
calibration class (eg by starting fluxes).



Currently does nothing.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Calib::SCUBA_SEE_ALSO}\index{ORAC::Calib::SCUBA!SEE ALSO}}


\emph{ORAC::Calib}

\subsubsection*{REVISION\label{ORAC::Calib::SCUBA_REVISION}\index{ORAC::Calib::SCUBA!REVISION}}


\$Id: SCUBA.pm 7300 2007-12-29 00:54:19Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Calib::SCUBA_COPYRIGHT}\index{ORAC::Calib::SCUBA!COPYRIGHT}}


Copyright (C) 1998-2005 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Constants\label{ORAC::Constants}\index{ORAC::Constants}}


Constants available to the ORAC system

\subsubsection*{SYNOPSIS\label{ORAC::Constants_SYNOPSIS}\index{ORAC::Constants!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Constants;
  use ORAC::Constants qw/ORAC__OK/;
  use ORAC::Constants qw/:status/;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Constants_DESCRIPTION}\index{ORAC::Constants!DESCRIPTION}}


Provide access to ORAC constants, necessary to use this module if you wish
to return an ORAC\_\_ABORT or ORAC\_\_FATAL status using ORAC::Error.

\subsubsection*{CONSTANTS\label{ORAC::Constants_CONSTANTS}\index{ORAC::Constants!CONSTANTS}}


The following constants are available from this module:

\begin{description}

\item[{\textbf{ORAC\_\_OK}}] \mbox{}

This constant contains the definition of good ORAC status.


\item[{\textbf{ORAC\_\_ERROR}}] \mbox{}

This constant contains the definition of bad ORAC status.


\item[{\textbf{ORAC\_\_BADENG}}] \mbox{}

An algorithm engine has returned with a status that indicates
that the engine is no longer valid. This can be used to
indicate that an engine has crashed and that a new one should be
launched.


\item[{\textbf{ORAC\_\_ABORT}}] \mbox{}

This constant contains the definition a user aborted ORAC process


\item[{\textbf{ORAC\_\_FATAL}}] \mbox{}

This constant contains the definition an ORAC process which has died fatally


\item[{\textbf{ORAC\_\_PARSE\_ERROR}}] \mbox{}

This constant contains the definition of an error in parsing a recipe.


\item[{\textbf{ORAC\_\_TERM}}] \mbox{}

This constant denotes that a recipe was terminated early, but without
error.

\end{description}
\subsubsection*{TAGS\label{ORAC::Constants_TAGS}\index{ORAC::Constants!TAGS}}


Individual sets of constants can be imported by 
including the module with tags. For example:

\begin{verbatim}
  use ORAC::Constants qw/:status/;
\end{verbatim}


will import all constants associated with ORAC status checking.



The available tags are:

\begin{description}

\item[{:status}] \mbox{}

Constants associated with ORAC status checking: ORAC\_\_OK and ORAC\_\_ERROR.

\end{description}
\subsubsection*{USAGE\label{ORAC::Constants_USAGE}\index{ORAC::Constants!USAGE}}


The constants can be used as if they are subroutines.
For example, if I want to print the value of ORAC\_\_ERROR I can

\begin{verbatim}
  use ORAC::Constants;
  print ORAC__ERROR;
\end{verbatim}


or

\begin{verbatim}
  use ORAC::Constants ();
  print ORAC::Constants::ORAC__ERROR;
\end{verbatim}
\subsubsection*{SEE ALSO\label{ORAC::Constants_SEE_ALSO}\index{ORAC::Constants!SEE ALSO}}


\emph{constants}

\subsubsection*{REVISION\label{ORAC::Constants_REVISION}\index{ORAC::Constants!REVISION}}


\$Id: Constants.pm 7997 2008-06-25 02:08:47Z bradc \$

\subsubsection*{AUTHOR\label{ORAC::Constants_AUTHOR}\index{ORAC::Constants!AUTHOR}}


Tim Jenness $<$t.jenness@jach.hawaii.edu$>$ and
Frossie Economou $<$frossie@jach.hawaii.edu$>$

\subsubsection*{REQUIREMENTS\label{ORAC::Constants_REQUIREMENTS}\index{ORAC::Constants!REQUIREMENTS}}


The \texttt{constants} package must be available. This is a standard
perl package.

\subsubsection*{COPYRIGHT\label{ORAC::Constants_COPYRIGHT}\index{ORAC::Constants!COPYRIGHT}}


Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Display\label{ORAC::Display}\index{ORAC::Display}}


Top level interface to ORAC display tools

\subsubsection*{SYNOPSIS\label{ORAC::Display_SYNOPSIS}\index{ORAC::Display!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Display;
\end{verbatim}
\begin{verbatim}
  $Display = new ORAC::Display;
  $Display->usenbs(1);
  $Display->filename(filename);
  $Display->display_data('frame/group object');
  $Display->display_data('frame/group object',{WINDOW=>1});
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Display_DESCRIPTION}\index{ORAC::Display!DESCRIPTION}}


This module provides an OO-interface to the ORAC display manager.  The
display object reads device information from a file or notice board
(shared memory) [NBS not implemented], determines whether the supplied
frame object matches the criterion for display, if it does it
instructs the relevant device object to send to the selected window
(creating a new device object if necessary)

\subsubsection*{PUBLIC METHODS\label{ORAC::Display_PUBLIC_METHODS}\index{ORAC::Display!PUBLIC METHODS}}
\paragraph*{Constructor\label{ORAC::Display_Constructor}\index{ORAC::Display!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of \textbf{ORAC::Display}. No arguments are
required.

\begin{verbatim}
  $Display = new ORAC::Display;
\end{verbatim}
\end{description}
\subsubsection*{Accessor Methods\label{ORAC::Display_Accessor_Methods}\index{ORAC::Display!Accessor Methods}}
\begin{description}

\item[{\textbf{display\_tools}}] \mbox{}

Returns (or sets) a hash containing the current lookup of display tool
to display tool object. For example:

\begin{verbatim}
   $Display->display_tools(%tools);
   %tools = $Display->display_tools;
\end{verbatim}


where \%tools could look like:

\begin{verbatim}
     'GAIA' => Display::GAIA=HASH(object),
     'P4'   => Display::P4=HASH(object)
\end{verbatim}


etc. The current contents are overwritten when a new hash is supplied.



When called from an array context, returns the full hash contents.
When called from a scalar context, returns the reference to the hash.


\item[{\textbf{filename}}] \mbox{}

Set (or retrieve) the name of the file containing the display device
definition. Only used when usenbs() is false.

\begin{verbatim}
  $file = $Display->file;
  $Display->file("new_file");
\end{verbatim}

\item[{\textbf{idstring}}] \mbox{}

Set (or retrieve) the value of the string used for comparison
with the display device definition information (created by the
separate device allocation GUI).

\begin{verbatim}
  $Display->idstring($id);
  $id = $Display->idstring;
\end{verbatim}

\item[{\textbf{usenbs}}] \mbox{}

Determine whether NBS (shared memory) should be used to read the
display device definition. Default is false.

\begin{verbatim}
  $usenbs = $Display->usenbs;
  $Display->usenbs(0);
\end{verbatim}

\item[{\textbf{is\_master}}] \mbox{}

Returns true if this object is driving a display, false if this object is monitoring
a display.


\item[{\textbf{monitor\_handle}}] \mbox{}

File handle associated with monitor file. Will be created if
necessary.  If this is the master, the file is opened for write
(thereby removing any existing file). If this is a monitor the file is
opened for read.

\begin{verbatim}
  $hdl = $display->monitor_handle;
\end{verbatim}


It is non-fatal for the monitor to fail to open a file since this usually
indicates that the master pipeline is not enabling monitoring.


\item[{\textbf{does\_master\_display}}] \mbox{}

Controls whether the master display object is doing local displaying of data
itself (true) or whether it is simply sending information to a monitor (false).
Default is true.

\end{description}
\paragraph*{General Methods\label{ORAC::Display_General_Methods}\index{ORAC::Display!General Methods}}
\begin{description}

\item[{\textbf{definition}}] \mbox{}

Method to read a display definition, compare it with the idstring 
stored in the object (this is usually a file suffix)
and return back an array of  hashes containing all the relevant entries
from the definition. If an argument is given, the object updates
its definition of current idstring (and then searches).

\begin{verbatim}
   @defn = $display->definition;
   @defn = $display->definition($id);
\end{verbatim}


An empty array is returned if the suffix can not be matched.


\item[{\textbf{display\_data}}] \mbox{}

This is the main method to be used for displaying data.  The supplied
object must contain a method for determining the filename and the
display ID (so that it can be compared with the information stored in
the device definition file). It should support the file(), nfiles()
and gui\_id() methods.



The optional hash can be used to supply extra entries in the
display definition file (or in fact do away with the definition file
completely). Note that the contents of the options hash will be used
even if no display definition can be found to match the current 
gui\_id.

\begin{verbatim}
  $Display->display_data($Frm) if defined $Display;
  $Display->display_data($Frm, { TOOL => 'GAIA'});
  $Display->display_data($Frm, { TOOL => 'GAIA'}, $usedisp);
\end{verbatim}


A third optional argument can be used in conjunction with the
options hash to indicate whether these options should be used
instead of the display definition file (false) or in addition
to (true - the default)


\item[{\textbf{parse\_nbs\_defn}}] \mbox{}

Using the current idstring, read the relevant information from
a noticeboard and return it in a hash. This routine takes no
arguments (idstring is read from the object) and should only
be used if the usenbs() flag is true.

\begin{verbatim}
  %defn = $self->parse_nbs_defn;
\end{verbatim}


Currently not implemented.


\item[{\textbf{parse\_file\_defn}}] \mbox{}

Using the current idstring, read the relevant information from
the text file (name stored in filename()) and return it in an array
of  hashes. There will be one hash per entry in the file that
matches the given suffix.
This routine takes no arguments (idstring is read from the object).



The input file is assumed to contain one line per ID of the following
format:

\begin{verbatim}
  ID  key=value key=value key=value..........\n
\end{verbatim}

\item[{\textbf{append\_monitor}}] \mbox{}

Write information to a file that can be read by monitor processes. This allows the
display system to be separated from the actual tools doing the displaying or for
a clone display system to enable more than one person to view pipeline output.

\begin{verbatim}
  $display->append_monitor( $Frm, \%options, $usedisp );
\end{verbatim}


Does nothing if this object is monitoring.


\item[{\textbf{process\_monitor\_request}}] \mbox{}

Given a line of text matching that written by the \texttt{append\_monitor} method,
trigger the display system accordingly by calling the \texttt{display\_data} method.

\begin{verbatim}
  $Display->process_monitor_request( $line );
\end{verbatim}


No-op if the Display is configured as a master.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Display_SEE_ALSO}\index{ORAC::Display!SEE ALSO}}


Related ORAC display devices (eg \emph{ORAC::Display::KAPVIEW})

\subsubsection*{REVISION\label{ORAC::Display_REVISION}\index{ORAC::Display!REVISION}}


\$Id: Display.pm 7702 2008-05-06 21:34:57Z bradc \$

\subsubsection*{COPYRIGHT\label{ORAC::Display_COPYRIGHT}\index{ORAC::Display!COPYRIGHT}}


Copyright (C) 2007 Science and Technology Facilities Council.
Copyright (C) 1998-2004 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Frame\label{ORAC::Frame}\index{ORAC::Frame}}


Base class for dealing with observation frames in ORAC-DR

\subsubsection*{SYNOPSIS\label{ORAC::Frame_SYNOPSIS}\index{ORAC::Frame!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Frame;
\end{verbatim}
\begin{verbatim}
  $Frm = new ORAC::Frame("filename");
  $Frm->file("prefix_flat");
  $num = $Frm->number;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Frame_DESCRIPTION}\index{ORAC::Frame!DESCRIPTION}}


This module provides the basic methods available to all \textbf{ORAC::Frame}
objects. This class should be used when dealing with individual
observation files (frames).

\subsubsection*{PUBLIC METHODS\label{ORAC::Frame_PUBLIC_METHODS}\index{ORAC::Frame!PUBLIC METHODS}}


The following methods are available in this class:

\paragraph*{Constructors\label{ORAC::Frame_Constructors}\index{ORAC::Frame!Constructors}}


The following constructors are available:

\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a \textbf{ORAC::Frame} object.  This method also
takes optional arguments: if 1 argument is supplied it is assumed to
be the name of the raw file associated with the observation.  If 2
arguments are supplied they are assumed to be the raw file prefix and
observation number.  In any case, all arguments are passed to the
configure() method which is run in addition to new() when arguments
are supplied.  The object identifier is returned.

\begin{verbatim}
   $Frm = new ORAC::Frame;
   $Frm = new ORAC::Frame("file_name");
   $Frm = new ORAC::Frame("UT", "number");
\end{verbatim}


The base class constructor should be invoked by sub-class constructors.
If this method is called with the last argument as a reference to
a hash it is assumed that this hash contains extra configuration
information ('instance' information) supplied by sub-classes.



Note that the file format expected by this constructor is actually the
required format of the data (as returned by \texttt{format()} method) and not
necessarily the raw format.  ORAC-DR will pre-process the data with
\texttt{ORAC::Convert} prior to passing it to this constructor.


\item[{\textbf{framegroup}}] \mbox{}

Create new instances of objects (of this class) from multiple
input files.

\begin{verbatim}
  @frames = ORAC::Frame->framegroup( @files );
\end{verbatim}


In most cases this is identical to simply passing the files directly
to the constructor. In some subclasses, files from the same
observation will be grouped into multiple file objects and processed
independently.



Note that framegroup() accepts multiple filenames in a list, as opposed
to the frame constructors that only take single files or reference to
an array.



If the \texttt{framegroupkeys} method returns a list, those keys
are used as FITS headers that should be used to group the input
files.

\paragraph*{Accessor Methods\label{ORAC::Frame_Accessor_Methods}\index{ORAC::Frame!Accessor Methods}}


The following methods are available for accessing the 
'instance' data.

\begin{description}

\item[{\textbf{group}}] \mbox{}

This method returns the group name associated with the observation.

\begin{verbatim}
  $group_name = $Frm->group;
  $Frm->group("group");
\end{verbatim}


This can be configured initially using the findgroup() method.
Alternatively, findgroup() is run automatically by the configure()
method.


\item[{\textbf{framegroupkeys}}] \mbox{}

Returns the FITS header keys that should be used to group
files into distinct Frame objects. Used by the \texttt{framegroup}
method to determine grouping.



Returns empty list in the base class.


\item[{\textbf{is\_frame}}] \mbox{}

Whether or not the current object is an ORAC::Frame object.

\begin{verbatim}
  $is_frame = $self->is_frame;
\end{verbatim}


Returns 1.


\item[{\textbf{isgood}}] \mbox{}

Flag to determine the current state of the frame. If isgood() is true
the Frame is valid. If it returns false the frame object may have a
problem (eg the recipe responsible for processing the frame failed to
complete).



This flag is used by the \textbf{ORAC::Group} class to determine membership.


\item[{\textbf{nsubs}}] \mbox{}

Return the number of sub-frames associated with this frame.



nfiles() should be used to return the current number of sub-frames
associated with the frame (nsubs usually only reports the number given
in the header and may or may not be the same as the number of
sub-frames currently stored)



Usually this value is set as part of the configure() method from the
header (using findnsubs()) or by using findnsubs() directly.


\item[{\textbf{rawfixedpart}}] \mbox{}

Return (or set) the constant part of the raw filename associated
with the raw data file. (ie the bit that stays fixed for every 
observation)

\begin{verbatim}
  $fixed = $self->rawfixedpart;
\end{verbatim}

\item[{\textbf{rawformat}}] \mbox{}

Data format associated with the raw() data file.
Usually one of 'NDF', 'HDS' or 'FITS'. This format should be
recognisable by \texttt{ORAC::Convert}.


\item[{\textbf{rawsuffix}}] \mbox{}

Return (or set) the file name suffix associated with
the raw data file.

\begin{verbatim}
  $suffix = $self->rawsuffix;
\end{verbatim}

\item[{\textbf{recipe}}] \mbox{}

This method returns the recipe name associated with the observation.
The recipe name can be set explicitly but in general should be
set by the findrecipe() method.

\begin{verbatim}
  $recipe_name = $Frm->recipe;
  $Frm->recipe("recipe");
\end{verbatim}


This can be configured initially using the findrecipe() method.
Alternatively, findrecipe() is run automatically by the configure()
method.


\item[{\textbf{tempraw}}] \mbox{}

An array of flags, one per raw file, indicating whether the raw
file is temporary, and so can be deleted, or real data (don't want
to delete it).

\begin{verbatim}
  $Frm->tempraw( @istemp );
  @istemp = $Frm->tempraw;
\end{verbatim}


If a single value is given, it will be applied to all raw files

\begin{verbatim}
  $Frm->tempraw( 1 );
\end{verbatim}


In scalar context returns true if all frames are temporary,
false if all frames are permanent and undef if some frames are temporary
whilst others are permanent.

\begin{verbatim}
  $alltemp = $Frm->tempraw();
\end{verbatim}
\end{description}
\paragraph*{General Methods\label{ORAC::Frame_General_Methods}\index{ORAC::Frame!General Methods}}


The following methods are provided for manipulating
\textbf{ORAC::Frame} objects:

\begin{description}

\item[{\textbf{configure}}] \mbox{}

This method is used to configure the object. It is invoked	 
automatically if the new() method is invoked with an argument. The	 
file(), raw(), readhdr(), findgroup(), findrecipe and findnsubs()	 
methods are invoked by this command. Arguments are required.  If there	 
is one argument it is assumed that this is the raw filename. If there	 
are two arguments the filename is constructed assuming that argument 1	 
is the prefix and argument 2 is the observation number.

\begin{verbatim}
  $Frm->configure("fname");      
  $Frm->configure("UT","num");
\end{verbatim}


Multiple raw file names can be provided in the first argument using	 
a reference to an array.


\item[{\textbf{data\_detection\_tasks}}] \mbox{}

When the 'task' looping scheme is enabled, this method returns the name
of the remote task that should be queried for new data. These task names
must be registered with the \texttt{ORAC::Inst::Defn} module.

\begin{verbatim}
  @tasks = $Frm->data_detection_tasks();
\end{verbatim}


Returns an empty list in the base class.


\item[{\textbf{erase}}] \mbox{}

Erase the current file from disk.

\begin{verbatim}
  $Frm->erase($i);
\end{verbatim}


The optional argument specified the file number to be erased.
The argument is identical to that given to the file() method.
Returns ORAC\_\_OK if successful, ORAC\_\_ERROR otherwise.



Note that the file() method is not modified to reflect the
fact the the file associated with it has been removed from disk.



This method is usually called automatically when the file()
method is used to update the current filename and the nokeep()
flag is set to true. In this way, temporary files can be removed
without explicit use of the erase() method. (Just need to
use the nokeep() method after the file() method has been used
to update the current filename).


\item[{\textbf{file\_exists}}] \mbox{}

Method to determine whether the Frame file() exists on disk or not.
Returns true if the file is there, false otherwise. Effectively
equivalent to using \texttt{-e} but allows for the possibility that the
information stored in file() does not directly relate to the
file as stored on disk (e.g. a .sdf extension). The base class is
very simplistic (ie does not assume extensions).

\begin{verbatim}
  $exists = $Frm->file_exists($i)
\end{verbatim}


The optional argument refers to the file number.


\item[{\textbf{file\_from\_bits}}] \mbox{}

Determine the raw data filename given the variable component
parts. A prefix (usually UT) and observation number should
be supplied.

\begin{verbatim}
  $fname = $Frm->file_from_bits($prefix, $obsnum);
\end{verbatim}

\item[{\textbf{findgroup}}] \mbox{}

Returns group name from header.  If we cannot find anything sensible,
we return 0.  The group name stored in the object is automatically
updated using this value.


\item[{\textbf{findnsubs}}] \mbox{}

Find the number of sub-frames associated with the frame by looking in
the header. Usually run by configure().



In the base class this method looks for a header keyword of 'NSUBS'.

\begin{verbatim}
  $nsubs = $Frm->findnsubs;
\end{verbatim}


The state of the object is updated automatically.


\item[{\textbf{findrecipe}}] \mbox{}

Method to determine the recipe name that should be used to reduce the
observation.  The default method is to look for an "ORAC\_DR\_RECIPE" entry
in the user header. If one cannot be found, we assume QUICK\_LOOK.

\begin{verbatim}
  $recipe = $Frm->findrecipe;
\end{verbatim}


The object is automatically updated to reflect this recipe.


\item[{\textbf{flag\_from\_bits}}] \mbox{}

Determine the name of the flag file given the variable
component parts. A prefix (usually UT) and observation number
should be supplied

\begin{verbatim}
  $flag = $Frm->flag_from_bits($prefix, $obsnum);
\end{verbatim}


This method should be implemented by a sub-class.


\item[{\textbf{number}}] \mbox{}

Method to return the number of the observation. The number is
determined by looking for a number at the end of the raw data
filename.  For example a number can be extracted from strings of the
form textNNNN.sdf or textNNNN, where NNNN is a number (leading zeroes
are stripped) but not textNNNNtext (number must be followed by a decimal
point or nothing at all).

\begin{verbatim}
  $number = $Frm->number;
\end{verbatim}


The return value is -1 if no number can be determined.



As an aside, an alternative approach for this method (especially
in a sub-class) would be to read the number from the header.


\item[{\textbf{pattern\_from\_bits}}] \mbox{}

Determine the pattern for the raw filename given the variable component
parts. A prefix (usually UT) and observation number should
be supplied.

\begin{verbatim}
  $pattern = $Frm->pattern_from_bits($prefix, $obsnum);
\end{verbatim}


Returns a regular expression object.


\item[{\textbf{template}}] \mbox{}

Method to change the current filename of the frame (file())
so that it matches a template. e.g.:

\begin{verbatim}
  $Frm->template("something_number_flat");
\end{verbatim}


Would change the first file to match "something\_number\_flat".
Essentially this simply means that the number in the template
is changed to the number of the current frame object.

\begin{verbatim}
  $Frm->template("something_number_dark", 2);
\end{verbatim}


would change the second filename to match "something\_number\_dark".
The base method assumes that the filename matches the form:
prefix\_number\_suffix. This must be modified by the derived
classes since in general the filenaming convention is telescope
and instrument specific.



The Nth filename is modified (ie file(N)).
There are no return arguments.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Frame_SEE_ALSO}\index{ORAC::Frame!SEE ALSO}}


\emph{ORAC::Group}

\subsubsection*{REVISION\label{ORAC::Frame_REVISION}\index{ORAC::Frame!REVISION}}


\$Id: Frame.pm 7993 2008-06-24 23:46:17Z bradc \$

\subsubsection*{COPYRIGHT\label{ORAC::Frame_COPYRIGHT}\index{ORAC::Frame!COPYRIGHT}}


Copyright (C) 1998-2007 Particle Physics and Astronomy Research
Council. All Rights Reserved.



Copyright (C) 2007 Science and Technology Facilities Council.  All
Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Frame::NDF\label{ORAC::Frame::NDF}\index{ORAC::Frame::NDF}}


Class for dealing with frames based on NDF files

\subsubsection*{SYNOPSIS\label{ORAC::Frame::NDF_SYNOPSIS}\index{ORAC::Frame::NDF!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Frame::NDF
\end{verbatim}
\begin{verbatim}
  $Frm = new ORAC::Frame::NDF;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Frame::NDF_DESCRIPTION}\index{ORAC::Frame::NDF!DESCRIPTION}}


This class provides implementations of the methods that require
knowledge of the NDF file format rather than generic methods or
methods that require knowledge of a specific instrument.  In general,
the specific instrument sub-classes will inherit from the file type
(which inherits from ORAC::Frame) rather than directly from
ORAC::Frame. For JCMT and UKIRT the group files are based on NDFs and
inherit from this class.



The format specific sub-classes do not contain constructors; they 
should be defined in either the base class or the instrument specific
sub-class.

\subsubsection*{PUBLIC METHODS\label{ORAC::Frame::NDF_PUBLIC_METHODS}\index{ORAC::Frame::NDF!PUBLIC METHODS}}


The following methods are modified from the base class versions.

\paragraph*{General Methods\label{ORAC::Frame::NDF_General_Methods}\index{ORAC::Frame::NDF!General Methods}}
\begin{description}

\item[{\textbf{erase}}] \mbox{}

Erase the current file from disk.

\begin{verbatim}
  $Frm->erase($i);
\end{verbatim}


The optional argument specifies the file number to be erased.
The argument is identical to that given to the file() method.
Returns ORAC\_\_OK if successful, ORAC\_\_ERROR otherwise.



Note that the file() method is not modified to reflect the
fact the the file associated with it has been removed from disk.



This method is usually called automatically when the file()
method is used to update the current filename and the nokeep()
flag is set to true. In this way, temporary files can be removed
without explicit use of the erase() method. (Just need to
use the nokeep() method after the file() method has been used
to update the current filename).



Can support paths to HDS objects. If the last object is removed from
an HDS container file, the entire container file is removed.


\item[{\textbf{file\_exists}}] \mbox{}

Checks for the existence of the frame file(). Assumes a \texttt{.sdf}
extension.

\begin{verbatim}
  $exists = $Frm->exists($i)
\end{verbatim}


The optional argument specifies the file number to be used.
All extension are removed from the file name before adding the
\texttt{.sdf} so that HDS containers can be supported (and files
that already have the extension)  -- but note that
this version of the method does not look inside HDS containers
looking for NDFs.


\item[{\textbf{inout}}] \mbox{}

Method to return the current input filename and the new output
filename given a suffix.  Copes with non-existence of HDS container
and handles NDF subframes on the assumption that any NDF with a
"." in it must be referring to an HDS component.



The suffix is appended to the root filename derived from the characters
before the first ".". Note that this uses the ORAC-DR standard, replacing
the first non-numeric suffix.



The following logic is applied when propogating HDS containers:

\begin{verbatim}
 - If a '.' is present
\end{verbatim}
\begin{verbatim}
   NFILES > 1
       The new suffix is attached before the dot.
       An HDS container is created (based on the root) to
       receive the expected NDF. If present, a .HEADER component
       is copied to the output file, else, the current FITS header
       is written to a .HEADER component. Note that even if multiple
       HDS component paths are included in the input file, only
       the last section of the path is copied to the output file.
       ie file.A.B.I1 will result in outfile.I1
\end{verbatim}
\begin{verbatim}
   NFILES = 1
       We remove the dot and append the suffix as normal
       (by removing the old suffix first).
       This ensures that when NFILES=1 we will no longer
       be using HDS containers
\end{verbatim}
\begin{verbatim}
 - If no '.' is present
\end{verbatim}
\begin{verbatim}
       This is the standard behaviour. Simply remove after
       last underscore and replace with new suffix.
\end{verbatim}


If you want to retain the HDS container syntax, this routine has to be
fooled into thinking that nfiles is greater than 1 (eg by adding a dummy
file name to the frame).



Returns \$out in a scalar context:

\begin{verbatim}
   $out = $Frm->inout($suffix);
\end{verbatim}


Returns \$in and \$out in an array context:

\begin{verbatim}
   ($in, $out) = $Frm->inout($suffix);
\end{verbatim}
\begin{verbatim}
   ($in,$out) = $Frm->inout($suffix,2);
\end{verbatim}


The second (optional) argument is used to specify which of the input
filenames should be used to generate an output name. This number is
forwarded to the file() method and defaults to 1 (ie the first frame).



If a value of 0 is provided, the output name is derived assuming the
NFILES=1 rule described above. This allows the output file name
to be derived correctly in the many-to-one scenario.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Frame::NDF_SEE_ALSO}\index{ORAC::Frame::NDF!SEE ALSO}}


\emph{ORAC::Frame}, \emph{ORAC::BaseNDF}

\subsubsection*{REVISION\label{ORAC::Frame::NDF_REVISION}\index{ORAC::Frame::NDF!REVISION}}


\$Id: NDF.pm 7388 2008-02-01 02:03:43Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Frame::NDF_COPYRIGHT}\index{ORAC::Frame::NDF!COPYRIGHT}}


Copyright (C) 1998-2005 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Frame::UKIRT\label{ORAC::Frame::UKIRT}\index{ORAC::Frame::UKIRT}}


UKIRT class for dealing with observation files in ORAC-DR

\subsubsection*{SYNOPSIS\label{ORAC::Frame::UKIRT_SYNOPSIS}\index{ORAC::Frame::UKIRT!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Frame::UKIRT;
\end{verbatim}
\begin{verbatim}
  $Frm = new ORAC::Frame::UKIRT("filename");
  $Frm->file("file")
  $Frm->readhdr;
  $Frm->configure;
  $value = $Frm->hdr("KEYWORD");
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Frame::UKIRT_DESCRIPTION}\index{ORAC::Frame::UKIRT!DESCRIPTION}}


This module provides methods for handling Frame objects that
are specific to UKIRT. It provides a class derived from \textbf{ORAC::Frame::NDF}.
All the methods available to \textbf{ORAC::Frame} objects are available
to \textbf{ORAC::Frame::UKIRT} objects.

\subsubsection*{PUBLIC METHODS\label{ORAC::Frame::UKIRT_PUBLIC_METHODS}\index{ORAC::Frame::UKIRT!PUBLIC METHODS}}


The following methods are available in this class in addition to
those available from \textbf{ORAC::Frame}.

\paragraph*{General Methods\label{ORAC::Frame::UKIRT_General_Methods}\index{ORAC::Frame::UKIRT!General Methods}}
\begin{description}

\item[{\textbf{file\_from\_bits}}] \mbox{}

Determine the raw data filename given the variable component
parts. A prefix (usually UT) and observation number should
be supplied.

\begin{verbatim}
  $fname = $Frm->file_from_bits($prefix, $obsnum);
\end{verbatim}


The \$obsnum is zero padded to 5 digits.



pattern\_from\_bits() is currently an alias for file\_from\_bits(),
and both can be used interchangably in the UKIRT subclass.


\item[{\textbf{flag\_from\_bits}}] \mbox{}

Determine the name of the flag file given the variable
component parts. A prefix (usually UT) and observation number
should be supplied

\begin{verbatim}
  $flag = $Frm->flag_from_bits($prefix, $obsnum);
\end{verbatim}


This generic UKIRT version returns back the observation filename (from
file\_from\_bits) , adds a leading "." and replaces the .sdf with .ok


\item[{\textbf{inout}}] \mbox{}

Method to return the current input filename and the new output
filename given a suffix.  Copes with non-existence of HDS container
and handles NDF subframes



The following logic is applied:

\begin{verbatim}
 - If a '.' is present
\end{verbatim}
\begin{verbatim}
   NFILES > 1
       The new suffix is attached before the dot.
       An HDS container is created (based on the root) to
       receive the expected NDF.
\end{verbatim}
\begin{verbatim}
   NFILES = 1
       We remove the dot and append the suffix as normal
       (by removing the old suffix first).
       This ensures that when NFILES=1 we will no longer
       be using HDS containers
\end{verbatim}
\begin{verbatim}
 - If no '.' is present
\end{verbatim}
\begin{verbatim}
       This is the standard behaviour. Simply remove after
       last underscore and replace with new suffix.
\end{verbatim}


If you want to retain the HDS container syntax, this routine has to be
fooled into thinking that nfiles is greater than 1 (eg by adding a dummy
file name to the frame).



Returns \$out in a scalar context:

\begin{verbatim}
   $out = $Frm->inout($suffix);
\end{verbatim}


Returns \$in and \$out in an array context:

\begin{verbatim}
   ($in, $out) = $Frm->inout($suffix);
\end{verbatim}
\begin{verbatim}
   ($in,$out) = $Frm->inout($suffix,2);
\end{verbatim}
\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Frame::UKIRT_SEE_ALSO}\index{ORAC::Frame::UKIRT!SEE ALSO}}


\emph{ORAC::Group}, \emph{ORAC::Frame::NDF}, \emph{ORAC::Frame}

\subsubsection*{REVISION\label{ORAC::Frame::UKIRT_REVISION}\index{ORAC::Frame::UKIRT!REVISION}}


\$Id: UKIRT.pm 7427 2008-02-15 00:28:37Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Frame::UKIRT_COPYRIGHT}\index{ORAC::Frame::UKIRT!COPYRIGHT}}


Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Frame::JCMT\label{ORAC::Frame::JCMT}\index{ORAC::Frame::JCMT}}


JCMT class for dealing with observation files in ORACDR

\subsubsection*{SYNOPSIS\label{ORAC::Frame::JCMT_SYNOPSIS}\index{ORAC::Frame::JCMT!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Frame::JCMT;
\end{verbatim}
\begin{verbatim}
  $Frm = new ORAC::Frame::JCMT("filename");
  $Frm->file("file")
  $Frm->readhdr;
  $Frm->configure;
  $value = $Frm->hdr("KEYWORD");
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Frame::JCMT_DESCRIPTION}\index{ORAC::Frame::JCMT!DESCRIPTION}}


This module provides methods for handling Frame objects that
are specific to JCMT. It provides a class derived from \textbf{ORAC::Frame}.
All the methods available to \textbf{ORAC::Frame} objects are available
to \textbf{ORAC::Frame::JCMT} objects. Some additional methods are supplied.

\subsubsection*{PUBLIC METHODS\label{ORAC::Frame::JCMT_PUBLIC_METHODS}\index{ORAC::Frame::JCMT!PUBLIC METHODS}}


The following are modifications to standard ORAC::Frame methods.

\paragraph*{Constructors\label{ORAC::Frame::JCMT_Constructors}\index{ORAC::Frame::JCMT!Constructors}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a \textbf{ORAC::Frame::JCMT} object.
This method also takes optional arguments:
if 1 argument is  supplied it is assumed to be the name
of the raw file associated with the observation. If 2 arguments
are supplied they are assumed to be the raw file prefix and
observation number. In any case, all arguments are passed to
the configure() method which is run in addition to new()
when arguments are supplied.
The object identifier is returned.

\begin{verbatim}
   $Frm = new ORAC::Frame::JCMT;
   $Frm = new ORAC::Frame::JCMT("file_name");
   $Frm = new ORAC::Frame::JCMT("UT","number");
\end{verbatim}


This method runs the base class constructor and then modifies
the rawsuffix and rawfixedpart to be '.sdf' and '\_dem\_'
respectively.

\end{description}
\paragraph*{Subclassed methods\label{ORAC::Frame::JCMT_Subclassed_methods}\index{ORAC::Frame::JCMT!Subclassed methods}}


The following methods are provided for manipulating
\textbf{ORAC::Frame::JCMT} objects. These methods override those
provided by \textbf{ORAC::Frame}.

\begin{description}

\item[{\textbf{calc\_orac\_headers}}] \mbox{}

This method calculates header values that are required by the
pipeline by using values stored in the header.

\begin{verbatim}
  %new = $Frm->calc_orac_headers();
\end{verbatim}


This method calculates WVM statistics in addition to calling
the standard base class calculations.



This method updates the frame header.
Returns a hash containing the new keywords.


\item[{\textbf{configure}}] \mbox{}

This method is used to configure the object. It is invoked
automatically if the new() method is invoked with an argument. The
file(), raw(), readhdr(), findgroup(), findrecipe(), findsubs() 
findfilters() and findwavelengths() methods are
invoked by this command. Arguments are required.
If there is one argument it is assumed that this is the
raw filename. If there are two arguments the filename is
constructed assuming that arg 1 is the prefix and arg2 is the
observation number.

\begin{verbatim}
  $Frm->configure("fname");
  $Frm->configure("UT","num");
\end{verbatim}


The sub-instrument configuration is also stored.


\item[{\textbf{file\_from\_bits}}] \mbox{}

Determine the raw data filename given the variable component
parts. A prefix (usually UT) and observation number should
be supplied.

\begin{verbatim}
  $fname = $Frm->file_from_bits($prefix, $obsnum);
\end{verbatim}


pattern\_from\_bits() is currently an alias for file\_from\_bits(),
and both can be used interchangably for SCUBA.


\item[{\textbf{flag\_from\_bits}}] \mbox{}

Determine the flag filename given the variable component
parts. A prefix (usually UT) and observation number should
be supplied.

\begin{verbatim}
  $fname = $Frm->file_from_bits($prefix, $obsnum);
\end{verbatim}


The format is ".20021001\_dem\_0001"


\item[{\textbf{findgroup}}] \mbox{}

Return the group associated with the Frame. This group is constructed
from header information. The group name is automatically updated in
the object via the group() method.



The group membership can be set using the DRGROUP keyword in the
header. If this keyword exists and is not equal to 'UNKNOWN' the
contents will be returned.



Alternatively, if DRGROUP is not specified the group name is
constructed from the MODE, OBJECT and FILTER keywords. This may cause
problems in the following cases:

\begin{verbatim}
 - The chop throw changes and the data should not be coadded
 [in general this is true except for LO chopping scan maps
 where all 6 chops should be included in the group]
\end{verbatim}
\begin{verbatim}
 - The source name is the same, the mode is the same and the
 filter is the same but the source coordinates are different by
 a degree or more. In some cases [a large scan map] these should
 be in the same group. In other cases they probably should not
 be. Should I worry about it? One example was where the observer
 used RB coordinates by mistake for a first map and then changed
 to RJ -- the coordinates and source name were identical but the
 position on the sky was miles off. Maybe this should be dealt with
 by using the Frame ON/OFF facility [so it would be part of the group
 but the observer would turn the observation off]
\end{verbatim}
\begin{verbatim}
 - Different source names are being used for offsets around
 a common centre [eg the Galactic Centre scan maps]. In this case
 we do want to coadd but this means we should be using position
 rather than source name. Also, how do we define when two fields
 are too far apart to be coadded
\end{verbatim}
\begin{verbatim}
 - Photometry data should never be in the same group as a source
 that has a different pointing centre. Note this really should take
 MAP_X and MAP_Y into account since data should be of the same group
 if either the ra/dec is given or if the mapx/y is given relative
 to a fixed ra/dec.
\end{verbatim}


Bottom line is the following (I think).



In all cases the actual position in RJ coordinates should be calculated
(taking into account RB-$>$RJ and GA-$>$RJ and map\_x map\_y, local\_coords) 
using Astro::SLA. Filter should also be matched as now.
Planets will be special cases - matching on name rather than position.



PHOTOM observations

\begin{verbatim}
  Should match positions exactly (within 1 arcsec). Should also match
  chop throws [since the gain is different]. The observer is responsible
  for a final coadd. Source name then becomes irrelevant.
\end{verbatim}


JIGGLE MAP

\begin{verbatim}
  Should match positions to within 10 arcmin (say). Should match chop
  throw.
\end{verbatim}


SCAN MAP

\begin{verbatim}
  Should match positions to 1 or 2 degrees?
  Should ignore chop throws (the primitive deals with that).
\end{verbatim}


The group name will then use the position with a number of significant
figures changing depending on the position tolerance.


\item[{\textbf{findnsubs}}] \mbox{}

Forces the object to determine the number of sub-instruments
associated with the data by looking in the header (hdr()). 
The result is stored in the object using nsubs().



Unlike findgroup() this method will always search the header for
the current state.


\item[{\textbf{findrecipe}}] \mbox{}

Return the recipe associated with the frame.
The state of the object is automatically updated via the
recipe() method.



The recipe is determined by looking in the FITS header
of the frame. If the 'DRRECIPE' is present and not
set to 'UNKNOWN' then that is assumed to specify the recipe
directly. Otherwise, header information is used to try
to guess at the reduction recipe. The default recipes
are keyed by observing mode:

\begin{verbatim}
 SKYDIP => 'SCUBA_SKYDIP'
 NOISE  => 'SCUBA_NOISE'
 POINTING => 'SCUBA_POINTING'
 PHOTOM => 'SCUBA_STD_PHOTOM'
 JIGMAP => 'SCUBA_JIGMAP'
 JIGMAP (phot) => 'SCUBA_JIGPHOTMAP'
 EM2_SCAN => 'SCUBA_EM2SCAN'
 EKH_SCAN => 'SCUBA_EKHSCAN'
 JIGPOLMAP => 'SCUBA_JIGPOLMAP'
 SCANPOLMAP => 'SCUBA_SCANPOLMAP'
 ALIGN  => 'SCUBA_ALIGN'
 FOCUS  => 'SCUBA_FOCUS'
\end{verbatim}


So called "wide" photometry is treated as a map (although this
depends on the name of the jiggle pattern which may change).



In future we may want to have a separate text file containing
the mapping between observing mode and recipe so that
we dont have to hard wire the relationship.


\item[{\textbf{template}}] \mbox{}

This method is identical to the base class template method
except that only files matching the specified sub-instrument
are affected.

\begin{verbatim}
  $Frm->template($template, $sub);
\end{verbatim}


If no sub-instrument is specified then the first file name
is modified



Note that this is different to the base class which accepts
a file number as the second argument. This may need some
rationalisation.

\end{description}
\subsubsection*{NEW METHODS FOR JCMT\label{ORAC::Frame::JCMT_NEW_METHODS_FOR_JCMT}\index{ORAC::Frame::JCMT!NEW METHODS FOR JCMT}}


This section describes methods that are available in addition
to the standard methods found in \textbf{ORAC::Frame}.

\paragraph*{Accessor Methods\label{ORAC::Frame::JCMT_Accessor_Methods}\index{ORAC::Frame::JCMT!Accessor Methods}}


The following extra accessor methods are provided:

\begin{description}

\item[{\textbf{filters}}] \mbox{}

Return or set the filter names associated with each sub-instrument
in the frame.


\item[{\textbf{subs}}] \mbox{}

Return or set the names of the sub-instruments associated
with the frame.


\item[{\textbf{wavelengths}}] \mbox{}

Return or set the wavelengths associated with each  sub-instrument
in the frame.

\end{description}
\paragraph*{New methods\label{ORAC::Frame::JCMT_New_methods}\index{ORAC::Frame::JCMT!New methods}}


The following additional methods are provided:

\begin{description}

\item[{\textbf{file2sub}}] \mbox{}

Given a file index, (see file()) returns the associated
sub-instrument.

\begin{verbatim}
  $sub = $Frm->file2sub(2)
\end{verbatim}


Returns the first sub name if index is too large.
This assumes that the file names associated wth the
object are linked to sub-instruments (as returned
by the subs method). It is up to the primitive writer
to make sure that subs() tracks changes to files().


\item[{\textbf{findfilters}}] \mbox{}

Forces the object to determine the names of all sub-instruments
associated with the data by looking in the hdr().



The result is stored in the object using filters(). The sub-inst filter
name is made to match the filter name such that a filter of '450w:850w'
has filter names of '450W' and '850W' despite the entries in the header
being simply '450' and '850'. Photometry filter names are not modified.



Unlike findgroup() this method will always search the header for
the current state.


\item[{\textbf{findsubs}}] \mbox{}

Forces the object to determine the names of all sub-instruments
associated with the data by looking in the header (hdr()). 
The result is stored in the object using subs().



Unlike findgroup() this method will always search the header for
the current state.


\item[{\textbf{findwavelengths}}] \mbox{}

Forces the object to determine the names of all sub-instruments
associated with the data by looking in the header (hdr()). 
The result is stored in the object using wavelengths().



Unlike findgroup() this method will always search the header for
the current state.


\item[{\textbf{sub2file}}] \mbox{}

Given a sub instrument name returns the associated file
index. This is the reverse of sub2file. The resulting value
can be used directly in file() to retrieve the file name.

\begin{verbatim}
  $file = $Frm->file($Frm->sub2file('LONG'));
\end{verbatim}


A case insensitive comparison is performed.



Returns 1 if nothing matched (ie just returns the first file
in file(). This is probably a bug.



Assumes that changes in subs() are reflected in files().

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Frame::JCMT_SEE_ALSO}\index{ORAC::Frame::JCMT!SEE ALSO}}


\emph{ORAC::Frame}, \emph{ORAC::Frame::NDF}

\subsubsection*{REVISION\label{ORAC::Frame::JCMT_REVISION}\index{ORAC::Frame::JCMT!REVISION}}


\$Id: JCMT.pm 7431 2008-02-16 02:00:42Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Frame::JCMT_COPYRIGHT}\index{ORAC::Frame::JCMT!COPYRIGHT}}


Copyright (C) 1998-2005 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::General\label{ORAC::General}\index{ORAC::General}}


Simple perl subroutines that may be useful for primitives

\subsubsection*{SYNOPSIS\label{ORAC::General_SYNOPSIS}\index{ORAC::General!SYNOPSIS}}
\begin{verbatim}
  use ORAC::General;
\end{verbatim}
\begin{verbatim}
  $max = max(@values);
  $min = min(@values);
  $result = log10($value);
  $result = nint($value);
  $yyyymmdd = utdate;
  %hash = parse_keyvalues($string);
  @obs = parse_obslist($string);
  $result = cosdeg( 45.0 );
  $result = sindeg( 45.0) ;
  @dms = dectodms( $dec );
\end{verbatim}
\begin{verbatim}
  print "Is a number" if is_numeric( $number );
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::General_DESCRIPTION}\index{ORAC::General!DESCRIPTION}}


This module provides simple perl functions that are not available
from standard perl. These are available to all ORAC primitive writers,
but they are general in nature and have no connection to orac. Some of
these are used in the ORAC infastructure, so ORACDR does require this
library in order to run.

\subsubsection*{SUBROUTINES\label{ORAC::General_SUBROUTINES}\index{ORAC::General!SUBROUTINES}}
\begin{description}

\item[{\textbf{cosdeg}}] \mbox{}

Return the cosine of the angle. The angle must be in degrees.


\item[{\textbf{sindeg}}] \mbox{}

Return the sine of the angle. The angle must be in degrees.


\item[{\textbf{dectodms}}] \mbox{}

Convert decimal angle (degrees or hours) to degrees, minutes and seconds.
(or hours).

\begin{verbatim}
  ($deg, $min, $sec) = dectodms( $decimal );
\end{verbatim}

\item[{\textbf{hmstodec}}] \mbox{}

Convert hours:minutes:seconds to decimal hours.

\begin{verbatim}
  my $hms = "23:58:01.23";
  my $dec = hmstodec($hms);
\end{verbatim}

\item[{\textbf{is\_numeric}}] \mbox{}

Determine whether the supplied argument is a number or not.
Returns true if it is and false otherwise.


\item[{\textbf{min}}] \mbox{}

Find the minimum value of an array. Can also be used to find
the minimum of a list of scalars since arguments are passed into
the subroutine in an array context.

\begin{verbatim}
  $min = min(@values);
  $min = min($a, $b, $c);
\end{verbatim}

\item[{\textbf{max}}] \mbox{}

Find the maximum value of an array. Can also be used to find
the maximum of a list of scalars since arguments are passed into
the subroutine in an array context.

\begin{verbatim}
  $max = max(@values);
  $max = max($a, $b, $c);
\end{verbatim}

\item[{\textbf{log10}}] \mbox{}

Returns the logarithm to base ten of a scalar.

\begin{verbatim}
  $value = log10($number);
\end{verbatim}


Currently uses the implementation of log10 found in the
POSIX module


\item[{\textbf{nint}}] \mbox{}

Return the nearest integer to a supplied floating point
value. 0.5 is rounded up.


\item[{\textbf{utdate}}] \mbox{}

Return the UT date (strictly, GMT) date in the format yyyymmdd


\item[{\textbf{parse\_keyvalues}}] \mbox{}

Takes a string of comma-separated key-value pairs and return a hash.

\begin{verbatim}
  %hash = parse_keyvalues("a=1,b=2,C=3");
\end{verbatim}


The keys are down-cased.



Values can be quoted or bracketed. If values include commas themselves
they will be returned as array references, e.g.

\begin{verbatim}
   "a=1,b=2,3,c='4,5',d=[1,2,3,4],e=[5]"
\end{verbatim}


will return the following.

\begin{verbatim}
    a => 1,
    b => [2,3],
    c => [4,5],
    d => [1,2,3,4],
    e => 5,
\end{verbatim}


Note that delimiters are removed from the values and that if only a
single element is quoted it will be returned as a scalar string rather
than an array.


\item[{\textbf{parse\_obslist}}] \mbox{}

Converts a comma separated list of observation numbers (as supplied
on the command line for the -list option) and converts it to
an array of observation numbers. Colons are treated as range arguments.



For example,

\begin{verbatim}
   "5,9:11"
\end{verbatim}


is converted to

\begin{verbatim}
   (5,9,10,11)
\end{verbatim}

\item[{\textbf{get\_prim\_arg}}] \mbox{}

Retrieve a primitive argument safely using exists and defined
and if necessary returning the supplied default.

\begin{verbatim}
  my $val = get_prim_arg( $_PRIM_ARGS_, $key, $default );
\end{verbatim}

\item[{\textbf{write\_file\_list}}] \mbox{}

Given an array of file names, open a temp file, write the filenames
to it and return the name of the file. The returned object stringifies
to the actual filename. It must be returned as an object so that
the temp file will be deleted automatically when the variable
goes out of scope.

\begin{verbatim}
  $fobject = write_file_list( $Frm->files );
\end{verbatim}


Suitable for creating a file to be used for Starlink application
group parameters.


\item[{\textbf{write\_file\_list\_inout}}] \mbox{}

Write an input indirection file and an output indirection file using the
supplied file suffix.

\begin{verbatim}
  ($in, $out, @outfiles) = write_file_list_inout( $Frm, "_al" );
\end{verbatim}


The first argument is the frame or group object that will be used
for the inout() method and the second argument is the suffix to
be supplied to the inout() method. The names of the derived output files
are returned in the list. The object is not updated automatically.



If the third (optional) argument
is true the output files will be pushed onto the intermediates
array associated with the supplied frame/group object. This ensures
the files will be cleared up even if they are not output from a 
primitive. If istmp is true, the output files are not returned to
the caller.

\begin{verbatim}
 ($in, $out) = write_file_list_inout( $Frm, "_al", 1);
\end{verbatim}
\end{description}
\subsubsection*{SEE ALSO\label{ORAC::General_SEE_ALSO}\index{ORAC::General!SEE ALSO}}


\emph{POSIX},
\emph{List::Util},
\emph{Math::Trig}

\subsubsection*{REVISION\label{ORAC::General_REVISION}\index{ORAC::General!REVISION}}


\$Id: General.pm 7747 2008-05-09 02:41:37Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::General_COPYRIGHT}\index{ORAC::General!COPYRIGHT}}


Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Group\label{ORAC::Group}\index{ORAC::Group}}


Base class for dealing with observation groups in ORAC-DR

\subsubsection*{SYNOPSIS\label{ORAC::Group_SYNOPSIS}\index{ORAC::Group!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Group;
\end{verbatim}
\begin{verbatim}
  $Grp = new ORAC::Group("groupid");
\end{verbatim}
\begin{verbatim}
  $Grp->file("Group_file_name");
  $group_name = $Grp->name;
  $Grp->push($frame);
  $total_in_group = $Grp->num;
  $frame3 = $Grp->frame(2);
  @good_members = $Grp->members;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Group_DESCRIPTION}\index{ORAC::Group!DESCRIPTION}}


This module provides the basic methods available to all
\textbf{ORAC::Group} objects. This class should be used when 
storing information relating to a group of observations
processed in the \textbf{ORAC-DR} data reduction pipeline.



Groups are composed of frame objects (\textbf{ORAC::Frame})
or objects that can perform those methods.

\subsubsection*{PUBLIC METHODS\label{ORAC::Group_PUBLIC_METHODS}\index{ORAC::Group!PUBLIC METHODS}}


The following methods are available in this class.

\paragraph*{Constructors\label{ORAC::Group_Constructors}\index{ORAC::Group!Constructors}}


The following constructors are available:

\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a \textbf{ORAC::Group} object.
This method takes an optional argument containing the
identifier of the new group. The object identifier is returned.

\begin{verbatim}
   $Grp = new ORAC::Group;
   $Grp = new ORAC::Group("group_id");
\end{verbatim}
\begin{verbatim}
   $Grp = new ORAC::Group("group_id", $filename );
\end{verbatim}


The base class constructor should be invoked by sub-class constructors.
If this method is called with the last argument as a reference to
a hash it is assumed that this hash contains extra configuration
information ('instance' information) supplied by sub-classes.


\item[{\textbf{configure}}] \mbox{}

Initialise the object.


\item[{\textbf{subgrp}}] \mbox{}

Method to return a new group (ie a sub-group of the existing
group) that contains all members of the main group matching
certain header values.



Arguments is a hash that is used for comparison with each
frame.

\begin{verbatim}
  $subgrp = $Grp->subgrp(NAME => 'CRL618', CHOP=> 60.0);
\end{verbatim}


The new subgrp is blessed into the same class as \$Grp.
All header information (hdr() and uhdr()) is copied 
from the main group to the sub-group.



This method is generally used where access to members of the
group by some search criterion is required.



It is possible that the returned group will contain no 
members....



If the value looks like a number a numeric comparison will be performed.
Else a string comparison is used.


\item[{\textbf{subgrps}}] \mbox{}

Returns frames grouped by the supplied header keys.
A frame can not belong to more than one sub group created by this
method:

\begin{verbatim}
   @grps = $Grp->subgrps(@keys);
\end{verbatim}


The groups in @grps are blessed into the same class as \$Grp.
For example, if @keys = ('MODE','CHOP') then you can gurantee
that the members of each sub group will have the same values
for MODE and CHOP.



All header information from the main group is copied to the
sub groups.



If a key is not present in the headers then all the frames
will be returned in a single subgrp (since that group guarantees
that the specified header item is not different - it simply
is not there).



The order of the subgroups will match the position of the first
member in the original group.

\end{description}
\paragraph*{Accessor methods\label{ORAC::Group_Accessor_methods}\index{ORAC::Group!Accessor methods}}


The following methods are available for accessing the 
'instance' data.

\begin{description}

\item[{\textbf{allmembers}}] \mbox{}

Set or retrieve the array containing the current group membership.

\begin{verbatim}
    $Grp->allmembers(@frames);
    @frames = $Grp->allmembers;
\end{verbatim}


The setting function of this routine should only be used
if you know what you are doing (since it completely changes the group
membership). If setting the contents, the check\_membership() method
is run automatically so that the list of valid members can remain
synchronized.



All group members are returned regardless of the state of each member.
Use the members() method to return only valid members.



If called in a scalar context, a reference to an array is returned
rather than the array.

\begin{verbatim}
  $ref = $Grp->allmembers;
  $first = $Grp->allmembers->[0];
\end{verbatim}


Do not use this array reference to change the contents of the array
directly unless the check\_membership() method is run immediately
afterwards. The check\_membership() method is responsible for 
checking the state of each member and copying them to the members()
array.


\item[{\textbf{purge\_members}}] \mbox{}

Removes all frames from the group. Can be used to reduce the memory
footprint of the pipeline when a recipe is designed such that it never
needs to go back to the original members.

\begin{verbatim}
  $Grp->purge_members;
\end{verbatim}

\item[{\textbf{badobs\_index}}] \mbox{}

Return (or set) the index object associate with the bad observation
index file. A index of class \textbf{ORAC::Index::Extern} is used since 
this index is modified by an external user/program.



The index is created automatically the first time this method
is invoked.


\item[{\textbf{coadds}}] \mbox{}

Return (or set) the array containing the list of frame numbers that have
been coadded into the current group. This is not necessarily the same
as the return of the membernumbers() method since that can return numbers
for all the members of the group even if the full coaddition has not
taken place or the pipeline has been resumed partway through a coaddition
(in which case the coadds array will contain more numbers than are in the
group).

\begin{verbatim}
  @coadds = $Grp->coadds;
  $coaddref = $Grp->coadds;
  $Grp->coadds(@numbers);
\end{verbatim}


Returns an array reference in a scalar context, an array in an
array context.



The contents of this array are not automatically written to the 
group file when changed, see the coaddspush() or coaddswrite() methods
for further information on object persistence. The array is simply
meant as a storage area for the pipeline.


\item[{\textbf{filesuffix}}] \mbox{}

Set or retrieve the filename suffix associated with the
reduced group.

\begin{verbatim}
    $Grp->filesuffix(".sdf");
    $group_file = $Grp->filesuffix;
\end{verbatim}

\item[{\textbf{fixedpart}}] \mbox{}

Set or retrieve the part of the group filename that does not
change between invocation. The output filename can be derived using
this.

\begin{verbatim}
    $Grp->fixedpart("rg");
    $prefix = $Grp->fixedpart;
\end{verbatim}

\item[{\textbf{is\_frame}}] \mbox{}

Whether or not the current object is an ORAC::Frame object.

\begin{verbatim}
  $is_frame = $self->is_frame;
\end{verbatim}


Returns 0 for Group objects.


\item[{\textbf{members}}] \mbox{}

Retrieve the array containing the valid objects within the group

\begin{verbatim}
    @frames = $Grp->members;
\end{verbatim}


This is the safest way to access the group members
since it only returns valid frames to the caller.



Use the allmembers() method to return all members of the group 
regardless of the state of the individual frames.



Group membership should not be set using ths method since that may lead
to a situation where the actual membership of the group does not match the
selected membership. [Valid group membership should only be set from
within this class].



If called in a scalar context, a reference to an array is returned
rather than the array.

\begin{verbatim}
  $first = $Grp->members->[0];
\end{verbatim}

\item[{\textbf{name}}] \mbox{}

Retrieve or set the name of the group.

\begin{verbatim}
    $Grp->name("group_name");
    $group_name = $Grp->name;
\end{verbatim}


If no name is set but is retrieved, a name string will be
set automatically based on the first frame in the group.


\item[{\textbf{groupid}}] \mbox{}

Set or retrieve the group identifier. This will
be the string derived from the OBSERVATION\_GROUP
header of the first input frame object.

\begin{verbatim}
    $Grp->groupid("group_id");
    $group_id = $Grp->groupid;
\end{verbatim}
\end{description}
\paragraph*{General methods\label{ORAC::Group_General_methods}\index{ORAC::Group!General methods}}


The following methods are provided for manipulating \textbf{ORAC::Group}
objects:

\begin{description}

\item[{\textbf{check\_membership}}] \mbox{}

Check whether any of the members of the group have been marked for
removal from the group. The valid group members are copied
to a new array and can be retrieved by the members() method.
Note that all group methods use the list of valid group
members.



This routine is automatically run whenever the group membership
is updated (via the push() or  allmembers() methods. This may
cause too high an overhead with push() in, for example, the
subgrps method).



This method works by looking in a text file created by the
observer in \$ORAC\_DATA\_OUT called index.badobs. This file
contains a list of numbers (two per line) relating to observations
that should be turned off. The first number is the UT date
(YYYYMMDD) and the second number is the observation
number. This is necessary so that ORAC\_DATA\_OUT can be reused
for a different UT date without worrying about the index file
file turning off incorrect observations.



The UT and observation number are compared with each member of
the group (the full list of members - see allmembers()).
For each group member, the following test is performed to test
for validity. First it is queried to check whether it is in a
good state (ie has been processed successfully). 
A frame will be marked as bad if the recipe fails to execute
successfully. If the frame is good (from the pipeline viewpoint)
the UT date and observation number is then compared with the
entries in the index file. If a match can \textbf{NOT} be found the
frame is considered to be valid and is copied to the list of valid
group members (see the members() method).



The format of the index file should be of the form:

\begin{verbatim}
 24 19980716 
 27 19980716 
 43 19980815 
 ...
\end{verbatim}

\item[{\textbf{coaddspush}}] \mbox{}

Used to push observation numbers onto the coadds() array. Automatically
runs coaddswrite() to update to sync the file contents with the coadds()
array.

\begin{verbatim}
  $Grp->coaddspush(@numbers);
\end{verbatim}

\item[{\textbf{coaddspresent}}] \mbox{}

Compares the contents of the coadds() array with the supplied (single)
argument. Returns true if the argument is present in the coadds()
array, false otherwise. Also, returns false if no arguments are supplied
or if the argument is undef.

\begin{verbatim}
  $present = $Grp->coaddspresent($number);
\end{verbatim}

\item[{\textbf{coaddsread}}] \mbox{}

Reads the coadds() information from the current group file and stores
it in the group using the coadds() method.
Should return ORAC\_\_OK if the coadds information was read successfully,
else returns ORAC\_\_ERROR.



This is an abstract method and should be defined by a subclass.


\item[{\textbf{coaddswrite}}] \mbox{}

Method to write the contents of the coadds() array to the current
group file. Should return ORAC\_\_OK if the coadds information was written
successfully, else returns ORAC\_\_ERROR.



If coadds() contains no entries, all coadds information is removed from
the group file if present.



This is an abstract method and should be defined by a subclass.


\item[{\textbf{erase}}] \mbox{}

Erases the group file from disk.

\begin{verbatim}
   $Grp->erase;
\end{verbatim}


Returns ORAC\_\_OK if successful, ORAC\_\_ERROR otherwise.


\item[{\textbf{file\_exists}}] \mbox{}

Method to determine whether the group file() exists on disk or not.
Returns true if the file is there, false otherwise. Effectively
equivalent to using \texttt{-e} but allows for the possibility that the
information stored in file() does not directly relate to the
file as stored on disk (e.g. a .sdf extension).


\item[{\textbf{file\_from\_bits}}] \mbox{}

Method to return the group filename derived from a fixed
variable part (eg UT) and a group designator (usually obs
number). The full filename is returned (including suffix).

\begin{verbatim}
  $file = $Grp->file_from_bits("UT","num");
\end{verbatim}


For the base class the return string is of the format

\begin{verbatim}
  fixedpart . prefix . '_' . number . suffix
\end{verbatim}


For example, with IRCAM using a UT date of 980104 and observation
number 25 the returned string would be 'rg980104\_25.sdf'.


\item[{\textbf{frame}}] \mbox{}

Retrieve the nth frame of the group.
Counting starts at 0 as for a standard perl array.

\begin{verbatim}
  $Frm = $Grp->frame(2);
\end{verbatim}


This is equivalent to

\begin{verbatim}
  $Frm = $Grp->members->[2];
\end{verbatim}


A second argument can be used to set the nth frame.

\begin{verbatim}
  $Grp->frame(3, $Frm);
\end{verbatim}


Note that this replaces the nth frame in the list of valid members and
also replaces the equivalent frame in the list of all members of the
group. This is done since the nth valid member is not necessarily the
nth group member. If the supplied position is greater than the current
number of members the supplied frame is simply pushed onto the
array. Remember that just because a frame has been inserted into the
group does not necessarily mean that it will be a valid member
(check\_membership() will be run when setting any member of the group).
If the current frame at the specified position can not be found in
allmembers() the supplied frame is pushed onto allmembers() and
membership is re-checked.


\item[{\textbf{members\_inout}}] \mbox{}

Method to return the current filenames for each frame in the
group (similar to the membernames() method) and a set of output
names for each file. This is achieved by calling the inout()
method for each frame in turn. This will fail if the members of the
group do not possess the inout() method.



This method can take two arguments: the new suffix and, optionally,
the file number to use (see the inout() documentation for
\textbf{ORAC::Frame}). References to two arrays are returned when called
in an array context; returns the output array ref when called
from a scalar context

\begin{verbatim}
  ($inref, $outref) = $Grp->members_inout("suffix");
  ($inref, $outref) = $Grp->members_inout("suffix",2);
  $outref= $Grp->members_inout("suffix");
\end{verbatim}

\item[{\textbf{firstmember}}] \mbox{}

Method to determine whether the supplied argument matches the first
member of the group. Returns a 1 if it is the first member and a zero
otherwise.

\begin{verbatim}
  $isfirst = $Grp->firstmember( $Frm );
\end{verbatim}

\item[{\textbf{lastmember}}] \mbox{}

Method to determine whether the supplied argument
matches the last member of the group. Returns a 1 if
it is the last member and a zero otherwise.

\begin{verbatim}
   $islast = $Grp->lastmember($Frm);
\end{verbatim}

\item[{\textbf{memberindex}}] \mbox{}

Given a frame, determines what position this frame has in the
group. This is useful in Batch mode processing where the
groups are pre-populated.

\begin{verbatim}
  $index = $Grp->memberindex( $Frm );
\end{verbatim}


Index starts counting at 0 (see the \texttt{frame} method)
and refers only to valid members rather than all members.
If the frame is not in the group, returns undef.


\item[{\textbf{membernames}}] \mbox{}

Return a list of all the files associated with the group. This is
achieved by invoking the file() method for each object stored in the
Members array.  For this to work each member must be an object capable
of invoking the file() method (e.g. \textbf{ORAC::Frame}). Currently the
routine does not check to make sure this is possible - the program
will die if you try to use a SCALAR member.



If an argument list is given the file names for each member of the
group are updated. This will only be attempted if the number of 
arguments given matches the number of members in the group.

\begin{verbatim}
  $Grp->membernames(@newnames);
  @names = $Grp->membernames;
\end{verbatim}


Only the first file from each frame object is returned.


\item[{\textbf{membernumbers}}] \mbox{}

Return a list of all the observation numbers associated with
the group. This is achieved by invoking the number() method for
each object stored in the Members array.
For this to work each member must be an object capable of invoking
numbers() (e.g. \textbf{ORAC::Frame}). Currently the routine does not check
to make sure this is possible - the program will die if you try
to use a SCALAR member.

\begin{verbatim}
  @numbers = $Grp->membernumbers;
\end{verbatim}

\item[{\textbf{membertagset}}] \mbox{}

Set the tag in each of the members.

\begin{verbatim}
  $Grp->membertagset( 'TAG' );
\end{verbatim}


Runs the \texttt{tagset} method on each of the member frames.



Note that \$Grp-$>$tagset() is used for the group filenames
not the input files from Frame objects.


\item[{\textbf{membertagretrieve}}] \mbox{}

Run the \texttt{tagretrieve()} method for each of the members.

\begin{verbatim}
  $Grp->membertagretrieve
\end{verbatim}


Note that \$Grp-$>$tagretrieve() is used for the group filenames
not the input files from Frame objects.


\item[{\textbf{num}}] \mbox{}

Return the number of frames in a group minus one.
This is identical to the \$\# construct.

\begin{verbatim}
  $number_of_frames = $Grp->num;
\end{verbatim}

\item[{\textbf{push}}] \mbox{}

Method to push an observation into the group. Multiple observations
can be pushed on at once (see \emph{perl} "push()" command).

\begin{verbatim}
  $Grp->push("observation2");
  $Grp->push(@obs);
\end{verbatim}


There are no return arguments.


\item[{\textbf{template}}] \mbox{}

Method to change all the current filenames in the group so that they
match the supplied template. This method invokes the template()
method for each member of the group.

\begin{verbatim}
  $Grp->template("filename_template");
\end{verbatim}


A second argument can be specified to modify the specified frame
number rather than simply the first (see the template() method
in \textbf{ORAC::Frame} for more details):

\begin{verbatim}
  $Grp->template($template,2);
\end{verbatim}


There are no return arguments. The intelligence for this method resides
in the individual frame objects.


\item[{\textbf{updateout}}] \mbox{}

This method updates the current filename of each member of the group
when supplied with a suffix (and optionally, a file number -- see the
inout() method in \textbf{ORAC::Frame} for more information). The inout() 
method (of the individual frame) is invoked for each member to 
generate the output name.

\begin{verbatim}
  $Grp->updateout("suffix");
  $Grp->updateout("suffix", 5);
\end{verbatim}


This can be used to update the member filenames after an operation
has been applied to every file in the group. Alternatively the 
membernames() method can be invoked with the output of the inout()
method.

\end{description}
\subsubsection*{DISPLAY COMPATIBILITY\label{ORAC::Group_DISPLAY_COMPATIBILITY}\index{ORAC::Group!DISPLAY COMPATIBILITY}}


These methods are provided for compatibility with the ORAC display
system.

\begin{description}

\item[{\textbf{gui\_id}}] \mbox{}

Returns the identification string that is used to compare the
current frame with the frames selected for display in the
display definition file.



In the default case, this method returns everything after the
last suffix stored in file().



In some derived implementation of this method an argument
may be used so that multiple IDs can be extracted from objects
that contain more than one output file per observation.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Group_SEE_ALSO}\index{ORAC::Group!SEE ALSO}}


\emph{ORAC::Frame}

\subsubsection*{REVISION\label{ORAC::Group_REVISION}\index{ORAC::Group!REVISION}}


\$Id: Group.pm 7908 2008-06-02 20:32:10Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Group_COPYRIGHT}\index{ORAC::Group!COPYRIGHT}}


Copyright (C) 2007-2008 Science and Technology Facilities Council.
Copyright (C) 1998-2004, 2006-2007 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Group::NDF\label{ORAC::Group::NDF}\index{ORAC::Group::NDF}}


Class for dealing with groups based on NDF files

\subsubsection*{SYNOPSIS\label{ORAC::Group::NDF_SYNOPSIS}\index{ORAC::Group::NDF!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Group::NDF
\end{verbatim}
\begin{verbatim}
  $Grp = new ORAC::Group::NDF;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Group::NDF_DESCRIPTION}\index{ORAC::Group::NDF!DESCRIPTION}}


This class rovides implementations of the methods that require
knowledge of the NDF file format rather than generic methods or
methods that require knowledge of a specific instrument.  In general,
the specific instrument sub-classes will inherit from the file type
(which inherits from ORAC::Group) rather than directly from
ORAC::Group. For JCMT and UKIRT the group files are based on NDFs and
inherit from this class.



The format specific sub-classes do not contain constructors; they 
should be defined in either the base class or the instrument specific
sub-class.

\subsubsection*{PUBLIC METHODS\label{ORAC::Group::NDF_PUBLIC_METHODS}\index{ORAC::Group::NDF!PUBLIC METHODS}}


The following methods are modified from the base class versions.

\paragraph*{General Methods\label{ORAC::Group::NDF_General_Methods}\index{ORAC::Group::NDF!General Methods}}
\begin{description}

\item[{\textbf{coaddsread}}] \mbox{}

Method to read the COADDS information from the group file. If the
Group file exists, the file is opened and the \emph{.ORAC} extension is
located. The .COADDS component (ie groupfile.MORE.ORAC.COADDS) is then
opened as \_INTEGER and the contents are stored in the group using the
coadds() method. If a .MORE.ORAC.COADDS component can not be found (e.g.
because the file or component do not exist), the routine returns
ORAC\_\_ERROR, else returns ORAC\_\_OK.

\begin{verbatim}
  $Grp->coaddsread;
\end{verbatim}


There are no arguments.


\item[{\textbf{coaddswrite}}] \mbox{}

Writes the current contents of coadds() into the current group file().
Returns ORAC\_\_OK if the coadds information was written successfully,
else returns ORAC\_\_ERROR.

\begin{verbatim}
  $Grp->coaddswrite;
\end{verbatim}


There are no arguments. The information is written to a .ORAC.COADDS
component in the Group file.  If coadds() contains no entries, all
coadds information is removed from the group file if present (and good
status is returned). A .ORAC extension is always made if one does not
exist and the file is present.


\item[{\textbf{erase}}] \mbox{}

Erases the current group file. Assumes a \texttt{.sdf} extension.
Returns ORAC\_\_OK if successful, ORAC\_\_ERROR otherwise.


\item[{\textbf{file\_exists}}] \mbox{}

Checks for the existence of the Group file(). Assumes a \texttt{.sdf}
extension.

\end{description}
\subsubsection*{REQUIREMENTS\label{ORAC::Group::NDF_REQUIREMENTS}\index{ORAC::Group::NDF!REQUIREMENTS}}


This module requires the \emph{NDF} module.

\subsubsection*{SEE ALSO\label{ORAC::Group::NDF_SEE_ALSO}\index{ORAC::Group::NDF!SEE ALSO}}


\emph{ORAC::Group}, \emph{ORAC::BaseNDF}

\subsubsection*{REVISION\label{ORAC::Group::NDF_REVISION}\index{ORAC::Group::NDF!REVISION}}


\$Id: NDF.pm 7288 2007-12-11 00:09:25Z bradc \$

\subsubsection*{COPYRIGHT\label{ORAC::Group::NDF_COPYRIGHT}\index{ORAC::Group::NDF!COPYRIGHT}}


Copyright (C) 1998-2002 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Group::UFTI\label{ORAC::Group::UFTI}\index{ORAC::Group::UFTI}}


Class for dealing with UFTI observation groups in ORAC-DR

\subsubsection*{SYNOPSIS\label{ORAC::Group::UFTI_SYNOPSIS}\index{ORAC::Group::UFTI!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Group::UFTI;
\end{verbatim}
\begin{verbatim}
  $Grp = new ORAC::Group::UFTI("group1");
  $Grp->file("group_file")
  $Grp->readhdr;
  $value = $Grp->hdr("KEYWORD");
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Group::UFTI_DESCRIPTION}\index{ORAC::Group::UFTI!DESCRIPTION}}


This module provides methods for handling group objects that
are specific to UFTI. It provides a class derived from \textbf{ORAC::Group::NDF}.
All the methods available to ORAC::Group objects are available
to \textbf{ORAC::Group::UFTI} objects.

\subsubsection*{PUBLIC METHODS\label{ORAC::Group::UFTI_PUBLIC_METHODS}\index{ORAC::Group::UFTI!PUBLIC METHODS}}


The following methods are available in this class in addition to
those available from ORAC::Group.

\paragraph*{Constructor\label{ORAC::Group::UFTI_Constructor}\index{ORAC::Group::UFTI!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a \textbf{ORAC::Group::UFTI} object.
This method takes an optional argument containing the
name of the new group. The object identifier is returned.

\begin{verbatim}
   $Grp = new ORAC::Group::UFTI;
   $Grp = new ORAC::Group::UFTI("group_name");
\end{verbatim}


This method calls the base class constructor but initialises
the group with a file suffix of '.sdf' and a fixed part
of 'g'.

\end{description}
\paragraph*{General Methods\label{ORAC::Group::UFTI_General_Methods}\index{ORAC::Group::UFTI!General Methods}}
\subsubsection*{SEE ALSO\label{ORAC::Group::UFTI_SEE_ALSO}\index{ORAC::Group::UFTI!SEE ALSO}}


\emph{ORAC::Group}, \emph{ORAC::Group::NDF}

\subsubsection*{REVISION\label{ORAC::Group::UFTI_REVISION}\index{ORAC::Group::UFTI!REVISION}}


\$Id: UFTI.pm 7427 2008-02-15 00:28:37Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Group::UFTI_COPYRIGHT}\index{ORAC::Group::UFTI!COPYRIGHT}}


Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 1998-2007 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Group::JCMT\label{ORAC::Group::JCMT}\index{ORAC::Group::JCMT}}


JCMT class for dealing with observation groups in ORAC-DR

\subsubsection*{SYNOPSIS\label{ORAC::Group::JCMT_SYNOPSIS}\index{ORAC::Group::JCMT!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Group::JCMT;
\end{verbatim}
\begin{verbatim}
  $Grp = new ORAC::Group::JCMT("group1");
  $Grp->file("group_file")
  $Grp->readhdr;
  $value = $Grp->hdr("KEYWORD");
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Group::JCMT_DESCRIPTION}\index{ORAC::Group::JCMT!DESCRIPTION}}


This module provides methods for handling group objects that
are specific to JCMT. It provides a class derived from \textbf{ORAC::Group::NDF}.
All the methods available to \textbf{ORAC::Group} objects are available
to \textbf{ORAC::Group::JCMT} objects. Some additional methods are supplied.

\subsubsection*{PUBLIC METHODS\label{ORAC::Group::JCMT_PUBLIC_METHODS}\index{ORAC::Group::JCMT!PUBLIC METHODS}}


The following methods are available in this class in addition to
those available from \textbf{ORAC::Group}.

\paragraph*{Constructor\label{ORAC::Group::JCMT_Constructor}\index{ORAC::Group::JCMT!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a \textbf{ORAC::Group::JCMT} object.
This method takes an optional argument containing the
name of the new group. The object identifier is returned.

\begin{verbatim}
   $Grp = new ORAC::Group::JCMT;
   $Grp = new ORAC::Group::JCMT("group_name");
\end{verbatim}


This method calls the base class constructor but initialises
the group with a file suffix of '.sdf' and a fixed part
of '\_grp\_'.

\end{description}
\paragraph*{General Methods\label{ORAC::Group::JCMT_General_Methods}\index{ORAC::Group::JCMT!General Methods}}
\begin{description}

\item[{\textbf{file}}] \mbox{}

This is an extension to the default file() method.
This method accepts a root name for the group file
(independent of sub-instrument) - same as for the base 
class. If a number is supplied the root name is returned
with the appropriate extension relating to the 
sub-instrument order in the current frame.



The number to sub-instrument conversion uses the last frame in the
group to calculate the allowed number of sub-instruments and
the order. Note that this may well not be what you want.
Use the grpoutsub() method if you know the name of the sub-instrument.


\item[{\textbf{file\_from\_bits}}] \mbox{}

Method to return the group filename derived from a fixed
variable part (eg UT) and a group designator (usually obs
number). The full filename is returned (including suffix).

\begin{verbatim}
  $file = $Grp->file_from_bits("UT","num");
\end{verbatim}


Returns file of form UT\_grp\_00num.sdf



Note that this is the filename before sub-instruments
have been taken into account (essentially this is the
default root name for file() - the suffix is stripped).


\item[{\textbf{gui\_id}}] \mbox{}

The file identification for comparison with the \textbf{ORAC::Display}
system. Input argument is the file number (starting from 1).



This routine calculates the current suffix from the group file
name base and prepends a string 'gN' signifying that this is
a group observation and the Nth frame is requested (N is less than
or equal to nfiles()).



The assumption is that file() returns a root name (ie without
a sub-instrument designation). This then allows us to create an
ID based on number and suffix without having to chop the
sub-instrument name off the end.


\item[{\textbf{nfiles}}] \mbox{}

This method returns the number of files currently associated
with the group. What this in fact means is that it returns
the number of files associated with the last member of the 
group (since that is how I construct output names in the
first place). grpoutsub() method is responsible for 
converting this number into a filename via the file() method.

\end{description}
\subsubsection*{NEW METHODS\label{ORAC::Group::JCMT_NEW_METHODS}\index{ORAC::Group::JCMT!NEW METHODS}}


This section describes methods that are available to the
JCMT implementation of ORAC::Group.

\begin{description}

\item[{\textbf{grpoutsub}}] \mbox{}

Method to determine the group filename associated with
the supplied sub-instrument.



This method uses the file() method to determine the
group rootname and then tags it by the specified sub-instrument.

\begin{verbatim}
  $file = $Grp->grpoutsub($sub);
\end{verbatim}

\item[{\textbf{membernamessub}}] \mbox{}

Return list of file names associated with the specified
sub instrument.

\begin{verbatim}
  @names = $Grp->membernamessub($sub)
\end{verbatim}

\item[{\textbf{subs}}] \mbox{}

Returns an array containing all the sub instruments present
in the group (some frames may only have one sub-instrument)

\begin{verbatim}
  @subs = $Grp->subs;
\end{verbatim}


The frames should be able to invoke the subs() method.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Group::JCMT_SEE_ALSO}\index{ORAC::Group::JCMT!SEE ALSO}}


\emph{ORAC::Group}

\subsubsection*{REVISION\label{ORAC::Group::JCMT_REVISION}\index{ORAC::Group::JCMT!REVISION}}


\$Id: JCMT.pm 7426 2008-02-14 23:44:00Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Group::JCMT_COPYRIGHT}\index{ORAC::Group::JCMT!COPYRIGHT}}


Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Index\label{ORAC::Index}\index{ORAC::Index}}


Perl routines for manipulating ORAC index files

\subsubsection*{SYNOPSIS\label{ORAC::Index_SYNOPSIS}\index{ORAC::Index!SYNOPSIS}}
\begin{verbatim}
 use ORAC::Index;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Index_DESCRIPTION}\index{ORAC::Index!DESCRIPTION}}


This module provides subs for manipulating ORAC index files. ORAC
index files consist of whitespace seperated columns containing
information about a particular frame.



In the case of calibration index files, these may also contain rules
for determining the suitability of use for these frames. These consist
of code that is TRUE or FALSE depending on appropriate header values
of the object to be calibrated.

\subsubsection*{PUBLIC METHODS\label{ORAC::Index_PUBLIC_METHODS}\index{ORAC::Index!PUBLIC METHODS}}


The following methods are available in this class.

\paragraph*{Constructor\label{ORAC::Index_Constructor}\index{ORAC::Index!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of an \textbf{ORAC::Index} object.

\begin{verbatim}
  $Index = new ORAC::Index;
  $Index = new ORAC::Index($indexfile, $rulesfile);
\end{verbatim}


Any arguments are passed to the configure() method.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Index_Accessor_Methods}\index{ORAC::Index!Accessor Methods}}
\begin{description}

\item[{\textbf{configure}}] \mbox{}

Takes an index file and a rules file and sets up the index object

\begin{verbatim}
  $Index->configure($indexfile, $rulesfile);
\end{verbatim}

\item[{\textbf{indexfile}}] \mbox{}

Return (or set) the filename of the index file

\begin{verbatim}
  $file = $Index->indexfile;
  $Index->indexfile($file);
\end{verbatim}

\item[{\textbf{rulesok}}] \mbox{}

Returns true if we are using a valid set of rules, false
if the rules were automatically generated from a read of the
index file (and therefore contain no clauses for verification).


\item[{\textbf{indexrulesfile}}] \mbox{}

Return (or set) the filename of the rules file



If the rules file has the magic value of ORAC::Index::NO\_RULES a lightweight
version of the object will be instantiated that does not do any
explicit rules checking. This only works if an index file is being
read (since the rules column names will be read from the index file),
rather than being freshly created (there will be no columns in the
output file!).


\item[{\textbf{rulesref}}] \mbox{}

Returns or sets the reference to the hash containing the rules


\item[{\textbf{indexref}}] \mbox{}

Returns or sets the reference to the hash containing the index


\item[{\textbf{indexkeys}}] \mbox{}

Return all the keys associated with the index file (ie from \texttt{indexref}
method. These can then be used in conjunction with \texttt{indexentry} to obtain
the content of the index.

\begin{verbatim}
 @keys = $index->indexkeys;
\end{verbatim}
\end{description}
\paragraph*{General Methods\label{ORAC::Index_General_Methods}\index{ORAC::Index!General Methods}}
\begin{description}

\item[{slurprules}] \mbox{}

Sets up the index rules in the object. Croaks if it fails.
This converts the index rules file into an internal hash
that can be retrieved with the rulesref() method.


\item[{\textbf{slurpindex}}] \mbox{}

Sets up the index data in the object. Croaks if it fails.  This
converts the index file name into an internal hash that can be
retrieved using the indexref() method.  There is one optional
argument.  The supplied argument is used to control the behaviour of
the read. If the 'usekey' flag is true the first string in each row
(space separated) is used as a key for the index hash.



If 'usekey' is false the key for each row is created 
automatically. This is useful for indexes where the contents 
of the index is more important than any particular key.

\begin{verbatim}
  $index->slurpindex(0); # Auto-generate keys
\end{verbatim}


Default behaviour (ie no args) is to read the key from the
index file (ie usekey=1).


\item[{\textbf{writeindex}}] \mbox{}

writes out the current state of the index object into the index file


\item[{\textbf{add}}] \mbox{}

adds an entry to an index

\begin{verbatim}
  $index->add($name,$hashref)
\end{verbatim}

\item[{\textbf{append\_to\_index}}] \mbox{}

Method to force an append of the specified index entry to the
the index file on disk.

\begin{verbatim}
  $Index->append_to_index($name);
\end{verbatim}


\$name is the name of the key (indexentry) to use to select the
index entry to append [cf the indexentry() method].



This method is intended to be called from the add() method
to speed up index read/write when appending a new entry.
Do not use this method to write a modified entry to the
index file (since the original entry will still be on disk)



No return value.


\item[{\textbf{index\_to\_text}}] \mbox{}

Convert an index entry (in the index hash) to text suitable for
writing to an index file. Called by writeindex() and append\_to\_index()

\begin{verbatim}
  $text = $Ind->index_to_text($entry);
\end{verbatim}


Returns the text string (including the entry name but no carriage 
return).



ARRAY or HASH references are serialised (although the current output
format restricts the use of spaces).


\item[{\textbf{indexentry}}] \mbox{}

Returns a hash containing the key value pairs of the
selected index entry.



Input argument is the index entry name (ie the key in the hash
that returns the information (in an array).



Returns a hash reference if successful, undef if error.


\item[{\textbf{verify}}] \mbox{}

verifies a frame (in the form of a hash reference) against a 
(calibration) index entry (ie by supplying the hash key to the index
entry). An optional third argument is available to turn off warning 
messages -- default is for warning messages to be turned on (true)

\begin{verbatim}
  $result = $index->verify(indexkey, \%hash, $warn);
\end{verbatim}


Returns undef (error), 0 (not suitable), or 1 (suitable)


\item[{\textbf{choosebydt}}] \mbox{}

Chooses the optimal (nearest in time to an observation) calibration
frame from the index hash

\begin{verbatim}
  $calibration = $Index->choosebydt($key, \%header, $warn);
\end{verbatim}


Key is the name of the field that should be compared (eg ORACTIME)
and \%header is the hash containing the header values that are to
be compared with the index rules. \$warn is an optional third argument
that can be used to turn off warning messages from verify (default
is to report messages - true).



This method returns the name of the calibration frame closest in 
time that has met the selection criteria.



If a suitable calibration can not be found an undefined value is returned.


\item[{\textbf{chooseby\_positivedt}}] \mbox{}

Chooses the calibration frame closest in time from above by looking 
in the index file (ie difference between the index file entry and
the current frame is positive).

\begin{verbatim}
  $calibration = $Index->chooseby_positivedt($key, \%header, $warn);
\end{verbatim}


Key is the name of the field that should be compared (eg ORACTIME)
and \%header is the hash containing the header values that are to
be compared with the index rules. \$warn is an optional third argument
that can be used to turn off warning messages from verify (default
is to report messages - true).



This method returns the name of the calibration frame closest in 
time that has met the selection criteria.



This is similar to the choosebydt() method except that only
calibrations taken after the current time (read from the
header) can be chosen. undef is returned if no suitable
calibration frames can be found (eg because we are running
on-line and they have not even been taken yet).


\item[{\textbf{chooseby\_negativedt}}] \mbox{}

Chooses the calibration frame closest in time from below by looking 
in the index file (ie delta time between the index entry and the 
current frame is negative).

\begin{verbatim}
  $calibration = $Index->chooseby_negativedt($key, \%header, $warn);
\end{verbatim}


Key is the name of the field that should be compared (eg ORACTIME)
and \%header is the hash containing the header values that are to
be compared with the index rules. \$warn is an optional third argument
that can be used to turn off warning messages from verify (default
is to report messages - true).



This method returns the name of the calibration frame closest in 
time that has met the selection criteria.



This is similar to the choosebydt() method except that only
calibrations taken before the current time (read from the
header) can be chosen. undef is returned if no suitable 
calibration can be found.


\item[{\textbf{choosebydt\_generic}}] \mbox{}

Internal routine for handling calibraion matches using a 
time difference.

\begin{verbatim}
  $calibration = $Index->choosebydt_generic(TYPE, $key, \%header, $warn);
\end{verbatim}


TYPES can be 'ABS' (chooses the closest calibration in time), 
'POSITIVE' (chooses the closest in time from calibrations earlier
than the current header) and 'NEGATIVE' (chooses calibrations after
the current observation [as described by \%header]).



KEY, HEADER and WARN are described in the choosebydt() documentation.


\item[{\textbf{cmp\_with\_hash}}] \mbox{}

Compares each index entry with the values in the supplied hash
(supplied as a hash reference). The key to the first matching 
index entry is returned. undef is returned if no match could be 
found.

\begin{verbatim}
  $key = $index->cmp_with_hash(\%hash);
  $key = $index->cmp_with_hash({ key1 => 'value',
                                 key2 => 'value2'});
\end{verbatim}


Use the indexentry() method to convert this key into the actual
index entry. Note that warning messages are turned off during the
verification stage since we are not interested in failed matches.



Returns 'undef' if no match is found or if no argument is supplied
[or that argument itself is undef]


\item[{\textbf{scanindex}}] \mbox{}

Scan the index file for entries that match the supplied constraints.
Only string equality constraints are supported. For more complex scans,
consider using the rules system directly.

\begin{verbatim}
  @entries = $index->scanindex( UNITS => 'ARCSEC', FILTER => '850W' );
\end{verbatim}


The return entries are not sorted into any particular order.



Regular expression matching is supported by supplying a string
beginning and ending with forward slashes (e.g. '/\^{}g/' will match a
string starting with 'g').



Matching against the index entry's ID (i.e. the first column in an
index) can be done by supplying the hash key ':ID'.


\item[{\textbf{\_sanity\_check}}] \mbox{}

Make sure that the rules and index entry are consistent.

\begin{verbatim}
 $Idx->_sanity_check( \@calibdata );
\end{verbatim}


Takes the entry data as argument (does not try to 
work out that information itself).



Will die if they are inconsistent.

\end{description}
\subsubsection*{SEE ALSO\label{ORAC::Index_SEE_ALSO}\index{ORAC::Index!SEE ALSO}}


\emph{ORAC::Index::Extern}

\subsubsection*{REVISION\label{ORAC::Index_REVISION}\index{ORAC::Index!REVISION}}


\$Id: Index.pm 7930 2008-06-11 00:29:15Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Index_COPYRIGHT}\index{ORAC::Index!COPYRIGHT}}


Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::LogFile\label{ORAC::LogFile}\index{ORAC::LogFile}}


Routines for generating log files

\subsubsection*{SYNOPSIS\label{ORAC::LogFile_SYNOPSIS}\index{ORAC::LogFile!SYNOPSIS}}
\begin{verbatim}
  use ORAC::LogFile;
\end{verbatim}
\begin{verbatim}
  $log = new ORAC::LogFile('logfile.dat');
  $log->header(@header);
  $log->addentry(@lines);
  $log->timestamp(1);
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::LogFile_DESCRIPTION}\index{ORAC::LogFile!DESCRIPTION}}


Provide simple interface to generation of logfiles (eg logging
of seeing statistics, photometry results or pointing logs).

\subsubsection*{PUBLIC METHODS\label{ORAC::LogFile_PUBLIC_METHODS}\index{ORAC::LogFile!PUBLIC METHODS}}


The following methods are available:

\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of ORAC::LogFile and associate it with the 
specified log file.

\begin{verbatim}
  $log = new ORAC::LogFile($logfile);
\end{verbatim}


If no argument is supplied, the logfile name must be set explcitly
by using the logfile() method.



This constructor does not create the logfile itself.


\item[{\textbf{logfile}}] \mbox{}

Return or set the name of the logfile associated with
this instance. Usually set directly by the constructor.

\begin{verbatim}
  $logfile = $log->logfile;
  $log->logfile($logfile);
\end{verbatim}

\item[{\textbf{timestamp}}] \mbox{}

Control whether a timestamp is prepended to each entry
written to the logfile. Default is to not print a timestamp.

\begin{verbatim}
  $log->timestamp(1);
  $use = $log->timestamp;
\end{verbatim}


The timestamp will be in UT.


\item[{\textbf{header}}] \mbox{}

Write header information to the file. Header information is only
written if the logfile does not previously exist (since if the file
exists already a header is not required). If the logfile does not
exist the logfile is created by this method and all arguments written
to it.  A newline character "$\backslash$n" is automatically appended to each
line.

\begin{verbatim}
  $log->header($line1, $line2);
  $log->header(@lines);
\end{verbatim}

\item[{\textbf{addentry}}] \mbox{}

Add a log entry. Multiple lines can be supplied (eg as an array).
Each line is appended to the logfile (appending a newline "$\backslash$n"
character to each and prepending a timestamp if required).

\begin{verbatim}
  $log->addentry($line);
  $log->addentry(@lines);
\end{verbatim}


The logfile is closed each time this method is invoked.

\end{description}
\subsubsection*{REVISION\label{ORAC::LogFile_REVISION}\index{ORAC::LogFile!REVISION}}


\$Id: LogFile.pm 2435 2001-04-28 02:46:09Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::LogFile_COPYRIGHT}\index{ORAC::LogFile!COPYRIGHT}}


Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::Loop\label{ORAC::Loop}\index{ORAC::Loop}}


Data loops for ORACDR

\subsubsection*{SYNOPSIS\label{ORAC::Loop_SYNOPSIS}\index{ORAC::Loop!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Loop;
\end{verbatim}
\begin{verbatim}
  $frm = orac_loop_list($class, $utdate, \@list, $skip);
\end{verbatim}
\begin{verbatim}
  $frm = orac_loop_inf($class, $utdate, \@list);
\end{verbatim}
\begin{verbatim}
  $frm = orac_loop_wait($class, $utdate, \@list, $skip);
\end{verbatim}
\begin{verbatim}
  $frm = orac_loop_flag($class, $utdate, \@list, $skip);
\end{verbatim}
\begin{verbatim}
  $frm = orac_loop_task( $class, \@array, $skip );
\end{verbatim}
\begin{verbatim}
  $frm = orac_loop_file($class, \@list );
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Loop_DESCRIPTION}\index{ORAC::Loop!DESCRIPTION}}


This module provides a set of loop handling routines for ORACDR.
Each subroutine accepts the same arguments and returns the current
observation number (or undef if there was an error or if the loop
should be terminated).



A new  Frame object is returned of class \$class that has been configured
for the new file (ie a \texttt{\$Frm-$>$configure} method has been run)



It is intended that this routine is called inside an infinite while
loop with the same @list array. This array is modified by the loop
routines so that they can keep track of the 'next' frame number.



If a filename can not be found (eg it doesnt exist or the list has
been processed) undef is returned.



The skip flag is used to indicate whether the loop should skip
forward if the current observation number can not be found
but a higher numbered observation is present. Currently no loops
will go back to missing observations if they appear after a higher
number (eg observation 10 appears before observation 9!)

\subsubsection*{LOOP SUBROUTINES\label{ORAC::Loop_LOOP_SUBROUTINES}\index{ORAC::Loop!LOOP SUBROUTINES}}


The following loop facilities are available:

\begin{description}

\item[{\textbf{orac\_loop\_list}}] \mbox{}

Takes a list of numbers and returns back a frame object 
for each number (one frame object per call)

\begin{verbatim}
  $Frm = orac_loop_list($class, $UT, \@array, $noskip);
\end{verbatim}


undef is returned on error or when all members of the
list have been returned. If the 'skip' flag is true
missing files in the list will be ignored and the next
element of the list selected. If 'skip' is false
the loop will abort if the file is not present


\item[{\textbf{orac\_loop\_inf}}] \mbox{}

Checks for the frame stored in the first element of the supplied array
and returns the Frame object if the file exists. The number is incremented
such that the next observation is returned next time the routine is
called.

\begin{verbatim}
  $Frm = orac_loop_inf($class, $ut, \@array);
\end{verbatim}


undef is returned on error or when there are no more data files
available.



This loop does not have a facility for skipping files when observations
are not present. This behaviour is obtained by combining 
orac\_check\_data\_dir with the list looping option so that the last
observation number can be determined before running the loop. The skip
flag is ignored in this loop.


\item[{\textbf{orac\_loop\_wait}}] \mbox{}

Waits for the specified file to appear in the directory.
A timeout of 12 hours is hard-wired in initially -- undef
is returned if the timeout is exceeded.

\begin{verbatim}
  $frm = orac_loop_wait($class, $utdate, \@list, $skip);
\end{verbatim}


The first member of the array is used to keep track of the
current observation number. This element is incremented so that
the following observation is returned when the routine is called
subsequently. This means that this loop is similar to using the
'-from' option in conjunction with the 'inf' loop except that
new data is expected.



The loop will return undef (i.e. terminate looping) if the
supplied array contains undef in the first entry.



The skip flag is used to indicate whether the loop should skip
forward if the current observation number can not be found
but a higher numbered observation is present.



If no data can be found, the directory is scanned every few seconds
(hard-wired into the routine). A dot is printed to the screen after
a specified number of scans (default is 1 dot per scan and one scan every
2 seconds).


\item[{\textbf{orac\_loop\_flag}}] \mbox{}

Waits for the specified file to appear in the directory
by looking for the appearance of the associated flag file.
A timeout of 60 minutes is hard-wired in initially -- undef
is returned if the timeout is exceeded.

\begin{verbatim}
  $frm = orac_loop_flag($class, $utdate, \@list, $skip);
\end{verbatim}


The first member of the array is used to keep track of the
current observation number. This element is incremented so that
the following observation is returned when the routine is called
subsequently. This means that this loop is similar to using the
'-from' option in conjunction with the 'inf' loop except that
new data is expected.



The loop will return undef (i.e. terminate looping) if the
supplied array contains undef in the first entry.


\item[{\textbf{orac\_loop\_file}}] \mbox{}

Takes a list of files and returns back frame objects for the files,
removing them from the input array.

\begin{verbatim}
  @Frms = orac_loop_file($class, $ut, \@array, $skip );
\end{verbatim}


undef is returned on error or if the list of files is empty.



The UT and skip parameters are ignored.



The input filenames are assumed to come from \$ORAC\_DATA\_IN if they use
a relative path.


\item[{\textbf{orac\_loop\_task}}] \mbox{}

In this scheme, ORAC-DR obtains data triggers from a running task
that is updating its parameters each time new data are available.

\begin{verbatim}
  $Frm = orac_loop_task( $class, \@array, $skip );
\end{verbatim}


The array supplied to this routine is used to store the next frame
number of interest (to prevent returning the same data file more than once).



In this looping scheme the UT date and skip flags are ignored since we
only know about the data most recently written.

\end{description}
\subsubsection*{OTHER EXPORTED SUBROUTINES\label{ORAC::Loop_OTHER_EXPORTED_SUBROUTINES}\index{ORAC::Loop!OTHER EXPORTED SUBROUTINES}}
\begin{description}

\item[{\textbf{orac\_check\_data\_dir}}] \mbox{}

Routine to check the input data directory (ORAC\_DATA\_IN) for
files in order to see whether files exist with a higher number
than the supplied number. The routine is supplied with a class name,
UT date and current observation number. An additional argument
is provided to determine whether data files or flag files should
be used for the directory search.

\begin{verbatim}
   $next = orac_check_data_dir($class, $current, $flag);
   ($next, $high) = orac_check_data_dir($class, $current, $flag);
\end{verbatim}


If called in a scalar context, the return argument is the next
observation in the sequence. If called in an array context, two
arguments are returned: the next observation number and the highest
observation number.



undef (or undef,undef) is returned if no higher observations can be
found. If it is necessary to check for the existence of current
file as well (eg via a data detection loop) then simply decrement the
supplied argument by 1.



This routine is used in conjunction with the -from loop (where we
dont know the end) and the waiting loops where we are not sure whether
new data have been written to disk but missing the next observation.



This routine does NOT look in ORAC\_DATA\_OUT.



A global variables (@LIST) is used to speed up the sorting by storing
a list of observation numbers that have previously been shown to have a lower
number than required (NOT YET IMPLEMENTED).

\end{description}
\subsubsection*{PRIVATE SUBROUTINES\label{ORAC::Loop_PRIVATE_SUBROUTINES}\index{ORAC::Loop!PRIVATE SUBROUTINES}}


The following subroutines are not exported.

\begin{description}

\item[{\textbf{link\_and\_read}}] \mbox{}

General subroutine for converting ut and number into file
and creating a Frame object or multiple frame objects (depending
on instrument and mode).

\begin{verbatim}
  @frm = link_and_read($class, $ut, $obsnum, $flag)
\end{verbatim}
\begin{verbatim}
  @frm = link_and_read($class, $ut, $obsnum, $flag, \@reflist)
\end{verbatim}


The five parameters are:

\begin{description}

\item[{class}] \mbox{}

Class of Frame object


\item[{ut}] \mbox{}

UT date in YYYYMMDD


\item[{obsnum}] \mbox{}

Observation number


\item[{flag}] \mbox{}

If filename(s) is to come from flag file


\item[{reflist}] \mbox{}

Reference to array of files names that should be excluded from
the list of files read from the flag files (if flag files are non-zero).
This allows for flag files that can change length during an observation
(potentially allowing the pipeline to stop before the full observation
is complete but after data files start appearing for the observation).
The contents of this array are updated on exit to include the files that
were just read. This allows the reference list to be resubmitted
to this routine.

\end{description}


Empty list is returned on error.



Returns 1 or more configured frame objects on success.


\item[{\textbf{orac\_sleep}}] \mbox{}

Pause the checking for new data files by the specified number of seconds.

\begin{verbatim}
  $time = orac_sleep($pause);
\end{verbatim}


Where \$pause is the number of seconds to wait and \$time is the number
of seconds actually waited. Seconds can be fractional.



If the Tk system is loaded this routine will actually do a Tk event loop
for the required number of seconds. This is so that the X screen will
be refreshed. Currently the only test is the Tk is loaded, not that
we are actually using Tk.....


\item[{\textbf{\_files\_there}}] \mbox{}

Return true if all the specified files are present.

\begin{verbatim}
 if (!_files_there( @files ) {
   ...
 }
\end{verbatim}


Returns false is no files are supplied.


\item[{\textbf{\_files\_nonzero}}] \mbox{}

Return true if all the specified files are present with
a size greater than 0 bytes

\begin{verbatim}
 if (_files_nonzero( @files ) {
   ...
 }
\end{verbatim}


Returns false if no files are supplied.


\item[{\textbf{\_to\_abs\_path}}] \mbox{}

Convert a filename(s) relative to ORAC\_DATA\_IN to an absolute path.

\begin{verbatim}
  @abs = _to_abs_path( @rel );
\end{verbatim}


Does not affect absolute paths.



In scalar context, returns the first path.


\item[{\textbf{\_clean\_path}}] \mbox{}

Splits path up and resolves "../" entries. This is done because normally if you
use a symlink ../ ends up on the other end of the directory symlink.

\begin{verbatim}
 $clean = _clean_path( $notclean );
\end{verbatim}


This may be dangerous....


\item[{\textbf{\_convert\_and\_link}}] \mbox{}

Given the supplied file names, convert and link each file to ORAC\_DATA\_OUT.
If successful returns a list of \texttt{ORAC::Frame} objects derived from the input frame.

\begin{verbatim}
  @frames = _convert_and_link( $Frm, @files );
\end{verbatim}

\item[{\textbf{\_convert\_and\_link\_nofrm}}] \mbox{}

This is the low level file conversion/linking routine used by 
\texttt{\_convert\_and\_link}.

\begin{verbatim}
  @converted = _convert_and_link_nofrm( $infmt, $outfmt, @input);
\end{verbatim}


Given an input and output format and a list of files, returns
the modified files. Returning an empty list indicates an error (but
only if @input contained some filenames).


\item[{\textbf{\_read\_flagfiles}}] \mbox{}

Read the specified flag files and return the contents.

\end{description}
\subsubsection*{REVISION\label{ORAC::Loop_REVISION}\index{ORAC::Loop!REVISION}}


\$Id: Loop.pm 8087 2008-08-14 20:22:34Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Loop_COPYRIGHT}\index{ORAC::Loop!COPYRIGHT}}


Copyright (C) 1998-2006 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Msg::Control::AMS\label{ORAC::Msg::Control::AMS}\index{ORAC::Msg::Control::AMS}}


Control and initialise ADAM messaging from ORAC

\subsubsection*{SYNOPSIS\label{ORAC::Msg::Control::AMS_SYNOPSIS}\index{ORAC::Msg::Control::AMS!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Msg::Control::AMS;
\end{verbatim}
\begin{verbatim}
  $ams = new ORAC::Msg::Control::AMS(1);
  $ams->init;
\end{verbatim}
\begin{verbatim}
  $ams->messages(0);
  $ams->errors(1);
  $ams->timeout(30);
  $ams->stderr(\*ERRHANDLE);
  $ams->stdout(\*MSGHANDLE);
  $ams->paramrep( sub { return "!" } );
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Msg::Control::AMS_DESCRIPTION}\index{ORAC::Msg::Control::AMS!DESCRIPTION}}


Methods to initialise the ADAM messaging system (AMS) and control the
behaviour.

\subsubsection*{METHODS\label{ORAC::Msg::Control::AMS_METHODS}\index{ORAC::Msg::Control::AMS!METHODS}}


The following methods are available:

\paragraph*{Constructor\label{ORAC::Msg::Control::AMS_Constructor}\index{ORAC::Msg::Control::AMS!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of Starlink::AMS::Init.
If a true argument is supplied the messaging system is also
initialised via the init() method.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::Msg::Control::AMS_Accessor_Methods}\index{ORAC::Msg::Control::AMS!Accessor Methods}}
\begin{description}

\item[{\textbf{messages}}] \mbox{}

Method to set whether standard messages returned from monoliths
are printed or not. If set to true the messages are printed
else they are ignored.

\begin{verbatim}
  $current = $ams->messages;
  $ams->messages(0);
\end{verbatim}


Default is to print all messages.


\item[{\textbf{errors}}] \mbox{}

Method to set whether error messages returned from monoliths
are printed or not. If set to true the errors are printed
else they are ignored.

\begin{verbatim}
  $current = $ams->errors;
  $ams->errors(0);
\end{verbatim}


Default is to print all messages.


\item[{\textbf{timeout}}] \mbox{}

Set or retrieve the timeout (in seconds) for some of the ADAM messages.
Default is 30 seconds.

\begin{verbatim}
  $ams->timeout(10);
  $current = $ams->timeout;
\end{verbatim}

\item[{\textbf{stderr}}] \mbox{}

Set and retrieve the current filehandle to be used for printing
error messages. Default is to use STDERR.


\item[{\textbf{stdout}}] \mbox{}

Set and retrieve the current filehandle to be used for printing
normal ADAM messages. Default is to use STDOUT. This can be
a tied filehandle (eg one generated by ORAC::Print).


\item[{\textbf{paramrep}}] \mbox{}

Set and retrieve the code reference that will be executed if
the parameter system needs to ask for a parameter.
Default behaviour is to call a routine that simply prompts
the user for the required value. The supplied subroutine
should accept three arguments (the parameter name, prompt string and
default value) and should return the required value.

\begin{verbatim}
  $self->paramrep(\&mysub);
\end{verbatim}


A simple check is made to make sure that the supplied argument
is a code reference.



Warning: It is possible to get into an infinite loop if you try
to continually return an unacceptable answer.

\end{description}
\paragraph*{General Methods\label{ORAC::Msg::Control::AMS_General_Methods}\index{ORAC::Msg::Control::AMS!General Methods}}
\begin{description}

\item[{\textbf{init}}] \mbox{}

Initialises the ADAM messaging system. This routine should always be
called before attempting to control I-tasks.



A relay task is spawned in order to test that the messaging system
is functioning correctly. The relay itself is not necessary for the
non-event loop implementation. If this command hangs then it is
likely that the messaging system is not running correctly (eg
because the system was shutdown uncleanly.

\begin{verbatim}
  $ams->init( $preserve );
\end{verbatim}


For ORAC-DR the message system directories are set to
values that will allow multiple oracdr pipelines to run
without interfering with each other.



Scratch files are written to ORACDR\_TMP directory if defined,
else ORAC\_DATA\_OUT is used. By default ADAM\_USER is set
to be a directory in the scratch file directory. This can be
overridden by supplying an optional flag.



If \texttt{\$preserve} is true, ADAM\_USER will be left untouched. This
enables the pipeline to talk to tasks created by other applications
but does mean that the users ADAM\_USER may be filled with unwanted
temporary files. It also has the added problem that on shutdown
the ADAM\_USER directory is removed by ORAC-DR, this should not happen
if \texttt{\$preserve} is true but is not currently guaranteed.

\end{description}
\subsubsection*{CLASS METHODS\label{ORAC::Msg::Control::AMS_CLASS_METHODS}\index{ORAC::Msg::Control::AMS!CLASS METHODS}}
\begin{description}

\item[{\textbf{require\_uniqid}}] \mbox{}

Returns true, indicating that the ADAM "engine" identifiers must
be unique in the client each time an engine is launched.

\end{description}
\subsubsection*{REQUIREMENTS\label{ORAC::Msg::Control::AMS_REQUIREMENTS}\index{ORAC::Msg::Control::AMS!REQUIREMENTS}}


This module requires the Starlink::AMS::Init module.

\subsubsection*{SEE ALSO\label{ORAC::Msg::Control::AMS_SEE_ALSO}\index{ORAC::Msg::Control::AMS!SEE ALSO}}


\emph{Starlink::AMS::Init}

\subsubsection*{REVISION\label{ORAC::Msg::Control::AMS_REVISION}\index{ORAC::Msg::Control::AMS!REVISION}}


\$Id: AMS.pm 7087 2007-08-13 22:28:20Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Msg::Control::AMS_COPYRIGHT}\index{ORAC::Msg::Control::AMS!COPYRIGHT}}


Copyright (C) 1998-2000 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Msg::Task::ADAM\label{ORAC::Msg::Task::ADAM}\index{ORAC::Msg::Task::ADAM}}


Load and control ADAM tasks

\subsubsection*{SYNOPSIS\label{ORAC::Msg::Task::ADAM_SYNOPSIS}\index{ORAC::Msg::Task::ADAM!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Msg::Task::ADAM;
\end{verbatim}
\begin{verbatim}
  $kap = new ORAC::Msg::Task::ADAM("kappa","/star/bin/kappa/kappa_mon");
\end{verbatim}
\begin{verbatim}
  $status           = $kap->obeyw("task", "params");
  $status           = $kap->set("task", "param","value");
  ($status, @values) = $kap->get("task", "param");
  ($dir, $status)   = $kap->control("default","dir");
  $kap->control("par_reset");
  $kap->resetpars;
  $kap->cwd("dir");
  $cwd = $kap->cwd;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Msg::Task::ADAM_DESCRIPTION}\index{ORAC::Msg::Task::ADAM!DESCRIPTION}}


Provide methods for loading and communicating with ADAM monoliths.
This module conforms to the ORAC messaging standard. This is an
ORAC interface to the Starlink::AMS::Task module.



By default all tasks loaded by this module will be terminated
on exit from perl.

\subsubsection*{METHODS\label{ORAC::Msg::Task::ADAM_METHODS}\index{ORAC::Msg::Task::ADAM!METHODS}}


The following methods are available:

\paragraph*{Constructor\label{ORAC::Msg::Task::ADAM_Constructor}\index{ORAC::Msg::Task::ADAM!Constructor}}
\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a ORAC::Msg::Task::ADAM object.

\begin{verbatim}
  $obj = new ORAC::Msg::Task::ADAM;
  $obj = new ORAC::Msg::Task::ADAM("name_in_message_system","monolith");
  $obj = new ORAC::Msg::Task::ADAM("name_in_message_system","monolith"
                                    { TASKTYPE => 'A'} );
\end{verbatim}


If supplied with arguments (matching those expected by load() ) the
specified task will be loaded upon creating the object. If the load()
fails then undef is returned (which will not be an object reference).

\end{description}
\paragraph*{General Methods\label{ORAC::Msg::Task::ADAM_General_Methods}\index{ORAC::Msg::Task::ADAM!General Methods}}
\begin{description}

\item[{\textbf{load}}] \mbox{}

Load a monolith and set up the name in the messaging system.
This task is called by the 'new' method.

\begin{verbatim}
  $status = $obj->load("name","monolith_binary",{ TASKTYPE => 'A' });
\end{verbatim}


If the second argument is omitted it is assumed that the binary
is already running and can be called by "name".



If a path to a binary with name "name" already exists then the monolith
is not loaded.



Options (in the form of a hash reference) can be supplied
in order to configure the monolith. Currently supported options
are

\begin{verbatim}
  TASKTYPE  - can be 'A' for A-tasks or 'I' for I-tasks
\end{verbatim}

\item[{\textbf{obeyw}}] \mbox{}

Send an obey to a task and wait for a completion message

\begin{verbatim}
  $status = $obj->obeyw("action","params");
\end{verbatim}

\item[{\textbf{get}}] \mbox{}

Obtain the value of a parameter

\begin{verbatim}
 ($status, @values) = $obj->get("task", "param");
\end{verbatim}

\item[{\textbf{mget}}] \mbox{}

Get multiple parameter values. This method is a wrapper around
the get() method, returning the values in a hash indexed
by parameter name. If a parameter has only one value it will
be stored in the hash directly, else if multiple values are
returned for a parameter a reference to an array will be stored
in the return hash.

\begin{verbatim}
  ($status, %params) = $obj->mget("task", @params);
\end{verbatim}


Status will only be good if all parameter gets return good
status. Status will take on the last bad status value but
an attempt will be made to get all parameter values even if
some return with bad status.


\item[{\textbf{set}}] \mbox{}

Set the value of a parameter

\begin{verbatim}
  $status = $obj->set("task", "param", "newvalue");
\end{verbatim}

\item[{\textbf{control}}] \mbox{}

Send CONTROL messages to the monolith. The type of control
message is specified via the first argument. Allowed values are:

\begin{verbatim}
  default:  Return or set the current working directory
  par_reset: Reset all parameters associated with the monolith.
\end{verbatim}
\begin{verbatim}
  ($current, $status) = )$obj->control("type", "value")
\end{verbatim}


"value" is only relevant for the "default" type and is used
to specify a new working directory. \$current is always returned
even if it is undefined.



These commands are synonymous with the cwd() and resetpars()
methods.


\item[{\textbf{resetpars}}] \mbox{}

Reset all parameters associated with a monolith

\begin{verbatim}
  $status = $obj->resetpars;
\end{verbatim}

\item[{\textbf{cwd}}] \mbox{}

Set and retrieve the current working directory of the monolith

\begin{verbatim}
  ($cwd, $status) = $obj->cwd("newdir");
\end{verbatim}

\item[{\textbf{contactw}}] \mbox{}

This method will not return unless the monolith can be contacted.
It only returns with a timeout. Returns a '1' if we contacted okay
and a '0' if we timed out. It will timeout if it takes longer than
specified in \texttt{ORAC::Msg::ADAM::Control-$>$timeout}.


\item[{\textbf{contact}}] \mbox{}

This method can be used to determine whether the object can
contact a monolith. Returns a 1 if we can contact a monolith and
a zero if we cant.


\item[{\textbf{pid}}] \mbox{}

Returns process id of forked task.
Returns undef if there is no external task.

\end{description}
\subsubsection*{REQUIREMENTS\label{ORAC::Msg::Task::ADAM_REQUIREMENTS}\index{ORAC::Msg::Task::ADAM!REQUIREMENTS}}


This module requires the Starlink::AMS::Task module.

\subsubsection*{SEE ALSO\label{ORAC::Msg::Task::ADAM_SEE_ALSO}\index{ORAC::Msg::Task::ADAM!SEE ALSO}}


\emph{Starlink::AMS::Task}

\subsubsection*{REVISION\label{ORAC::Msg::Task::ADAM_REVISION}\index{ORAC::Msg::Task::ADAM!REVISION}}


\$Id: ADAM.pm 7812 2008-05-21 02:27:40Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::Msg::Task::ADAM_COPYRIGHT}\index{ORAC::Msg::Task::ADAM!COPYRIGHT}}


Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council. All Rights Reserved.



This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.



This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.



You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

\subsection{ORAC::Print\label{ORAC::Print}\index{ORAC::Print}}


ORAC output message printing

\subsubsection*{SYNOPSIS\label{ORAC::Print_SYNOPSIS}\index{ORAC::Print!SYNOPSIS}}
\begin{verbatim}
  use ORAC::Print qw/:func/;
\end{verbatim}
\begin{verbatim}
  orac_print("text",'magenta');
  orac_err("error text",'red');
\end{verbatim}
\begin{verbatim}
  orac_err("error text");
  orac_print("some text");
  orac_warn("some warning");
  orac_throw("error text");
\end{verbatim}
\begin{verbatim}
  $value = orac_read("Prompt");
\end{verbatim}
\begin{verbatim}
  $prt = new ORAC::Print;
  $prt->out("Message","colour");
  $prt->err("Error message"); 
  $prt->war("warning message");
  $prt->errcol("red");
  $prt->outcol("magenta");
  $prt->errbeep(1);
\end{verbatim}
\begin{verbatim}
  tie *HANDLE, 'ORAC::Print', $ptr;
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::Print_DESCRIPTION}\index{ORAC::Print!DESCRIPTION}}


This module provides commands for printing messages from ORAC
software. Commands are provided for printing error messages, warning
messages and information messages. The final output location of these
messages is controlled by the object configuration.



If the \texttt{ORAC::Print::TKMW} variable is set, it is assumed that this
is the Tk object referring to the MainWindow, and the
\texttt{Tk-$>$update()} method is run whenever the \texttt{orac\_*} commands are
executed via the method in the ORAC::Event class.  This can be used to 
keep a Tk log window updating even though no X-events are being processed.



A simplified interface to Term::ReadLine is provided for use with
the orac\_read command. This can only be used on STDIN/STDOUT and
is not object-oriented.

\subsubsection*{NON-OO INTERFACE\label{ORAC::Print_NON-OO_INTERFACE}\index{ORAC::Print!NON-OO INTERFACE}}


A simplified non-object oriented interface is provided.
These routines are exported into the callers namespace by default
and are the commands that should be used by primitive writers.

\begin{description}

\item[{orac\_print ( text , [colour])}] \mbox{}

Print the supplied text to the ORAC output device(s)
using the (optional) supplied colour.



If the colour is not specified the default value is used (magenta
for primtives).


\item[{orac\_say( text, [colour] )}] \mbox{}

Print the supplied text to the ORAC output device(s) using the (optional) supplied colour. A carriage return is automatically appended to the text to be printed.


\item[{orac\_warn( text, [colour])}] \mbox{}

Print the supplied text as a warning message using the supplied
colour.


\item[{orac\_carp( text, callers, [colour])}] \mbox{}

Prints the supplied text as a warning message and appends the line number
and name of the parent primitive. This information is obtained from the
standard \$\_PRIM\_CALLERS\_ variable available to each primitive.


\item[{orac\_err( text, [colour])}] \mbox{}

Print the supplied text as an error message using the supplied
colour.


\item[{orac\_throw( text, [colour])}] \mbox{}

Identical to \texttt{orac\_err} except that an exception is thrown (see
\texttt{ORAC::Error}) of type \texttt{ORAC::Error::FatalError} immediately after
the text message has been printed.


\item[{orac\_debug( text)}] \mbox{}

Print the supplied text as a debug message using the supplied
colour.


\item[{orac\_read(prompt)}] \mbox{}

Read a value from standard input. This is simply a layer
on top of Term::ReadLine.

\begin{verbatim}
  $value = orac_read($prompt);
\end{verbatim}


There is no Object-oriented version of this routine. It always
uses STDIN for input and STDOUT for output.


\item[{\textbf{orac\_print\_prefix}}] \mbox{}

Set the prefix to be used by \texttt{orac\_print} in all output.

\begin{verbatim}
  orac_prefix( "ORAC-DR says:" );
\end{verbatim}

\item[{\textbf{orac\_printp}}] \mbox{}

As for \texttt{orac\_print} but includes the prefix that has been specified
by using \texttt{orac\_print\_prefix}.

\begin{verbatim}
 orac_printp( $text, $color );
\end{verbatim}

\item[{\textbf{orac\_sayp}}] \mbox{}

As for \texttt{orac\_say} but includes the prefix that has been specified by using \texttt{orac\_print\_prefix}

\begin{verbatim}
  orac_sayp( $text, $color );
\end{verbatim}

\item[{\textbf{orac\_warnp}}] \mbox{}

As for \texttt{orac\_warn} but includes the prefix that has been specified
by using \texttt{orac\_print\_prefix}.

\begin{verbatim}
 orac_warnp( $text, $color );
\end{verbatim}

\item[{\textbf{orac\_errp}}] \mbox{}

As for \texttt{orac\_err} but includes the prefix that has been specified
by using \texttt{orac\_print\_prefix}.

\begin{verbatim}
 orac_errp( $text, $color );
\end{verbatim}
\end{description}
\subsubsection*{OO INTERFACE\label{ORAC::Print_OO_INTERFACE}\index{ORAC::Print!OO INTERFACE}}


The following methods are available:

\paragraph*{Constructors\label{ORAC::Print_Constructors}\index{ORAC::Print!Constructors}}
\begin{description}

\item[{new()}] \mbox{}

Object constructor. The object is returned.

\end{description}
\paragraph*{Instance Methods\label{ORAC::Print_Instance_Methods}\index{ORAC::Print!Instance Methods}}
\begin{description}

\item[{debugmsg}] \mbox{}

Turns debugging messages on or off. Default is off.


\item[{outcol(colour)}] \mbox{}

Retrieve (or set) the colour currently used for printing output
messages.

\begin{verbatim}
  $col = $prt->outcol;
  $prt->outcol('red');
\end{verbatim}


Currently no check is made that the supplied colour is acceptable.


\item[{warncol(colour)}] \mbox{}

Retrieve (or set) the colour currently used for printing warning
messages.

\begin{verbatim}
  $col = $prt->warncol;
  $prt->warncol('red');
\end{verbatim}


Currently no check is made that the supplied colour is acceptable.


\item[{errcol(colour)}] \mbox{}

Retrieve (or set) the colour currently used for printing error
messages.

\begin{verbatim}
  $col = $prt->errcol;
  $prt->errcol('red');
\end{verbatim}


Currently no check is made that the supplied colour is acceptable.


\item[{prefix}] \mbox{}

String that is prepended to all messages printed by this class.
Default is to have no prefix.

\begin{verbatim}
  $prefix = $prt->prefix;
  $prt->prefix('Obs52');
\end{verbatim}

\item[{outpre}] \mbox{}

Prefix that is prepended to all strings printed with the
out() method. Default is to have no prefix.

\begin{verbatim}
  $pre = $prt->outpre;
  $prt->outpre('ORAC says:');
\end{verbatim}

\item[{warpre}] \mbox{}

Prefix that is prepended to all strings printed with the
out() method. Default is to have the string 'Warning:' prepended.

\begin{verbatim}
  $pre = $prt->warpre;
  $prt->warpre('ORAC Warning:');
\end{verbatim}

\item[{errpre}] \mbox{}

Prefix that is prepended to all strings printed with the
out() method. Default is to have the string 'Error:' prepended.

\begin{verbatim}
  $pre = $prt->errpre;
  $prt->errpre('ORAC Error:');
\end{verbatim}

\item[{outhdl}] \mbox{}

Output file handle(s). These are the filehandles that are used
to send all output messages. Multiple filehandles can be supplied.
Returns an IO::Tee object that can be used as a single filehandle.

\begin{verbatim}
  $Prt->outhdl(\*STDOUT, $fh);
\end{verbatim}
\begin{verbatim}
  $fh = $Prt->outhdl;
\end{verbatim}


Default is to use STDOUT.


\item[{warhdl}] \mbox{}

Warning output file handle(s). These are the filehandles that are used
to print all warning messages. Multiple filehandles can be supplied.
Returns an IO::Tee object that can be used as a single filehandle.

\begin{verbatim}
  $Prt->warhdl(\*STDOUT, $fh);
\end{verbatim}
\begin{verbatim}
  $fh = $Prt->warhdl;
\end{verbatim}


Default is to use STDOUT.


\item[{errhdl}] \mbox{}

Error output file handle(s). These are the filehandles that are used
to print all error messages. Multiple filehandles can be supplied.
Returns an IO::Tee object that can be used as a single filehandle.

\begin{verbatim}
  $Prt->errhdl(\*STDERR, $fh);
\end{verbatim}
\begin{verbatim}
  $fh = $Prt->errhdl;
\end{verbatim}


Default is to use STDERR.


\item[{\textbf{errbeep}}] \mbox{}

Specifies whether the terminal is to beep when an error
message is printed. Default is not to beep (false).

\begin{verbatim}
  $dobeep = $Prt->errbeep;
\end{verbatim}

\item[{debughdl}] \mbox{}

This specifies the debug file handle. Defaults to STDERR if not 
defined. Returns an IO::Tee object that can be used as a single
filehandle.

\end{description}
\paragraph*{Methods\label{ORAC::Print_Methods}\index{ORAC::Print!Methods}}
\begin{description}

\item[{out(text, [col])}] \mbox{}

Print output messages.
By default messages are written to STDOUT. This can be overridden with
the outhdl() method.


\item[{say( text, [col] )}] \mbox{}

Print output messages, appending a carriage return to the text string.



By default messages are written to STDOUT. This can be overridden with the outhdl() method.


\item[{war(text, [col])}] \mbox{}

Print warning messages.
Default is to print warnings to STDOUT. This can be overriden with
the warhdl() method.


\item[{carp(text, callers, [col])}] \mbox{}
\item[{orac\_carp( text, callers, [colour])}] \mbox{}

Prints the supplied text as a warning message and appends the line number
and name of the parent primitive. This information is obtained from the
standard \$\_PRIM\_CALLERS\_ variable available to each primitive.


\item[{err(text, [col])}] \mbox{}

Print error messages.
Default is to use STDERR. This can be overriden with the errhdl()
method.


\item[{throw (text,[colour])}] \mbox{}\begin{verbatim}
  $prt->throw("An error message");
\end{verbatim}


Same as \texttt{err} method except that an exception of type
\texttt{ORAC::Error::FatalError} is thrown immediately after the error
message is printed.



The message itself is part of the exception that is thrown.


\item[{debug (text)}] \mbox{}

Prints debug messages to the debug filehandle so long as debugging
is turned on.


\item[{tk\_update ( )}] \mbox{}

Does an Tk update on the Main Window widget

\end{description}
\subsubsection*{TIED INTERFACE\label{ORAC::Print_TIED_INTERFACE}\index{ORAC::Print!TIED INTERFACE}}


An ORAC::Print object can also be tied to filehandle using the
tie command:

\begin{verbatim}
  tie *HANDLE, 'ORAC::Print', $prt, 'out|war|err';
\end{verbatim}


where \$prt is an ORAC::Print object. Currently all strings printed
to this handle will be redirected to the orac\_print command
(and will therefore use the output filehandles associated with the
most recent ORAC::Print object created). The default color used
by the tied handle can be set using the outcol() method of the
object associated with the filehandle

\begin{verbatim}
  $prt = new ORAC::Print;
  $prt->outcol('clear');
  tie *HANDLE, 'ORAC::Print', $prt;
\end{verbatim}


will result in all messages printed to HANDLE, being printed
with no color codes to STDOUT.



The optional fourth argument to the tie() command can be used
to set the default output stream. Allowed values are 'out',
'war' and 'err'. These correspond directly to the orac\_print,
orac\_warn and orac\_err commands. Default is to use orac\_print
for all tied filehandles.



It is not possible to read from this tied filehandle.

\subsubsection*{SEE ALSO\label{ORAC::Print_SEE_ALSO}\index{ORAC::Print!SEE ALSO}}


\emph{Term::ANSIColor}, \emph{IO::Tee}.

\subsubsection*{REVISION\label{ORAC::Print_REVISION}\index{ORAC::Print!REVISION}}


\$Id: Print.pm 8109 2008-09-08 21:27:28Z bradc \$

\subsubsection*{COPYRIGHT\label{ORAC::Print_COPYRIGHT}\index{ORAC::Print!COPYRIGHT}}


Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council. All Rights Reserved.

\subsection{ORAC::TempFile\label{ORAC::TempFile}\index{ORAC::TempFile}}


Generate temporary files for ORAC-DR

\subsubsection*{SYNOPSIS\label{ORAC::TempFile_SYNOPSIS}\index{ORAC::TempFile!SYNOPSIS}}
\begin{verbatim}
  use ORAC::TempFile;
\end{verbatim}
\begin{verbatim}
  $temp = new ORAC::TempFile;
  $temp = new ORAC::TempFile(0);
  $fname = $temp->file;
  print {$temp->handle} "Some temporary data";
\end{verbatim}
\begin{verbatim}
  $temp->handle->close; # Close temporary file
\end{verbatim}
\begin{verbatim}
  undef $temp;          # Close file and remove it
\end{verbatim}
\subsubsection*{DESCRIPTION\label{ORAC::TempFile_DESCRIPTION}\index{ORAC::TempFile!DESCRIPTION}}


Provide a simplified means of handling temporary files from within
ORAC-DR. The temporary file is automatically removed when the
object goes out of scope.



The temporary file name can also be used as a temporary name for
NDF files. NDF files (extension '.sdf') are automatically deleted
in addition to the temporary file created by this class.

\subsubsection*{PUBLIC METHODS\label{ORAC::TempFile_PUBLIC_METHODS}\index{ORAC::TempFile!PUBLIC METHODS}}


The following methods are available in this class.

\paragraph*{Constructor\label{ORAC::TempFile_Constructor}\index{ORAC::TempFile!Constructor}}


The following constructors are available:

\begin{description}

\item[{\textbf{new}}] \mbox{}

Create a new instance of a \textbf{ORAC::TempFile} object.

\begin{verbatim}
  $temp = new ORAC::TempFile;
\end{verbatim}


If a false argument is supplied the temporary file
name will be allocated (and the file opened) but the 
file itself will be closed before the new object is returned.
This is so that the temporary file name can be passed directly
to another process without wanting to write anything to the
file yourself (for example if you want to generate a file
in an external program and then read the results back into
perl).

\begin{verbatim}
  $temp = new ORAC::TempFile(0);
\end{verbatim}


Returns 'undef' if the tempfile could not be created.
The file is opened for read/write with autoflush set to true.
The file should be closed (using the close() method on the
object file handle) before sending the file name to an external
process (unless a false argument is supplied to the constructor).

\begin{verbatim}
  $temp->handle->close;
\end{verbatim}


An argument hash is also supported. These arguments are OPEN and
SUFFIX. OPEN is the equivalent of passing in a solitary false
argument. SUFFIX appends the given suffix to the temporary
filename. For example, to create a temporary file with a closed
filehandle and a .txt suffix, one would do:

\begin{verbatim}
  $temp = new ORAC::TempFile( OPEN => 0,
                              SUFFIX => '.txt' );
\end{verbatim}


Note that if you pass in an argument hash you cannot have a solitary
false argument to return a closed file; if you wish to return a closed
file in conjunction with setting a suffix, you must use the OPEN named
argument.

\end{description}
\paragraph*{Accessor Methods\label{ORAC::TempFile_Accessor_Methods}\index{ORAC::TempFile!Accessor Methods}}


The following methods are available for accessing the 
'instance' data.

\begin{description}

\item[{\textbf{handle}}] \mbox{}

Return (or set) the file handle associated with the temporary 
file.

\begin{verbatim}
  print {$tmp->handle} "some information\n";
\end{verbatim}

\item[{\textbf{file}}] \mbox{}

Return the file name associated with the temporary file.

\begin{verbatim}
  $name = $tmp->file;
\end{verbatim}


The file name is also returned on stringification of the object.

\end{description}
\paragraph*{Destructor\label{ORAC::TempFile_Destructor}\index{ORAC::TempFile!Destructor}}


This section details the object destructor.

\begin{description}

\item[{\textbf{DESTROY}}] \mbox{}

The destructor is run when the object goes out of scope
or no longer has any references to it. When called, the
temporary file is closed and unlinked. If necessary
and files of the same name but with a '.sdf' extension
are also unlinked. This allows the same class to be used
for temporary plain files and temporary NDF files.



No files are removed if the debugging flag (\$DEBUG) is set to
true (the default is false)

\end{description}
\subsubsection*{PRIVATE METHODS\label{ORAC::TempFile_PRIVATE_METHODS}\index{ORAC::TempFile!PRIVATE METHODS}}


The following methods are intended for use inside the module.
They are included here so that authors of derived classes are 
aware of them.

\begin{description}

\item[{\textbf{Initialise}}] \mbox{}

This method is used to initialise the object. It is called
automatically by the object constructor. It generates
a temporary file name and attempts to open it. If the 
open is not successful the state of the object remains 
unchanged. In general, this means that the object
constructor has failed.

\end{description}
\subsubsection*{GLOBAL VARIABLES\label{ORAC::TempFile_GLOBAL_VARIABLES}\index{ORAC::TempFile!GLOBAL VARIABLES}}


The following global variables are available.
They can be accessed directly or via Class methods of the same name.

\begin{itemize}

\item \$VERSION

The current version number of this module.

\begin{verbatim}
  $version = $ORAC::TempFile::VERSION;
  $version = ORAC::TempFile->VERSION;
\end{verbatim}

\item \$DEBUG

Debugging flag. When this flag is set to true the temporary
files are not deleted by the object destructor. They can be
examined at a later time.

\begin{verbatim}
  $debug = ORAC::TempFile->DEBUG;
  ORAC::TempFile->DEBUG(1);
  $ORAC::TempFile::DEBUG = 0;
\end{verbatim}
\end{itemize}
\subsubsection*{SEE ALSO\label{ORAC::TempFile_SEE_ALSO}\index{ORAC::TempFile!SEE ALSO}}


\emph{IO::File}, \emph{File::MkTemp}, \textsf{tmpnam()} in \emph{POSIX}

\subsubsection*{REVISION\label{ORAC::TempFile_REVISION}\index{ORAC::TempFile!REVISION}}


\$Id: TempFile.pm 7738 2008-05-09 01:21:33Z timj \$

\subsubsection*{COPYRIGHT\label{ORAC::TempFile_COPYRIGHT}\index{ORAC::TempFile!COPYRIGHT}}


Copyright (C) 2008 Science and Technology Facilities Council.
Copyright (C) 1998-2001 Particle Physics and Astronomy Research
Council. All Rights Reserved.

